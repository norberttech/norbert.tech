{% extends 'blog/post.html.twig' %}

{%- block title -%}
    {{ post.title }}
{%- endblock -%}

{%- block description -%}
    {{ post.description }}
{%- endblock -%}

{%- block og_img -%}
{{ asset('images/blog/dark-sides-of-modularization/roots.jpg') }}
{%- endblock -%}

{%- block og_img_type -%}
image/jpeg
{%- endblock -%}

{%- block og_img_alt -%}
    {{ post.title }}
{%- endblock -%}


{% block article %}
    <div class="img-wide">
        <img src="{{ asset('images/blog/dark-sides-of-modularization/roots.jpg') }}" alt="{{ post.title }}" />
    </div>

    <h1 class="font-bold text-4xl mb-2" id="title">{{ post.title }}</h1>
    <div class="mb-2">
        <small class="text-sm">Published {{ post.date | date }}</small>
    </div>
    <div class="mb-4">
        {% for label in post.labels %}
            <small><span class="badge badge-info">{{ label }}</span></small>
        {% endfor %}
    </div>

    <a href="#introduction"><h2 id="introduction">Introduction</h2></a>
    <p>
        I recently ran into a pretty interesting problem that got me thinking about the less glamorous aspects
        of modularization - you know, the stuff we don't usually hear about at conferences or workshops.
    </p>
    <p>
        Let's start with the basics. What exactly is modularization? Simply put, it's breaking down
        a system into independent parts (modules), where each one has:
    </p>
    <ul>
        <li>A clearly defined responsibility</li>
        <li>Communication through defined protocols</li>
        <li>The ability to be developed independently from other modules</li>
    </ul>
    <p>
        In a nutshell, it's a nod toward the <strong>divide and conquer</strong> principle. Instead of wrestling
        with one massive, complicated, tangled problem, we break it into smaller problems that are much easier
        to solve.
    </p>

    <p>
        A lot of people hear "modularization" and immediately think "microservices." So before we go any further, let's clear one thing up.
        Microservices are just one way to implement modularization, same as a modular monolith.
    </p>

    <a href="#current-state"><h2 id="current-state">The Current State</h2></a>

    <p>
        Picture a system made up of three modules.
    </p>
    <div class="notice">
        <p>
            <strong>Note:</strong> The diagram below is a very simplified model - its only purpose is
            to illustrate the problem.
        </p>
    </div>
    <ul>
        <li><code>IAM</code> Module (Identity and Access) - users / groups / permissions</li>
        <li><code>Module A</code> - resource management</li>
        <li><code>Module B</code> - different resource management</li>
    </ul>

    <div class="img-wide">
        <a href="{{ asset('images/blog/dark-sides-of-modularization/problem.png') }}" target="_blank">
            <img src="{{ asset('images/blog/dark-sides-of-modularization/problem.png') }}" alt="Dark Sides of Modularization - problem" />
        </a>
    </div>

    <p>
        The permissions system here is a bit complex. It's mainly based on <code>ACL</code> (Access Control List),
        which means granting permissions to resources directly to users or groups.
    </p>
    <p>
        On top of that, there's also some <code>RBAC</code> (Role Based Access Control), where users with specific
        roles have defined permissions to specific parts of the system.
    </p>
    <p>
        We also have partial <code>ABAC</code> (Attribute Based Access Control), where permissions are derived from user attributes,
        in this case, group membership.
    </p>
    <p>
        Sound familiar? This isn't as unique a case as you might think. But anyway, let's get to the point.
    </p>
    <a href="#problem"><h2 id="problem">The Problem</h2></a>
    <p>
        As you can see in the diagram, the permission system is defined in the <code>IAM</code> module - that's where we store
        information about:
    </p>
    <ul>
        <li>Users and their roles</li>
        <li>Groups that users belong to</li>
        <li>Permissions for specific resources</li>
    </ul>
    <p>
        Modules A and B, meanwhile, are responsible for managing their own resources but need to verify
        that a given user has access to a specific resource.
    </p>
    <p>
        So the module dependency scheme looks like this: Modules A and B know about the existence of the IAM module (they're
        dependent on it), but the IAM module itself has no clue that Modules A and B exist.
    </p>
    <div class="img-wide">
        <a href="{{ asset('images/blog/dark-sides-of-modularization/dependencies.png') }}" target="_blank">
            <img src="{{ asset('images/blog/dark-sides-of-modularization/dependencies.png') }}" alt="Dark Sides of Modularization - Dependencies" />
        </a>
    </div>
    <p>
        The problem the team ran into was this: "How do we create a paginated list of resources in a given module based on user permissions?"
    </p>
    <p>
        Additionally, the resource list needs to allow:
    </p>
    <ul>
        <li>Filtering based on resource characteristics</li>
        <li>Sorting based on resource characteristics</li>
        <li>Returning only a selected page</li>
    </ul>
    <p>
        These requirements make implementation significantly harder. If we didn't have filtering/pagination, we could just
        hit the <code>IAM</code> module directly with a request to return resources for a given user.
    </p>
    <div class="important">
        <p>
            Resource characteristics are all their parameters and attributes that make sense and have meaning mainly within their
            own context. Example resource characteristics might be its name or creation date. These are parameters that
            the user should be able to sort or filter by, but they don't exist in the <code>IAM</code> module.
        </p>
    </div>
    <p>
        But without resource characteristics that we can filter/sort by, the <code>IAM</code> module can at best return all resources,
        and we'd have to do the filtering on the module side. Not exactly a scalable solution.
    </p>
    <p>
        Not knowing how to get out of this situation, the team decided (consciously or not) to break the rules of modularization and couple
        the modules at the database level.
    </p>
    <p>
        Since the system is deployed as a modular monolith and each module has access to the same database (each module has its own tables with an appropriate prefix),
        theoretically nothing stands in the way of building an SQL query that returns a list of resources for a specific module
        and joining it with permission tables from the <code>IAM</code> module to filter out resources the user doesn't have access to.
    </p>
    <p>
        Quick, simple, and it even works.
    </p>
    <p>
        This could probably coexist peacefully, except for one new requirement: we need to extract one of the modules from
        the monolith...
    </p>
    <p>
        And here's where things get messy. How do you extract Module A as an independent service when it's tightly coupled at the
        database level with the IAM module? If we remove the <code>join</code> to the <code>IAM</code> tables, access control will
        stop working.
    </p>
    <p>
        Below, I'll present techniques that will allow us to extract this module from the monolith without losing functionality, breaking
        modularization rules, or changing dependencies between modules.
    </p>
    <div class="notice">
        <p>
            When designing a modular monolith, it's worth trying a slightly different approach.
            Instead of prefixing tables, you can create separate databases/schemas for each module within a single database server,
            which makes it much harder to create accidental coupling at the SQL query level.
        </p>
    </div>
    <a href="#division-of-responsibility"><h2 id="division-of-responsibility">Division of Responsibility</h2></a>
    <p>
        What if it wasn't the <code>IAM</code> module that was responsible for permissions granted to resources
        that only exist in a specific module?
    </p>
    <p>
        One possible approach (probably the best for many) is separation of responsibilities, meaning <code>IAM</code>
        handles authorization, users, their roles, and the groups they're assigned to.
    </p>
    <p>
        The modules themselves manage the permission rules for resources. In practice, this means moving the <code>access_rules</code> tables
        to <code>Module A</code> and <code>Module B</code>.
    </p>
    <p>
        The result would be an architecture similar to the one below:
    </p>
    <div class="img-wide">
        <a href="{{ asset('images/blog/dark-sides-of-modularization/separation.png') }}" target="_blank">
            <img src="{{ asset('images/blog/dark-sides-of-modularization/separation.png') }}" alt="Dark Sides of Modularization - Separation" />
        </a>
    </div>
    <p>
        None of the modules need to make trips to <code>IAM</code> to get a list of resources available
        to a selected user.
    </p>
    <p>
        We do have some duplication - we basically need to repeat the permission logic for each existing module
        and hook it into the existing module mechanisms.
    </p>
    <div class="notice">
        <p>
            <strong>Note:</strong> Here you might be tempted to create a component.
            Unless you have people on your teams who are experienced in building libraries/components, it's best to start
            with duplication. In the long run, duplication hurts way less than the wrong abstraction.
        </p>
    </div>
    <p>
        But is that enough?
    </p>
    <p>
        Not quite. If we look at the permissions table, we'll notice that permissions can be granted directly
        to a user or to a group that the user belongs to.
    </p>
    <p>
        This means that in <code>Module A</code>, we grant permissions to a resource for group <code>Group 01</code>, which includes
        <code>User 01</code> and <code>User 02</code>.<br/>
        Thanks to this, both users have access to the resource.
    </p>
    <p>
        But what if we remove a user from the selected group?
    </p>
    <p>
        We can approach this in two ways:
    </p>
    <ol>
        <li>During each access verification, we query the <code>IAM</code> module for the user's list of groups</li>
        <li>We accept <code>eventual consistency</code> and keep user groups in the session, refreshing it every few/dozen minutes</li>
    </ol>

    <p>
        The first solution is simplest to implement, doesn't violate module responsibility boundaries, but might
        become a bottleneck pretty quickly.
    </p>
    <p>
        Of course, this won't happen immediately. Plus, due to the nature of the data (more reads than writes), we can
        also offload the database through appropriate caching mechanisms.
    </p>
    <p>
        For solution number two, we need to make sure this is even an acceptable solution from a business
        perspective.
    </p>
    <a href="#projection"><h2 id="projection">Projection</h2></a>
    <p>
        Another approach to solving the problem is keeping the permission structure in the <code>IAM</code> module but
        introducing mechanisms that allow <code>Module A</code> and <code>Module B</code> to sync
        the permissions table to a local projection.
    </p>
    <p>
        This projection is nothing more than a simplified form of the <code>access_rules</code> table replicated in a specific module.
    </p>
    <p>
        As a result, we still get some duplication, but <code>Module A</code> and <code>Module B</code>
        don't focus on managing permissions - that responsibility is still delegated to the <code>IAM</code> module.
    </p>
    <p>
        Their responsibility is reduced to syncing permissions with the permissions module.
    </p>
    <p>
        But how and when do we perform this sync? Every time we grant permissions to a resource.
    </p>
    <p>
        <code>Module A</code>, when granting permissions to a user or group for some resource, first
        communicates with the <code>IAM</code> module.
    </p>
    <p>
        We do the same when revoking access to a resource. First, we remove the entry in the <code>IAM</code> module, then
        we remove the entry in the local projection.
    </p>
    <p>
        But what if we remove a user from a selected group?
    </p>
    <p>
        Here we basically return to the same problem we had in the previous approach. We can either
        fetch the user's list of groups from the <code>IAM</code> module each time, or accept <code>eventual consistency</code>.
    </p>
    <p>
        The difference between separation and projection is very small. But with projections, we can take it a step further.
    </p>
    <a href="#events"><h2 id="events">Events</h2></a>
    <p>
        The <code>IAM</code> module can also propagate events related to:
    </p>
    <ul>
        <li>Adding a user to groups</li>
        <li>Removing a user from a group</li>
        <li>Deleting a group</li>
    </ul>
    <p>
        To maintain the proper dependency structure, these events can't be published "to a specific recipient."
        We need to apply a Pub/Sub approach here, where <code>IAM</code> publishes events to a specific
        <code>Topic</code>, which interested modules can subscribe to.
    </p>
    <p>
        Thanks to this, both modules will receive a copy of the same event, which they can handle independently.
    </p>
    <p>
        When building a projection, we can also significantly simplify its structure by breaking down groups into user lists.
    </p>
    <p>
        If a group receives <code>access</code> permission to some resource, instead of storing
        one entry in the projection representing the group, we can create an entry for each user in the group.
    </p>
    <p>
        Thanks to this, during access verification, we don't need to ask the <code>IAM</code> module for anything at all. We just need to
        respond appropriately to events propagated by the <code>IAM</code> module:
    </p>
    <ul>
        <li>Adding a user to a group</li>
        <li>Removing a user from a group</li>
        <li>Deleting a group</li>
    </ul>
    <p>
        Basically, only these events matter to us. Adding a group or user doesn't really affect anything,
        so we can safely ignore/filter them out.
    </p>
    <a href="#events-reliability"><h2 id="events-reliability">Event Reliability</h2></a>
    <p>
        Of course, an event-based approach carries certain risks. One of them is, for example, disrupted event order.<br/>
        For instance, we first get a "user removed from group" event, and only later the "user added" event, when
        in reality these events occurred in the opposite order.
    </p>
    <p>
        Yeah, this can be a problem, especially when the message containing the event also includes
        all the details of that event.
    </p>
    <p>
        But we can deal with this by deciding to use anemic events - that is, events that basically
        only contain identifiers of the resources they concern, and for everything else you need to go to the source module.
    </p>
    <p>
        Let's compare both approaches using the <code>UserRemovedFromGroup</code> event as an example:
    </p>

    <p><strong>Rich Event</strong></p>
    <pre><code class="language-json" {{ stimulus_controller('syntax_highlight') }}>{{ source(template_folder ~ '/code-examples/rich-event.json') | e('html') }}</code></pre>

    <p><strong>Anemic Event</strong></p>
    <pre><code class="language-json" {{ stimulus_controller('syntax_highlight') }}>{{ source(template_folder ~ '/code-examples/anemic-event.json') | e('html') }}</code></pre>

    <p>
        The difference is fundamental. With a rich event, all information about the user, group, and permissions
        is contained in the event. If the order of events gets disrupted, our projection can end up in an inconsistent state.
    </p>
    <p>
        An anemic event, on the other hand, only contains identifiers. After receiving such an event, the consumer must
        make an additional query to the <code>IAM</code> module to get the current state. Thanks to this, regardless of the order
        events are received, we'll always get the most up-to-date version of the data.
    </p>

    <p><strong>Problematic Scenario for Rich Events</strong></p>
    <p>
        Let's imagine the following sequence of events in the <code>IAM</code> module:
    </p>
    <ol>
        <li><code>10:00:00</code> - User added to "Administrators" group</li>
        <li><code>10:00:05</code> - User removed from "Administrators" group</li>
    </ol>
    <p>
        The consumer in Module A receives events in reverse order:
    </p>
    <ol>
        <li>Receives <code>UserRemovedFromGroup</code> (with data from 10:00:05)</li>
        <li>Receives <code>UserAddedToGroup</code> (with data from 10:00:00)</li>
    </ol>
    <p>
        With <strong>rich events</strong>, the projection in Module A shows that the user <strong>belongs</strong>
        to the group (because the last received event was "addition"), even though in reality they've already been removed from it.
    </p>
    <p>
        With <strong>anemic events</strong>, regardless of the order received, Module A will execute a query to IAM
        and get the current state - the user <strong>doesn't belong</strong> to the group.
    </p>

    <div class="notice">
        <p>
            Anemic events reduce the risk of inconsistency but don't eliminate it completely.
            There's still the possibility that between receiving the event and querying IAM,
            the state changes. So you might consider adding a version number or timestamp
            to events and checking them when updating the projection. Though safeguarding mechanisms
            will largely depend on traffic and frequency of changes.
        </p>
    </div>

    <p>
        Here's what it looks like:
    </p>
    <div class="img-wide">
        <a href="{{ asset('images/blog/dark-sides-of-modularization/events.png') }}" target="_blank">
            <img src="{{ asset('images/blog/dark-sides-of-modularization/events.png') }}" alt="Dark Sides of Modularization - Events" />
        </a>
    </div>
    <p>
        When Module A's consumer receives information, its job is to go to the <code>IAM</code> module and ask it
        for all rules for a specific group. The <code>IAM</code> module can return records from the permissions table concerning
        a specific group, and then, if any rules exist, we can ask for users in that group and in
        the module's local projection build a permission projection for them.
    </p>
    <p>
        We can also make life a bit easier for ourselves and add to the communication protocol with the <code>IAM</code> module the ability to
        fetch a flat structure of permissions, which returns not the group but a list of group users with permissions to
        a specific resource.
    </p>
    <div class="important">
        <p>
            <strong>Note:</strong> To provide additional guarantees of event delivery, consider
            implementing the <strong>Outbox</strong> pattern.
        </p>
    </div>
    <p>
        Wait, but won't the <code>IAM</code> module become a bottleneck again?
    </p>
    <p>
        Not exactly. What matters here isn't just the query itself but rather its frequency. Permission control is
        one of those processes where we ask about permissions way more often than we change them.
    </p>
    <p>
        Of course, don't just take my word for it - if you have an existing system with permission control, it's worth simply measuring it.
    </p>
    <p>
        But getting back to the point, when using anemic events, we don't have to worry as much about
        the order they're received. We're not relying on the event's content but only on the resource identifier it
        concerns, which makes building projections much easier.
    </p>
    <p>
        But this does have its cost - now after each event we need to go to the source to
        determine the actual state.
    </p>
    <p>
        So it's worth analyzing this approach from a performance perspective.<br/>
        There are more techniques for dealing with events, though. You can find one at <a href="https://event-driven.io/en/dealing_with_race_conditions_in_eda_using_read_models/" target="_blank">https://event-driven.io/</a>.
    </p>
    <a href="#duplication"><h2 id="duplication">Duplication</h2></a>
    <p>
        In both approaches, though, the problem of duplication comes up. Although in this case, "problem" is probably the wrong word.
        It's just a cost of modularization that simply isn't talked about.
    </p>
    <p>
        Regardless of whether we decide on separation of responsibilities or building projections, Modules A and B will
        duplicate permission-related logic to a greater or lesser extent.
    </p>
    <p>
        So regardless of our deployment model (monolith / microservices) and regardless of how we separate
        module boundaries and their responsibilities, we just need to prepare for this cost.
    </p>
    <p>
        My advice here is always to start with duplication. Even if our implementations don't differ at all
        between modules.
    </p>
    <p>
        It's much easier to extract common parts from existing solutions than to design common parts for solutions
        that don't exist yet.
    </p>
    <a href="#whats-better"><h2 id="whats-better">What's Better?</h2></a>
    <p>
        There's no clear-cut answer to this question. But we can try to analyze our situation and choose
        a solution that will let us extract one of the modules and get rid of database-level coupling.
    </p>
    <p>
        For the module that needs to be extracted, I'd suggest (if possible) separation of responsibilities and
        moving resource permission management to that module.
    </p>
    <p>
        Since we have to do some work anyway, since we have to physically separate this module from our monolith,
        we might as well go a step further and reduce its dependency on
        <code>IAM</code> even more at a relatively low cost.
    </p>
    <p>
        But does such an operation make sense for existing modules?
    </p>
    <p>
        For modules that don't need to be extracted and will continue living within the modular monolith, I'd suggest
        a projection-based approach, but not necessarily with events.
    </p>
    <a href="#projections-without-events"><h2 id="projections-without-events">Projections Without Events</h2></a>
    <div class="important">
        <p>
            This is a technique that won't work in a microservices approach but can help as a stopgap.
            Not just help, but also point the way forward. You can implement it at a low cost, getting
            basically the same thing as with an event-based approach.
        </p>
    </div>
    <p>
        Let's look at it from a different angle. Pub/Sub is basically a mechanism that allows us a certain form of replication.
        Thanks to events, we know that something happened at some point in some module.
    </p>
    <p>
        What if instead of publishing an event to a <code>Topic</code>, we used <code>Materialized Views</code>?
    </p>
    <p>
        Yeah, I know - many people are probably seeing red flags right now. I mean, materialized views?
        Logic on the database side instead of in code?
    </p>
    <p>
        Well, it's not an ideal solution. Sure, we get rid of SQL-level coupling, but in exchange
        we get different coupling - this time at the database level.
    </p>
    <p>
        But if we approach this pragmatically, we're basically just swapping the transport mechanism.
        Instead of building pub/sub, implementing the Outbox pattern, handling network communication errors, retries, etc.,
        we can just let the database handle data replication.
    </p>
    <p>
        If for any reason this stops working for us - like when refreshing the materialized view
        becomes too expensive and starts unnecessarily loading our database - nothing will stop us
        from switching to projections.
    </p>
    <p>
        But before we get to that point, we can also try putting the refresh process itself on a queue in the <code>IAM</code> module
        and executing it asynchronously. We'll get a slight delay, though in this case it should be at an acceptable level.
    </p>
    <p>
        The key thing to understand is that a <code>Materialized View</code> isn't a bad or good solution - it just gives us
        the ability to introduce a simplified separation relatively quickly without having to build the entire event-based mechanism.
    </p>
    <p>
        But when full separation/performance/vendor locking or anything else starts bothering us here, there shouldn't be major
        problems switching to projections.
    </p>
    <p>
        That's exactly what makes <code>Materialized View</code> an interesting solution.
    </p>
    <a href="#ideal-solution"><h2 id="ideal-solution">The Ideal Solution</h2></a>
    <p class="text-center">
        <strong>Doesn't exist...</strong>
    </p>
    <p>
        And that's probably the most important thing I want to get across in this article.
    </p>
    <p>
        Even if we manage to reduce the problem purely to technology, and even if by some miracle
        we all agree that problem A should be solved with pattern/technique/architecture B...
    </p>
    <p>
        None of that might matter because the business might simply not approve a major refactoring...<br/>
        And this doesn't have to be bad faith or ignorance - sometimes we just don't have the resources.
    </p>
    <p>
        It's hard to justify why we should spend time moving permission management to modules
        when everything works and generates profit.
    </p>
    <p>
        Just as hard as it'll be to argue why suddenly, with a requirement to extract one module, we have to fix
        all the others, adding asynchronous communication, events, retry mechanisms, recovery, etc.
    </p>
    <p>
        It's worth accepting that the world isn't perfect, isn't black and white, and we'll often have to
        choose between several imperfect solutions.
    </p>
    <p>
        What might seem absolutely incorrect in one place could be acceptable in another context,
        or even desirable.
    </p>
    <a href="#help"><h2 id="help">Help</h2></a>
    <p>
        If you're struggling with similar problems in your project and aren't quite sure how to solve them,<br/>
        <a href="{{ url('consulting') }}">get in touch with me</a>, and together we'll find a solution perfectly tailored to your needs.
    </p>
    <p>
        I also encourage you to visit <a href="https://discord.gg/5dNXfQyACW" target="_blank">Discord - Flow PHP</a>, where
        we can talk directly.
    </p>
    <div class="img-wide">
        <img src="{{ asset('images/blog/analytics-in-transactional-distributed-systems/consulting_01.jpg') }}" alt="Consulting" />
    </div>
{% endblock %}
