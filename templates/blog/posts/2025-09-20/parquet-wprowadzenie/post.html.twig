{% extends 'blog/post.html.twig' %}

{%- block title -%}
    {{ post.title }}
{%- endblock -%}

{%- block description -%}
    {{ post.description }}
{%- endblock -%}

{% block article %}
    <div class="img-wide">
        <img src="{{ asset('images/blog/parquet-introduction/parquet.jpeg') }}" alt="Parquet - Introduction" />
    </div>

    <h1 class="font-bold text-4xl mb-2" id="title">{{ post.title }}</h1>
    <div class="mb-2">
        <small class="text-sm">Data Publikacji {{ post.date | date }}</small>
    </div>
    <div class="mb-4">
        {% for label in post.labels %}
            <small><span class="badge badge-info">{{ label }}</span></small>
        {% endfor %}
    </div>
    <p>
        Parquet, binarny, kolumnowy format plików stworzony w celu wydajnego przechowywania oraz przeszukiwania danych.
    </p>
    <p>
        Artykułów na temat parquet jest w sieci całe mnóstwo, więc dlaczego kolejny?<br/>
        Jest to moje spojrzenie na ten fantastyczny format, będący w zasadzie wynikiem moich doświadczeń z pracy nad
        napisaniem implementacji parqueta w czystym PHP.
    </p>
    <p>
        Dla tych, którzy trafili tu przypadkiem, wspomnę tylko, że jestem autorem pierwszego frameworka do przetwarzania
        danych w PHP, o nazwie <a href="https://flow-php.com" target="_blank">Flow PHP</a>.<br/>
        Jak przystało na Data Frame, Flow musi umieć czytać i zapisywać dane w różnych formatach, w tym Parquet<br/>
    </p>
    <p>
        Ponieważ jednak jedyna implementacja, którą znalazłem, była w zasadzie bezpośrednim portem z C#, który w dodatku
        nie do końca radzi sobie z głęboko zagnieżdżonymi strukturami, oraz posiada sporo brakujących funkcji, postanowiłem
        w ramach nauki, napisać własną implementację od zera, co okazało się niezwykle cennym doświadczeniem ale i świetną
        zabawą.
    </p>
    <a href="#why-parquet"><h2 id="why-parquet">Dlaczego Parquet</h2></a>
    <ul>
        <li><a href="#binary-format">Format Binarny - nawet o 10x mniejszy rozmiar plików</a></li>
        <li><a href="#metadata">Metadata - łatwiejszy dostęp do wybranych danych</a></li>
        <li><a href="#schema">Schema - gwarancja poprawnej struktury</a></li>
        <li><a href="#compression">Kompresja - dodatkowa redukcja rozmiaru</a></li>
        <li><a href="#encryption">Szyfrowanie - na poziomie, pliku, metadanych, kolumn czy stron</a></li>
    </ul>

    <a href="#binary-format"><h2 id="binary-format">Format Binarny</h2></a>
    <p>
        Dzięki temu, że format ten jest zorientowany na kolumny, nie wiersze, pozwala na bardzo wydajną kompresję danych,
        co przekłada się na znacznie mniejszy rozmiar pliku. Bez większego wysiłku parquet potrafi skompresować dane nawet o <strong>10 razy</strong>,
        w porównaniu z tradycyjnymi formatami jak np. CSV czy XML.
    </p>
    <p>
        Jeżeli więc te same dane, zapisane w formacie CSV zajmują 1Gb, to w formacie parquet mogą zająć zaledwie 100Mb.<br/>
        Przekłada się to nie tylko na koszty przechowywania, ale i przetwarzania danych.<br/>
        Szczególnie kiedy nasze dane żyją w chmurze, czy to na Azure Bucket, czy AWS S3. Jednym z większych czynników wpływających
        na rachunek nie jest wcale rozmiar danych, a to ile transferu zużywamy, aby te dane odczytać / zapisać.
    </p>
    <p>
        Tak więc redukując rozmiar pliku, redukujemy nie tylko koszt jego przechowywania, ale również przetwarzania.
        Istotne jest jednak żeby zrozumieć, że przetwarzanie to tak naprawdę jakakolwiek forma dostępu, czyli zapis/odczyt.
    </p>
    <p>
        Sprowadza się to więc do tego, że poprzez wybór odpowiedniego formatu pliku, oszczędności mogą być naprawdę spore,
        szczególnie kiedy mówimy o większej ilości danych.
    </p>
    <p>
        Co to w ogóle znaczy, że Parquet jest formatem binarnym?
    </p>
    <p>
        Oznacza to mniej więcej tyle, że dane przechowywane są w postaci binarnej, czyli takiej, której nie da się
        bezpośrednio odczytać za pomocą popularnych edytorów tekstowych.
    </p>
    <p>
        No ale przecież wszystko finalnie przechowywane jest w postaci binarnej, nie?
    </p>
    <p>
        Tak, generalnie pliki tekstowe to też pliki binarne, różnica polega na tym, że w plikach tekstowych struktura
        pliku jest zawsze taka sama i każda informacja zapisywana jest w ten sam sposób.
    </p>
    <p>
        Przykładowo jeżeli chcielibyśmy zapisać "12345" w pliku tekstowym, wersja binarna będzie wyglądać następująco:
    </p>
    <pre><code class="code-shell" {{ stimulus_controller('syntax_highlight') }}>{{ source(template_folder ~ '/code-examples/binary-text.txt') | e('html') }}</code></pre>
    <p>
        Ten sam ciąg znaków zapisany w formacie binarnym jako int32 (integer w postaci 32 bitowej) będzie wyglądać tak:
    </p>
    <pre><code class="code-shell" {{ stimulus_controller('syntax_highlight') }}>{{ source(template_folder ~ '/code-examples/binary-integer.txt') | e('html') }}</code></pre>

    <p>
        Zauważmy, że w przypadku zapisu integera w formie binarnej, nie da się go po prostu odczytać od lewej do prawej (lub odwrotnie).
        Tutaj musimy już wiedzieć, jak interpretować te bity, aby zrozumieć co one oznaczają.
        W przypadku plików tekstowych nie mamy tego problemu, gdyż wiemy, że każdy znak jest zapisywany w postaci 8-bitowej.
    </p>
    <p>
        Mniej więcej dlatego dowolny edytor tekstu jest w stanie otworzyć każdy plik tekstowy i wyświetlić nam coś, co będzie miało mniej lub więcej sensu.
    </p>
    <p>
        Jeżeli jednak spróbujemy otworzyć plik typu parquet w edytorze tekstowym, dostaniemy ciąg znaków wyglądający bardzo losowo i nie mający większego sensu.
    </p>

    <a href="#columns-rows"><h2 id="columns-rows">Kolumnowy / Wierszowy</h2></a>
    <p>
        Najlepiej różnicę między tymi formatami wytłumaczyć za pomocą wizualizacji.
    </p>
    <p>
        W klasycznym modelu wierszowym każdy wiersz zawiera wszystkie kolumny, tak jak np. w formacie CSV
    </p>

    <pre><code class="code-shell" {{ stimulus_controller('syntax_highlight') }}>{{ source(template_folder ~ '/code-examples/rows.txt') | e('html') }}</code></pre>

    <p>
        Format kolumnowy jest o tyle ciekawy, że zamiast przechowywać dane wiersz po wierszu, przechowuje je kolumna po kolumnie.
    </p>

    <pre><code class="code-shell" {{ stimulus_controller('syntax_highlight') }}>{{ source(template_folder ~ '/code-examples/columns.txt') | e('html') }}</code></pre>

    <p>
        Przechowywanie danych w formacie kolumnowym przynosi bardzo wiele korzyści, takich jak:
    </p>
    <ul>
        <li>Dużo lepsza możliwość kompresji danych</li>
        <li>Możliwość odczytu tylko wybranych kolumn</li>
        <li>Możliwość szyfrowania wybranych lub wszystkich kolumn</li>
    </ul>

    <p>
        W przypadku formatu wierszowego, aby odczytać tylko jedną kolumnę, musimy i tak przejrzeć cały plik.<br/>
        W przypadku formatu kolumnowego możemy odczytać tylko te kolumny, które nas interesują.<br/>
        Jest to szczególnie przydatne w przypadku bardzo dużych zbiorów danych, gdzie często potrzebujemy tylko części informacji.
    </p>

    <a href="#metadata"><h2 id="metadata">Silna Struktura</h2></a>
    <p>
        Parquet jest formatem opartym o silne typowanie. Oznacza to, że struktura całego pliku jest zdefiniowana i przechowywana w stopce,
        dzięki czemu wystarczy odczytać tylko odpowiedni segment aby zrozumieć jakie dane mamy w pliku, oraz w których
        regionach pliku te dane są zapisane.
    </p>
    <p>
        Możemy o tym myśleć jak o mapie pliku, mapie, która powie nam gdzie w pliku dokładnie znajdują się dane, które
        nas interesują.
    </p>
    <p>
        Oto jak mniej więcej wygląda uproszczona struktura pliku w formacie parquet:
    </p>
    <pre><code class="code-shell" {{ stimulus_controller('syntax_highlight') }}>{{ source(template_folder ~ '/code-examples/basic-file-structure.txt') | e('html') }}</code></pre>

    <p>
        Na powyższym przykładzie widzimy 3 elementy:
    </p>

    <ul>
        <li><code>PAR1</code> - czyli "Parquet Magic Bytes" - 4 bajty otwierające i zamykające pliki w formacie parquet</li>
        <li><code>Data</code> - tutaj zapisane są wszystkie kolumny (o tym dalej)</li>
        <li><code>Metadata</code> - metadane, czyli mapa pliku</li>
    </ul>

    <p>
        Pierwszym krokiem do poprawnego odczytania pliku parqueta jest sprawdzenie czy pierwsze 4 bajty to <code>PAR1</code>.<br/>
        Jeżeli tak, musimy przeskoczyć do końca pliku (seek) i odczytać ostatnie 4 bajty.
    </p>
    <p>
        Jeżeli koniec i początek pliku zawierają <code>PAR1</code> możemy przystąpić do odczytu metadanych.
    </p>
    <p>
        W tym celu cofamy się o 8 bajtów od końca pliku i odczytujemy 4 bajty reprezentujące rozmiar metadanych.
        Innymi słowy, czytamy bajty <code>-8</code> do <code>-4</code>
    </p>
    <p>
        Te 4 bajty to <code>integer</code> mówiący o tym, na ilu bajtach zapisane są metadane. Mając
        tę informację możemy odczytać metadane, które są zserializowane binarnie za pomocą <a href="https://thrift.apache.org/" target="_blank">Apache Thrift</a>
    </p>
    <a href="#apache-thrift"><h2 id="apache-thrift">Apache Thrift</h2></a>
    <p>
        Apache Thrift to bardzo sprytne narzędzie pozwalające na binarną serializację interfejsów / typów w praktycznie każdym
        języku programowania.
    </p>
    <p>
        <a href="https://github.com/flow-php/flow/blob/1.x/src/lib/parquet/src/Flow/Parquet/Resources/Thrift/parquet_clean.thrift" target="_blank">Tutaj</a>
        możemy zobaczyć jak wygląda definicja metadanych w formacie parquet.
    </p>
    <p>
        Format ten przypomina trochę pseudokod, który następnie za pomocą odpowiedniej aplikacji jest użyty do wygenerowania
        kodu w danym języku programowania.
    </p>
    <p>
        <a href="https://github.com/flow-php/flow/tree/1.x/src/lib/parquet/src/Flow/Parquet/Thrift" target="_blank">Tutaj</a>
        możemy zobaczyć jak wygląda wygenerowany kod w PHP.
    </p>
    <p>
        Kiedy mamy już wygenerowane struktury / interfesy / modele możemy przystąpić do odczytu.
    </p>

    <pre><code class="code-php" {{ stimulus_controller('syntax_highlight') }}>{{ source(template_folder ~ '/code-examples/thrift.php') | e('html') }}</code></pre>

    <p>
        W tym celu będzie nam potrzebna biblioteka Thrift dla wybranego języka programowania.
        Wszystkie implementacje dostępne są w repozytorium <a href="https://github.com/apache/thrift" target="_blank">apache/thrift</a>.
    </p>

    <p>
        Mając dostęp do <code>$metadata</code> możemy zacząć analizować nasz plik, aby zrozumieć jego strukturę.<br/>
    </p>

    <a href="#parquet-file-metadata"><h2 id="parquet-file-metadata">Parquet - FileMetaData</h2></a>

    <pre><code class="code-shell" {{ stimulus_controller('syntax_highlight') }}>{{ source(template_folder ~ '/code-examples/file-metadata.txt') | e('html') }}</code></pre>

    <p>
        Kluczowe informacje na temat pliku przechowywane są w strukturze <code>FileMetaData</code>.
        Najważniejsze z nich to:
    </p>
    <ul>
        <li><code>version</code> - wersja formatu Parquet</li>
        <li><code>num_rows</code> - liczba wierszy w pliku</li>
        <li><code>schema</code> - schemat danych</li>
        <li><code>row_groups</code> - tutaj przechowywane są nasze dane</li>
    </ul>

    <a href="#format-versions"><h2 id="format-versions">Wersje Formatu</h2></a>
    <p>
        W czasie pisania tego artykułu format parquet był już dostępny w wersji <code>2.12.0</code>.
    </p>
    <p>
        Najbardziej kluczowe zmiany pomiędzy wersjami 1.0 a 2.0 to:
    </p>
    <ul>
        <li><strong>Nowe schematy kodowania:</strong> DELTA_BINARY_PACKED dla liczb, DELTA_BYTE_ARRAY dla stringów, RLE_DICTIONARY zastępujący PLAIN_DICTIONARY</li>
        <li><strong>Struktura Data Page V2:</strong> Wyeliminowano narzut metadanych, umożliwiono filtrowanie na poziomie stron</li>
    </ul>
    <p>
        Pomimo że wersja 2.0 wprowadza wiele ulepszeń, to jednak najwięksi gracze nadal domyślnie używają wersji 1.
    </p>
    <a href="#rows-count"><h2 id="rows-count">Liczba Wierszy</h2></a>
    <p>
        Ta informacja może na początku wydawać się mało intuicyjna w kontekście formatu kolumnowego.<br/>
        Musimy jednak pamiętać, że format kolumnowy to tylko sposób przechowywania wartości a nie struktury danych.
    </p>
    <p>
        Pomimo tego, że dane pogrupowane są na podstawie kolumn i swojego typu, odczyt/zapis nadal odbywa się w klasyczny
        sposób, czyli wiersz po wierszu.
    </p>
    <p>
        Różnica polega na tym, że nie odczytujemy jednego wiersza na raz, a całą grupę wierszy, wczytując do pamięci
        kolumnę po kolumnie, a następnie odbudowując wiersze na podstawie odpowiednich indeksów.
    </p>
    <blockquote>
        Pamiętając o tym, że aby odpowiednio zapisywać dane w formacie kolumnowym musimy operować na logicznych grupach, a nie na pojedynczych wierszach.
        Możemy w stosunkowo łatwy sposób zarządzać stosunkiem pamięci do ilości operacji IO.
    </blockquote>
    <p>
        Zapis i odczyt z pamięci jest szybszy niż zapis i odczyt z dysku (<a href="https://www.bitflux.ai/blog/memory-is-slow-part1/" target="_blank">chociaż nie zawsze</a>).
        Zwiększając ilość wierszy, które będą zapisane w jednej grupie, redukujemy ilość grup, czyli ilość operacji IO. <br/>
        Tym samym zwiększamy prędkość zapisu/odczytu, jednoczeście zwiększając zużycie pamięci.
    </p>
    <p>
        Działa to również w drugą stronę, redukując ilość wierszy w grupie, zwiększamy ilość grup w pliku, tym samym
        zwiększając ilość operacji IO.
    </p>
    <p>
        <strong>Rozmiar grupy, nie ilość wierszy</strong> - parquet pozwala definiować nie ilość wierszy, a maksymalny
        rozmiar grupy wierszy. <br/>
        Jednak należy pamiętać, że nie są to wartości bezwzględne (o tym nieco później), więc
        niektóre grupy mogą być mniejsze/większe niż dopuszczalny rozmiar i zależy to głównie od implementacji biblioteki
        do parqueta.
    </p>
    <p>
        W dokumentacji formatu parquet znajdziemy informację, że sugerowany rozmiar grupy to <code>512Mb - 1Gb</code>.
        Warto jednak podejść do tego z odrobiną rozsądku, szczególnie jeżeli do odczytu/zapisu nie polegamy na HDFS (Hadoop Distributed File System). <br/>
        Sugerowana wartość jest ustalona w taki sposób, aby jedna grupa wierszy mieściła się w jednym bloku HDFS, gwarantując, że odczyt
        odbędzie się z dokładnie jednego węzła.
    </p>
    <p>
        Warto o tym pamiętać, jeżeli jednak nie planujemy używać parqueta z rozproszonym systemem plików, mniejsze grupy
        wierszy pozwolą zaoszczędzić sporo pamięci.
    </p>
    <p>
        Bardzo dobrym przykładem, kiedy mniejsze grupy są wydajniejsze, jest przypadek, w którym chcielibyśmy odczytać
        tylko niewielki wycinek wierszy gdzieś z środka pliku (stronicowanie).
    </p>
    <p>
        Zakładając, że musimy odczytać tylko 100 wierszy z pliku, który zawiera 10 milionów wierszy, ustawienie mniejszego
        rozmiaru grupy pozwoli zaoszczędzić sporo na pamięci. Dlaczego?
    </p>
    <p>
        Jeżeli podzielimy 10 mln na powiedzmy 10 grup, każda grupa zawiera 1 mln wierszy. Oznacza to, że w praktyce
        musimy odczytać całą grupę, a następnie wyciągnąć tylko 100 wierszy, które nas interesują.
    </p>
    <p>
        W przypadku ustalenia mniejszego rozmiaru grupy, który pozwoli podzielić 10 mln na 1000 grup, analizując
        metadane pliku, będziemy mogli przeskoczyć większą ilość grup i wczytać do pamięci dużo mniejszą ilość wierszy.
    </p>
    <blockquote>
        Decyzja o rozmiarze grupy wierszy powinna być przemyślana zarówno pod kątem wydajności zapisu jak i odczytu
        konkretnego pliku. Odpowiednia konfiguracja przekłada się bezpośrednio na zużycie zasobów co finalnie przekłada się
        na pieniądze.
    </blockquote>

    <a href="#schema"><h2 id="schema">Schema</h2></a>

    <p>
        Powoli dochodzimy do sedna parqueta, czyli <code>Row Groups</code>. Zanim jednak przeanalizujemy ich strukturę, musimy
        cofnąć się do kolejnego bardzo ważnego aspektu parquet'a, schematu danych.
    </p>

    <p>
        Zacznijmy od typów danych. Parquet składa się z typów fizycznych i logicznych.
    </p>

    <h3>Physical Types</h3>

    <p>
        Typy fizyczne to podstawowe typy danych, które są używane do przechowywania wartości w pliku parquet.
        Są to typy takie jak:
    </p>

    <ul>
        <li>Boolean</li>
        <li>Byte Array</li>
        <li>Double</li>
        <li>Fixed Len Byte Array</li>
        <li>Float</li>
        <li>Int32</li>
        <li>Int64</li>
        <li>Int96 - (deprecated - używany jedynie przez starsze implementacje)</li>
    </ul>

    <p>
        Typy logiczne to typy, które są używane do reprezentowania bardziej złożonych struktur danych. Można
        o nich myśleć jak o rozszerzeniu typów fizycznych.
    </p>

    <h3>Logical Types</h3>

    <ul>
        <li>Bson</li>
        <li>Date</li>
        <li>Decimal</li>
        <li>Enum</li>
        <li>Integer</li>
        <li>Json</li>
        <li>List</li>
        <li>Map</li>
        <li>String</li>
        <li>Time</li>
        <li>Timestamp</li>
        <li>Uuid</li>
    </ul>

    <p>
        Aktualną strukturę zawsze można sprawdzić u źródła, <a href="https://github.com/apache/parquet-format/blob/master/src/main/thrift/parquet.thrift" target="_blank">apache/parquet-format</a>
    </p>

    <p>
        Poza podziałem na typy logiczne oraz fizyczne parquet rozróżnia też kolumny płaskie, oraz zagnieżdżone.<br/>
        <strong>Kolumny płaskie</strong> to takie, które przechowują pojedynczą wartość, np. <code>Int32</code>, <code>Boolean</code>, <code>Float</code> itp.<br/>
        <strong>Kolumny zagnieżdżone</strong> to takie, które przechowują więcej niż jedną wartość, np. <code>List</code>, <code>Map</code> itp.
    </p>

    <p>
        W zasadzie istnieją 3 rodzaje kolumn zagnieżdżonych:
    </p>
    <ul>
        <li>List</li>
        <li>Map</li>
        <li>Struct</li>
    </ul>
    <p>
        <strong>Struct</strong>, to specjalny typ kolumny, który pozwala na zagnieżdżenie dowolnych innych typów, pozwalając stworzyć
        praktycznie dowolną strukturę danych.
    </p>
    <p>
        Za pomocą powyższych typów jesteśmy w stanie zamodelować praktycznie dowolną
        strukturę danych, a następnie efektywnie ją przechowywać i przeszukiwać.
    </p>
    <p>
        Popatrzmy więc na definicje Thrift <code>SchemaElement</code> oraz kilku powiązanych elementów.
    </p>

    <pre><code class="code-shell" {{ stimulus_controller('syntax_highlight') }}>{{ source(template_folder ~ '/code-examples/schema-element.txt') | e('html') }}</code></pre>

    <p>
        Większość wartości powinna być w miarę oczywista, popatrzmy jednak na <code>FieldRepetitionType</code>.
    </p>

    <p>
        Ta wartość mówi nam o tym, czy dana kolumna jest wymagana, opcjonalna czy powtarzalna.<br/>
        Jeżeli kolumna jest wymagana, oznacza to, że wartość nie może być nullem. <br/>
        Jeżeli kolumna jest opcjonalna wartość może być nullem, a jeżeli jest powtarzalna, oznacza to, że może zawierać wiele wartości (np. listę).
    </p>

    <p>
        Oto jak może wyglądać schemat pliku z zamówieniami (w postaci DDL)
    </p>

    <pre><code class="code-shell" {{ stimulus_controller('syntax_highlight') }}>{{ source(template_folder ~ '/code-examples/schema-ddl.txt') | e('html') }}</code></pre>

    <a href="#nested-types"><h2 id="nested-types">Typy Zagnieżdżone</h2></a>

    <p>
        Aby w pełni zrozumieć strukturę grup wierszy musimy najpierw zrozumieć w jaki sposób parquet spłaszcza typy zagnieżdżone.<br/>
        O ile proste struktury jak <code>address</code> z powyższego przykładu można sprowadzić w zasadzie do 4 kolumn prostych:
    </p>
    <ul>
        <li><code>address.street</code> - String</li>
        <li><code>address.city</code> - String</li>
        <li><code>address.zip</code> - String</li>
        <li><code>address.country</code> - String</li>
    </ul>
    <p>
        Tak w przypadku <code>Map</code> czy <code>List</code> sytuacja jest trochę bardziej skomplikowana.
    </p>
    <p>
        Przykładowo, jeżeli chcielibyśmy spłaszczyć <code>{{ 'Map<string,int32>'|e }}</code> otrzymamy coś takiego:
    </p>
    <ul>
        <li><code>map_column.key_value.key</code> - String</li>
        <li><code>map_column.key_value.value</code> - Int32</li>
    </ul>
    <p>
        Tak więc dla powyższego przykładu płaska ścieżka do <code>sku</code> będzie wyglądać następująco:
        <code>items.list.element.sku</code>, natomiast spłaszczona kompletna struktura będzie wyglądać tak:
    </p>
    <pre><code class="code-shell" {{ stimulus_controller('syntax_highlight') }}>{{ source(template_folder ~ '/code-examples/schema-flat.txt') | e('html') }}</code></pre>

    <a href="#row-groups"><h2 id="row-groups">Row Groups</h2></a>

    <pre><code class="code-shell" {{ stimulus_controller('syntax_highlight') }}>{{ source(template_folder ~ '/code-examples/row-groups.txt') | e('html') }}</code></pre>

    <p>
        Zgodnie z tym co już wiemy, plik parquet podzielony jest na grupy wierszy, zapis do pliku wygląda w uproszczeniu w taki sposób:
    </p>
    <ul>
        <li>1) utwórz plik i dodaj do niego 4 bajty <code>PAR1</code></li>
        <li>2) stwórz strukturę metadanych na podstawie schematu i trzymaj ją w pamięci</li>
        <li>3) spłaszcz przekazany wiersz (sprawdzając czy pasuje do schematu)</li>
        <li>4) zapisz spłąszczony wiersz w pamięci w postaci binarnej</li>
        <li>
            5) sprawdź czy rozmiar grupy wierszy którą aktualnie trzymamy w pamięci mieści sie w maksymalnym dopuszczalnym rozmiarze
            <ul>
                <li>a) zapisz grupę wierszy do pliku</li>
                <li>b) zaktualizuj metadane w pamięci dodając do nich metadane grupy, którą właśnie zapisaliśmy</li>
            </ul>
        </li>
        <li>
            6) wróć do kroku 2
        </li>
        <li>
            7) Zapisz metadane na końcu pliku po zapisaniu wszystkich grup wierszy
        </li>
        <li>
            8) Zamknij plik 4 bajtami <code>PAR1</code>
        </li>
    </ul>
    <blockquote>
        Oczywiście ten opis jest bardzo uproszczony, w rzeczywistości jest on trochę bardziej złożony, ponadto różne implementacje
        mogą się różnić w szczegółach.
    </blockquote>

    <p>
        Skupmy się na strukturze grupy wierszy, popatrzmy najpierw na definicje Thrift <code>RowGroup</code>.
    </p>

    <pre><code class="code-shell" {{ stimulus_controller('syntax_highlight') }}>{{ source(template_folder ~ '/code-examples/row-group-thrift.txt') | e('html') }}</code></pre>

    <p>
        Już na tym etapie widać, jak wiele informacji na temat konkretnej grupy wierszy jest przechowywanych w metadanych.<br/>
        Na razie jednak skupmy się na trzech polach:
    </p>
    <ul>
        <li><code>file_offset</code> - czyli ile bajtów od początku pliku należy przeskoczyć aby odczytać daną grupę</li>
        <li><code>total_byte_size</code> - na ilu bajtach zapisana jest grupa wierszy</li>
        <li><code>columns</code> - szczegółowe informacje o każdej kolumnie zapisanej w ramach danej grupy</li>
    </ul>

    <div class="important">
        <p>
            <strong>Ważne:</strong> każda grupa wierszy zawiera zawsze wszystkie kolumny zdefiniowane w schemacie.<br/>
            Nawet jeżeli na przestrzeni całej grupy kolumna zawiera tylko wartości null.
        </p>
    </div>

    <a href="#row-groups"><h2 id="row-groups">Column Chunks</h2></a>

    <p>
        Wejdźmy głębiej i przyglądnijmy się definicji Thrift <code>ColumnChunk</code>
    </p>
    <pre><code class="code-shell" {{ stimulus_controller('syntax_highlight') }}>{{ source(template_folder ~ '/code-examples/column-chunk-thrift.txt') | e('html') }}</code></pre>

    <div class="notice">
        <p>
            <strong>Pamiętaj:</strong> Wszystko na co do tej pory patrzyliśmy to dalej część metadanych. <br/>
            Oznacza to, że te wszystkie informacje na temat kolumn, grup wierszy czy samych danych otrzymamy odczytując
            tylko i wyłącznie końcówkę pliku, niezależnie czy plik ma 1Mb czy 1Tb.
        </p>
    </div>

    <p>
        Tutaj dochodzimy w zasadzie do miejsca pozwalającego nam na odczytanie danych z pliku. <br/>
        Zanim jednak to nastąpi musimy poznać ostatnią strukturę danych niezbędną do odczytu.
    </p>

    <a href="#row-groups"><h2 id="row-groups">Data Pages</h2></a>

    <p>
        <code>Pages</code>, czyli kolejny logiczny podział w strukturz pliku parqueta.<br/>
        <code>Row Group -> Column Chunk -> Data Pages</code>
    </p>

    <ul>
        <li><code>RowGroup</code> - grupa wierszy (partycja)</li>
        <li><code>ColumnChunk</code> - każda grupa wierszy zawiera dokładnie 1 <code>ColumnChunk</code> dla każdej kolumny w grupie</li>
        <li><code>Data Page</code> - strona, najmniejsza jednostka logiczna w parquecie agregująca dane</li>
    </ul>

    <p>
        Tak naprawdę odczyt parqueta sprowadza się do przeanalizowania struktury metadanych, zlokalizowania adresu początku konkretnej grupy wierszy, następnie
        konkretnej kolumny w grupie, a następnie przeiterowania i odczytania danych z każdej strony.
    </p>

    <p>
        Zanim jednak zaczniemy czytać strony, musimy zrozumieć czy mamy do czynienia z <code>DataPage</code>, <code>IndexPage</code> lub <code>DictionaryPage</code>.
    </p>
    <p>
        W tym celu najpierw odczytujemy <code>PageHeader</code> czyli nagłówek strony, którego definicja Thrift wygląda następująco
    </p>

    <pre><code class="code-shell" {{ stimulus_controller('syntax_highlight') }}>{{ source(template_folder ~ '/code-examples/page-header.txt') | e('html') }}</code></pre>

    <p>
        Aby odczytać nagłówek musimy znać jego adres względem początku pliku, oto jak możemy go obliczyć dla wybranej grupy wierszy i wybranej kolumny:
    </p>

    <ol>
        <li>Odczytujemy <code>FileMetadata</code></li>
        <li>Znajdujemy odpowiednia <code>RowGroup</code> i odszukujemy istotny dla nas <code>ColumnChunk</code></li>
        <li>Mając <code>ColumnChunk</code> otrzymamy adres <code>file_offset</code> początku <code>ColumnChunk</code> względem początku pliku.</li>
    </ol>

    <div class="important">
        <p>
            <strong>Ważne:</strong> Na tym etapie nie musimy jeszcze fizycznie wczytywać do pamięci bajtów.<br/>
            Wystarczy, że utworzymy <code>stream</code> pozwalający na odczytanie danych bezpośrednio z pliku.
        </p>
    </div>

    <p>
        Pierwszą rzeczą jaką należy odczytać jest nagłówek, <code>PageHeader</code>, robiąc to za pomocą Thrifta, przekazując
        stream oraz ustawiając odpowiednio adres początku otrzymamy strukturę danych <code>PageHeader</code>, która powie nam dokładnie jak należy odczytać
        samą stronę.
    </p>
    <p>
        Istnieją 3 typy stron:
    </p>
    <h3><code>DataPage</code></h3>
    <p>
        Strona zawierająca binarną reprezentację danych wybranej kolumny z wierszy, które trafiły do wybranej grupy wierszy.<br/>
        Jest to najprostszy i najbardziej bezpośredni typ strony. Zawiera "tylko" dane.
    </p>
    <p>
        Czytając kolumnę typu integer, to co nas interesuje to tak naprawdę liczba wierszy w konkretnej grupie (każdy wiersz to jedna wartość w <code>DataPage</code>).
        Dlatego wiedząc, że w tej grupie mamy powiedzmy 100 wartości, wiemy że musimy odczytać 400 bajtów (int32 zapisany jest na 4 bajtach). <br/>
    </p>
    <p>
        No dobra, ale co w przypadku kiedy kolumna jest opcjonalna? To znaczy, że może zawierać wartości null.<br/>
        Tutaj sytuacja robi się trochę bardziej skomplikowana ponieważ musimy wiedzieć, które wiersze zawierają wartość null.<br/>
        Skąd ta wiedza zapytacie? <br/>
        <code>Definition Levels</code>
    </p>
    <p>
        Sytuacja się trochę komplikuje, na początku pisałem, że <code>DataPage</code> zawiera tylko dane, a teraz dokładam jakieś <code>Definition Levels</code>.<br/>
    </p>
    <p>
        W rzeczywistości struktura data page wygląda mniej więcej tak:
    </p>
    <pre><code class="code-shell" {{ stimulus_controller('syntax_highlight') }}>{{ source(template_folder ~ '/code-examples/data-page.txt') | e('html') }}</code></pre>
    <p>
        Na ten moment, skupmy się tylko na <code>Definition Levels</code> i <code>Values</code>. Bardzo łatwo zauważyć związek między nimi.
        Ilość <code>Definition Level</code> i <code>Repetition Levels</code> w każdej stronie jest zawsze równa ilości wartości w kolumnie.<br/>
        Bez względu na to czy są tam nulle czy nie. <code>Definition Levels</code> mówią nam czy dany wiersz zawiera wartość czy null.
    </p>
    <p>
        Na tej podstawie, możemy łatwo określić całkowitą ilość nie pustych <code>Values</code> co pozwoli nam na ich odczyt. <br/>
        W powyższym przykładzie mamy 5 wierszy, z czego 3 stanowią wartości, ponieważ <code>int32</code> zapisujemy na 4 bajtach,
        wiemy już że musimy odczytać w sumie 12 bajatów.<br/>
        Wiemy też, że przekształcając kolumnę na wiersze, wiersz pierwszy będzie zawierał wartość <code>42</code>, wiersz drugi <code>null</code>,
        wiersz trzeci <code>73</code>, wiersz czwarty <code>19</code> i wiersz piąty <code>null</code>.
    </p>
    <div class="important">
        <p>
            <strong>Ważne:</strong> <code>Repetition Levels</code> i <code>Definition Levels</code> są jednak o wiele bardziej skomplikowane, nieco więcej później.<br/>
        </p>
    </div>
    <p>
        Tak mniej więcej prezentuje się struktura <code>DataPage</code>.
    </p>
    <h3><code>DictionaryPage</code></h3>
    <p>
        Skoro dane trzymamy w <code>DataPage</code>, jaki cel ma <code>DictionaryPage</code>?<br/>
        Otóż <code>DictionaryPage</code> to strona zawierająca słownik wartości.<br/>
        Słownik, używany do odczytywania danych, szczególnie w przypadku kolumn zawierających powtarzalne wartości.
    </p>

    <p>
        Działa to mniej więcej tak, że odczytując <code>ColumChunk</code>, zaczynamy od pierwszej strony, jeżeli ta strona to <code>DictionaryPage</code>,
        wiemy że mamy do czynienia z słownikiem (w zasadzie wiemy to od początku, ponieważ jest to zapisane w metadanych kolumny).
    </p>
    <p>
        Jeżeli przykładowo odczytujemy kolumnę o wysokiej powtarzalności, np. kolumnę z nazwą kraju, zamiast zapisywać w <code>DataPage</code> pełną nazwę kraju dla każdego wiersza,
        zapisujemy jedynie jej pozycję w słowniku.<br/>
        W przypadku takiej kolumny pierwsza strona w kolumnie będzie <code>DictionaryPage</code>, a kolejne będą <code>DataPage</code>.
    </p>
    <p>
        Różnica polega na tym, że w <code>DataPage</code> zamiast pełnej wartości, będą znajdować się pozycje w słowniku, który będziemy trzymać w pamięci w celu odbudowania wierszy.<br/>
    </p>
    <div class="important">
        <p>
            <strong>Ważne:</strong> Każdy <code>ColumnChunk</code> może zawierać tylko jedną stronę <code>DictionaryPage</code>.
        </p>
    </div>
    <p>
        Potrafi to dać ogromne oszczędności, zamiast powiedzmy zapisywać binarnie słowo <code>Polska</code> 10 tys. razy, czyli 60k bajtów,
        zapiszemy tylko pozycję w indeksie (czyli 4 bajty), które dodatkowo zostaną spakowane za pomocą algorytmu <a href="https://parquet.apache.org/docs/file-format/data-pages/encodings/#RLE" target="_blank">Run Length Encoding / Bit-Packing Hybrid</a>.
        Który, również opierając się na powtarzalności kolejnych wartości zredukuje całkowitą ilość potrzebnych bajtów.
    </p>

    <h3><code>IndexPage</code></h3>
    <p>
        Ostatnim już typem strony, jest <code>IndexPage</code>.<br/>
        Strona ta nie zawiera danych, nie jest więc niezbędna do odczytu ani zapisu.<br/>
        Każdy <code>ColumnChunk</code> może zawierać tylko jedną stronę typu <code>IndexPage</code> i znajduje się ona zawsze na końcu, po <code>DictionaryPage</code> oraz wszystkich <code>DataPage</code>.
    </p>
    <p>
        Celem tej strony jest przechowywanie statystyk odnośnie <code>ColumnChunk</code>, jak np. wartości <code>Min/Max</code>, ilość <code>nulli</code> czy sposób sortowania dla każdej strony w konkretnym <code>ColumnChunk</code>.
        Pozwala to na szybkie filtrowanie oraz odnajdywanie konkretnych tylko konkretnych stron w ramach danego <code>ColumnChunka</code>, co znacząco przyśpiesza przeszukiwanie pliku, jeżeli interesują nas konkretne informacje.
    </p>
    <div class="notice">
        <p>
            <strong>Uwaga:</strong> Każdy <code>ColumnChunk</code> w swoich metadanych zawiera podobne statystyki co <code>IndexPage</code>, jednak nie dla każdej strony a dla całego <code>ColumnChunk</code>.<br/>
            Dzięki temu, w pierwszej kolejności możemy przeskoczyć całe kolumny, które nas nie interesują a następnie nawet konkretne strony, redukując do absolutnego minimum ilość danych, które musimy odczytać.
        </p>
    </div>

    <p>
        Biorąc pod uwagę, że te informacje znajdują się w metadanych pliku, nawet największe pliki parqueta, mogą być błyskawicznie odczytywane i filtrowane nawet jeżeli są one tylko dostępne przez sieć.<br/>
        Wystarczy, że uda się nam odczytać metadane, na ich podstawie zlokalizować konkretną grupę wierszy, następnie wybraną kolumnę a na końcu konkretne strony. <br/>
        Dostaniemy w ten sposób bardzo precyzyjną lokalizację naszych danych, które będziemy mogli odczytać za pomocą nagłówka <code>Http Range Header</code>.
    </p>
    <p>
        To właśnie jeden z powodów, dla których parquet jest tak potężny, nie mówimy już tutaj o brutalnym pobieraniu i iterowaniu po gigabajtowym pliku. Parquet pozwala z precyzją chirurga
        pobrać i odczytać tylko te obszary pliku, które naprawdę nas interesują.
    </p>

    <a href="#dremel"><h2 id="dremel">Dremel</h2></a>

    <p>
        Omawiając strukturę <code>DataPage</code> wspomniałem o <code>Definition Levels</code> oraz <code>Repetition Levels</code>.
    </p>
    <p>
        Omówiony przykład był bardzo prosty, ponieważ dotyczył kolumny prostej (int32), przez co <code>Repetition Levels</code> w ogóle nie mają zastosowania.<br/>
        Sytuacja zmienia się diametralnie, kiedy mamy do czynienia z kolumną zagnieżdżoną, np. strukturą, listą czy mapą.
        Spójrzmy na przykład.
    </p>
    <p>
        <code>[{"sku":"abc", "quantity": 1, "price": 100}, {"sku":"def", "quantity": 2, "price": 200}]</code>
    </p>
    <p>
        Wracając do wcześniejszej części tego artykułu, a dokładnie do <a href="#nested-types">typów zagnieżdżonych</a>.<br/>
        Wiemy, że nasze dane po spłaszczeniu będą wyglądać następująco:
    </p>
    <ul>
        <li><code>items.list.element.sku</code> - <code>"abc","def"</code></li>
        <li><code>items.list.element.quantity</code> - <code>1,2</code></li>
        <li><code>items.list.element.price</code> - <code>100,200</code></li>
    </ul>
    <p>
        Mamy tutaj do czynienia z 3 kolumnami, każda z nich będzie znajdować się w osobnym <code>Column Chunk</code> i każda będzie zawierać
        w sobie jedną lub więcej stron.
    </p>
    <p>
        Skąd więc na podstawie tych dwóch wartości (<code>Repetition / Definition Levels)</code> biblioteki czytające pliki wiedzą, jak głęboko w strukturze znajdują się wartości oraz do którego elementu one należą?<br/>
        Co w przypadku, gdyby nasza struktura wyglądała tak:
    </p>
    <p>
        <code>[{"sku":"abc", "quantity": 1, "price": 100}, {"sku":null, "quantity": 10, "price": 100}, {"sku":"def", "quantity": 2, "price": 200}]</code>
        (w drugim elemencie sku ma wartość null). <br/>
    </p>
    <p>Co w przypadku, kiedy struktura jest o wiele bardziej zagnieżdżona, skąd mamy wiedzieć, która wartość wpada na który poziom zagnieżdżenia?</p>
    <p>
        Na to oraz wiele innych pytań odpowiedź znajdziemy w dokumencie opublikowanym przez Google <a href="https://static.googleusercontent.com/media/research.google.com/pl//pubs/archive/36632.pdf" target="_blank">Dremel: Interactive Analysis of Web-Scale Datasets</a>
        który opisuje, w jaki sposób Google przechowuje oraz przeszukuje zagnieżdżone struktury danych.
    </p>
    <p>
        Narzędzie wykorzystywane przez Googla nazywa się Dremel i jest rozproszonym systemem przeszukiwania dużych zbiorów danych. <br/>
        Opiera się ono na 2 algorytmach, <code>Shredding</code> oraz <code>Assembling</code>, które zostały opisane bardzo pobieżnie w powyższym dokumencie.
    </p>
    <div class="notice">
        <p>
            <strong>Uwaga:</strong> Opisanie dokładnego działania tych algorytmów wykracza poza ramy tego i tak długiego wpisu.<br/>
            Jeżeli jednak pojawi się zainteresowanie tematem, postaram się poruszyć również i ten wątek w nadchodzących wpisach.
        </p>
    </div>
    <p>
        Algorytmy te bazują na tych 3 definicjach:
    </p>
    <ul>
        <li>Repetition Levels</li>
        <li>Definition Levels</li>
        <li>Values</li>
    </ul>
    <p>
        Tak jak już wspominaliśmy <code>Definition Level</code> określa czy dany wiersz zawiera wartość, czy też nie, <code>Repetition Level</code> który w przypadku kolumn płaskich jest zawsze 0.
        Dla struktur określać będzie czy wartość (lub null) ma być powtórzona, oraz na którym poziomie zagłębienia.
    </p>
    <div class="notice">
        <p>
            <strong>Uwaga:</strong> Wiedza o tym, jak dokładnie działają algorytmy z Dremela, nie jest niezbędna do optymalnego wykorzystywania parqueta.
            Z tego powodu, nie będę się na ten temat rozpisywał, jeżeli jednak pojawi się zainteresowanie tematem, postaram się poruszyć również i ten wątek w nadchodzących wpisach.
        </p>
    </div>
    <p>
         Poniżej przedstawię tylko mniej więcej, jak wyglądać będą spłaszczone dane.
    </p>
    <pre>
        <code class="code-shell" {{ stimulus_controller('syntax_highlight') }}>{{ source(template_folder ~ '/code-examples/shredded-data.txt') | e('html') }}</code>
    </pre>
    <p>
        Czyli w rzeczywistości zapisujemy <code>0, 1, 0, 1, "abc", "def"</code> a nie tylko <code>"abc", "def"</code>. <br/>
        To właśnie te dodatkowe liczby mówią w jaki sposób odbudować dowolną strukturę zagnieżdżoną.
    </p>
    <p>
        Ciekawostką jest, że nawet repetition levels i definition levels w celu optymalizacji są wcześnie odpowiednio pakowane przy użyciu algorytmu
        <a href="https://parquet.apache.org/docs/file-format/data-pages/encodings/#RLE" target="_blank">Run Length Encoding / Bit-Packing Hybrid</a>.
    </p>
    <p>
        Na tym nie koniec, bo nie tylko poziomy są pakowane, ale również same wartości.<br/>
        W zależności od typu kolumny, wartości mogą być pakowane na różne sposoby, listę wszystkich algorytmów pakujących obsługiwanych przez parqueta (przynajmniej w teorii) znajdziemy
        <a href="https://parquet.apache.org/docs/file-format/data-pages/encodings" target="_blank">w oficjalnej dokumentacji</a>.
    </p>
    <p>
        Natomiast informację o tym, jaki algorytm został użyty do spakowania danych przed zapisem znajdziemy w metadanych, pod taką ścieżką <code>RowGroups[x].ColumnChunk[y].PageHeader[z].data_page_header.encoding</code>
    </p>
    <p>
        Nie jest to natomiast ostatnie słowo parqueta w kontekście optymalizacji!
    </p>
    <a href="#compression"><h2 id="compression">Kompresja</h2></a>
    <p>
        Po spakowaniu i zapisaniu w formie binarnej naszych danych dla konkretnej strony, każda strona jest dodatkowo kompresowana.
    </p>
    <p>
        W zależności od implementacji parquet pozwala na użycie różnych algorytmów kompresji:
    </p>
    <ul>
        <li>UNCOMPRESSED</li>
        <li>SNAPPY</li>
        <li>GZIP</li>
        <li>LZO</li>
        <li>BROTLI</li>
        <li>LZ4</li>
        <li>ZSTD</li>
        <li>LZ4_RAW</li>
    </ul>
    <p>
        Bardzo popularną opcją jest <a href="https://github.com/google/snappy" target="_blank">Snappy</a>, która oferuje bardzo dobry kompromis pomiędzy szybkością a stopniem kompresji.
    </p>
    <p>
        Narzędzia takie jak <a href="https://spark.apache.org/" target="_blank">Apache Spark</a> wręcz używają go domyślnie.
    </p>
    <a href="#encryption"><h2 id="encryption">Szyfrowanie</h2></a>
    <p>
        Jedną z ostatnich ciekawszych funkcji, którą chciałbym omówić, jest szyfrowanie!
    </p>
    <p>
        Tak, parquet pozwala szyfrować dane, szyfrować na wielu poziomach.
    </p>
    <ul>
        <li>Metadane - zaszyfrowane metadane skutecznie utrudniają odczytanie zawartości pliku, jednak nie jest to niemożliwe</li>
        <li>Dane - zaszyfrowane dane praktycznie uniemożliwiają odczyt</li>
        <li>Kolumny - szczególnie przydatne, jeżeli tylko niektóre kolumny zawierają wrażliwe dane.</li>
        <li>Strony</li>
    </ul>
    <div class="notice">
        <p>
            <strong>Uwaga:</strong> Szyfrowanie jest jedną z tych, funkcji, których jeszcze nie zdążyłem pokryć w <a href="https://flow-php.com/documentation/components/libs/parquet/">implementacji dla PHP</a><br/>
            Z tego powodu nie będę się na ten temat rozpisywał, jak tylko nadaży się okazja do zaimplementowanie tej funkcjonalności, postaram się uzupełnić artykuł.
        </p>
    </div>
    <p>
        Szyfrowanie w parquecie opiera się o <a href="https://parquet.apache.org/docs/file-format/data-pages/encryption/" target="_blank">Parquet Modular Encryption</a> i wykorzystuje
        <a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf" target="_blank">AES</a> do szyfrowania danych.
    </p>
    <p>
        Szyfrowanie, szczególnie wybranych kolumn, wynosi parqueta na wyższy poziom przechowywania danych. <br/> Dzięki temu w stosunkowo łatwy sposób, z niewielkim narzutem,
        możemy dodatkowo zabezpieczyć dane, które przechowujemy w plikach parqueta. <br/>
    </p>
    <p>
        Wyobraźmy sobie, że parquet jest używany do przechowywania danych klientów, gdzie kolumna <code>email</code> oraz <code>phone</code> zawierają dane wrażliwe.<br/>
        W tej sytuacji, aż się prosi o to, żeby te dwie kolumny były dodatkowo zabezpieczone. Nawet jeżeli komuś uda się uzyskać fizyczny dostęp do pliku, bez klucza i tak nie
        będzie w stanie odczytać danych.
    </p>
    <a href="#summary"><h2 id="summary">Podsumowanie</h2></a>
    <p>
        To właśnie jest tajemnica parqueta i sposób na wydajność. Zamiast przechowywać dowolne dane w postaci tekstowej, parquet idzie o kilka kroków dalej. <br/>
        W pierwszej kolejności wymusza schemat danych opierający się o proste lecz niesamowicie elastyczne typy, z których każdy da się
        przedstawić w postaci binarnej.<br/>
        Następnie postać binarna jest odpowiednio pakowana, tak aby unikać zbędnych powtórzeń bajtów, co na samym końcu jest
        jeszcze dodatkowo kompresowane za pomocą bardzo wydajnych algorytmów.<br/>
        Wisienką na torcie są zaawansowane i szczegółówe metadane, dostępne na kilku poziomach, pozwalające odfiltrować
        zbędne partycje, lub wręcz całe pliki bez odczytywania ich zawartości.
    </p>
    <p>
        Ponadto dzięki odpowiedniemu podziałowi logicznemu, nad którym mamy pełną kontrolę (rozmiar grup i stron) możemy
        decydować co jest dla nas ważniejsze, szybkość czy oszczędność pamięci. Przeszukiwanie czy odczytywanie danych a może
        bezpieczeństwo, do którego wykorzystamy dodatkowe szyfrowanie?
    </p>
    <p>
        Parquet to naprawdę potężne narzędzie, które w odpowiednich rękach pozwala na efektywne przechowywanie i przeszukiwanie
        ogromnych ilości danych.<br/>
    </p>
    <p>
        Jeżeli ten wpis zainspirował Cię do poeksperymentowania z tym rewelacyjnym formatem danych, daj znać w komentarzach!
    </p>
    <a href="#help"><h2 id="help">Pomoc</h2></a>
    <p>
        Jeśli potrzebujesz pomocy w zakresie budowy centralnego magazynu danych, chętnie Ci pomogę.<br/>
        <a href="{{ url('consulting') }}">Skontaktuj się ze mną</a>, a wspólnie stworzymy rozwiązanie, które będzie idealnie dopasowane do Twoich potrzeb.
    </p>
    <p>
        Zachęcam również do odwiedzenia serwera <a href="https://discord.gg/5dNXfQyACW" target="_blank">Discord - Flow PHP</a>, na którym
        możemy porozmawiać bezpośrednio.
    </p>
    <div class="img-wide">
        <img src="{{ asset('images/blog/analytics-in-transactional-distributed-systems/consulting_01.jpg') }}" alt="Konsultacje" />
    </div>
{% endblock %}