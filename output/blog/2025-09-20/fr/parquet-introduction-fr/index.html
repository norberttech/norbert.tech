<!doctype html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Parquet - Introduction</title>
    <meta property="og:title" content="Parquet - Introduction" />
    <meta name="twitter:title" content="Parquet - Introduction" >

    <meta name="description" content="Guide complet d&#039;Apache Parquet - le format de fichier binaire et colonnaire. Apprenez comment obtenir des fichiers 10x plus petits, utiliser les mÃ©tadonnÃ©es pour un filtrage ultra-rapide, comprendre la structure des Row Groups et Data Pages, et explorer les fonctionnalitÃ©s avancÃ©es comme le chiffrement et les algorithmes Dremel.">
    <meta property="og:description" content="Guide complet d&#039;Apache Parquet - le format de fichier binaire et colonnaire. Apprenez comment obtenir des fichiers 10x plus petits, utiliser les mÃ©tadonnÃ©es pour un filtrage ultra-rapide, comprendre la structure des Row Groups et Data Pages, et explorer les fonctionnalitÃ©s avancÃ©es comme le chiffrement et les algorithmes Dremel.">
    <meta name="twitter:description" content="Guide complet d&#039;Apache Parquet - le format de fichier binaire et colonnaire. Apprenez comment obtenir des fichiers 10x plus petits, utiliser les mÃ©tadonnÃ©es pour un filtrage ultra-rapide, comprendre la structure des Row Groups et Data Pages, et explorer les fonctionnalitÃ©s avancÃ©es comme le chiffrement et les algorithmes Dremel.">

    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://norbert.tech/blog/2025-09-20/fr/parquet-introduction-fr" />
                <meta property="og:image" content="https://norbert.tech/assets/images/blog/parquet-introduction/parquet-026fc09c95c7c7b4728c30bb85593777.jpg" />
                    
    <meta name="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://norbert.tech/blog/2025-09-20/fr/parquet-introduction-fr" />
    <meta name="twitter:image" content="https://norbert.tech/assets/images/avatar-8f3c52c37f20d07c5e1631e1512bdeca.jpeg">
    <meta name="twitter:site" content="@norbert_tech" />
    <meta name="twitter:creator" content="@norbert_tech" />

    <link rel="apple-touch-icon" sizes="180x180" href="https://norbert.tech/assets/images/favicons/apple-touch-icon-9cae7ee880b4fe0bd755d300e1bca71e.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://norbert.tech/assets/images/favicons/favicon-32x32-b7a4ad4b584ab95534144e071f0e8587.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://norbert.tech/assets/images/favicons/favicon-16x16-154ca21abc06ae116c8d7ffc5713c000.png">
    <link rel="shortcut icon" href="https://norbert.tech/assets/images/favicons/favicon-db409885df78dea389e6d0b036da382c.ico">

            <style>
            @import url('https://fonts.googleapis.com/css2?family=Cabin:ital,wght@0,400..700;1,400..700&display=swap');
        </style>
        <link rel="stylesheet" href="https://norbert.tech/assets/styles/app-e24f407580be48180186fb40114b24be.css">
    
            
<script type="importmap">
{
    "imports": {
        "app": "https://norbert.tech/assets/app-930adf3462cf9ab60908eb1b74cf7ca7.js",
        "@oddbird/popover-polyfill": "https://norbert.tech/assets/vendor/@oddbird/popover-polyfill/popover-polyfill.index-7979d53637476aa204f709644aed2c19.js",
        "https://norbert.tech/assets/bootstrap.js": "https://norbert.tech/assets/bootstrap-d78d7e12c819dedf89372fb4824c072d.js",
        "htmx.org": "https://norbert.tech/assets/vendor/htmx.org/htmx.org.index-023ae86a082913526422a6063298f898.js",
        "iconify-icon": "https://norbert.tech/assets/vendor/iconify-icon/iconify-icon.index-8a41e423576dc2d752509fd455f508c1.js",
        "@symfony/stimulus-bundle": "https://norbert.tech/assets/@symfony/stimulus-bundle/loader-9311b8ea36bad0f6168e687b4d6dee73.js",
        "@hotwired/stimulus": "https://norbert.tech/assets/vendor/@hotwired/stimulus/stimulus.index-304681764684182e6662e0931532ed91.js",
        "https://norbert.tech/assets/@symfony/stimulus-bundle/controllers.js": "https://norbert.tech/assets/@symfony/stimulus-bundle/controllers-11c35dc7f11bbd855b8108888f18f9b7.js",
        "https://norbert.tech/assets/controllers/hello_controller.js": "https://norbert.tech/assets/controllers/hello_controller-55882fcad241d2bea50276ea485583bc.js",
        "https://norbert.tech/assets/controllers/syntax_highlight_controller.js": "https://norbert.tech/assets/controllers/syntax_highlight_controller-ae10e4cee8b4dedbf232536d05654062.js",
        "https://norbert.tech/assets/controllers/clipboard_controller.js": "https://norbert.tech/assets/controllers/clipboard_controller-6aefa8a9dec3271dae2f05b464bf9204.js",
        "highlight.js/lib/core": "https://norbert.tech/assets/vendor/highlight.js/lib/core-760145ef158caabe84ca07686407d093.js",
        "highlight.js/lib/languages/php": "https://norbert.tech/assets/vendor/highlight.js/lib/languages/php-c0eb2105c14097e8a5a1e9a767e8ac95.js",
        "highlight.js/styles/github-dark.min.css": "data:application/javascript,document.head.appendChild%28Object.assign%28document.createElement%28%22link%22%29%2C%7Brel%3A%22stylesheet%22%2Chref%3A%22https%3A%2F%2Fnorbert.tech%2Fassets%2Fvendor%2Fhighlight.js%2Fstyles%2Fgithub-dark.min-4b46e20f66f76e35d6454ca4f09b57c3.css%22%7D%29%29",
        "@fontsource-variable/cabin/index.min.css": "data:application/javascript,document.head.appendChild%28Object.assign%28document.createElement%28%22link%22%29%2C%7Brel%3A%22stylesheet%22%2Chref%3A%22https%3A%2F%2Fnorbert.tech%2Fassets%2Fvendor%2F%40fontsource-variable%2Fcabin%2Findex.min-08e34691d22388e6974e6cb2bfbcbfd0.css%22%7D%29%29",
        "clipboard": "https://norbert.tech/assets/vendor/clipboard/clipboard.index-925566f98181665b5a61fea1bcd9033d.js",
        "highlight.js/lib/languages/shell": "https://norbert.tech/assets/vendor/highlight.js/lib/languages/shell-664215791af27581e04813723523a355.js",
        "highlight.js/lib/languages/json": "https://norbert.tech/assets/vendor/highlight.js/lib/languages/json-9ac51ad2a97f9ce56b2f309eb64d7b04.js",
        "highlight.js/lib/languages/twig": "https://norbert.tech/assets/vendor/highlight.js/lib/languages/twig-0f3c6d18c0368650898b432b7bcf672a.js",
        "highlight.js/lib/languages/sql": "https://norbert.tech/assets/vendor/highlight.js/lib/languages/sql-09f80640dd6fe9bed6ff4eb255b13f08.js",
        "highlight.js/lib/languages/javascript": "https://norbert.tech/assets/vendor/highlight.js/lib/languages/javascript-100f963be02a503f0531e497103ff398.js",
        "highlight.js/lib/languages/xml": "https://norbert.tech/assets/vendor/highlight.js/lib/languages/xml-a2295112e12d4d01f257d59e1cfa676d.js"
    }
}
</script>
<!-- ES Module Shims: Import maps polyfill for modules browsers without import maps support -->
<script async src="https://ga.jspm.io/npm:es-module-shims@1.10.0/dist/es-module-shims.js"></script>
<link rel="modulepreload" href="https://norbert.tech/assets/app-930adf3462cf9ab60908eb1b74cf7ca7.js">
<link rel="modulepreload" href="https://norbert.tech/assets/vendor/@oddbird/popover-polyfill/popover-polyfill.index-7979d53637476aa204f709644aed2c19.js">
<link rel="modulepreload" href="https://norbert.tech/assets/bootstrap-d78d7e12c819dedf89372fb4824c072d.js">
<link rel="modulepreload" href="https://norbert.tech/assets/vendor/htmx.org/htmx.org.index-023ae86a082913526422a6063298f898.js">
<link rel="modulepreload" href="https://norbert.tech/assets/vendor/iconify-icon/iconify-icon.index-8a41e423576dc2d752509fd455f508c1.js">
<link rel="modulepreload" href="https://norbert.tech/assets/@symfony/stimulus-bundle/loader-9311b8ea36bad0f6168e687b4d6dee73.js">
<link rel="modulepreload" href="https://norbert.tech/assets/vendor/@hotwired/stimulus/stimulus.index-304681764684182e6662e0931532ed91.js">
<link rel="modulepreload" href="https://norbert.tech/assets/@symfony/stimulus-bundle/controllers-11c35dc7f11bbd855b8108888f18f9b7.js">
<link rel="modulepreload" href="https://norbert.tech/assets/controllers/hello_controller-55882fcad241d2bea50276ea485583bc.js">
<script type="module">import 'app';</script>
                <script defer src="https://cloud.umami.is/script.js" data-website-id="9fed007d-d990-428b-b5d9-11c6ff55a3f1"></script>
    </head>
<body class="scroll-smooth text-black relative min-h-screen pb-16">
    <div class="sticky top-0 max-h-screen overflow-y-auto bg-white py-2 px-2 border-b border-gray-500 z-[9999] print:hidden">
        <div class="grid grid-cols-2 sm:mx-auto sm:max-w-screen-2xl md:px-4">
            <div class="text-left">
                <a href="/" class="text-lg">
                    norbert.tech
                </a>
            </div>
            <div class="text-right">
                <a href="/consulting" class="text-lg inline-flex items-center space-x-1 md:mr-4 mr-2">
                    <iconify-icon icon="lineicons:consulting" class="mr-1"></iconify-icon> Consulting
                </a>
                <a href="/blog" class="text-lg inline-flex items-center space-x-1">
                    <iconify-icon icon="ooui:articles-ltr" class="mr-1"></iconify-icon> Blog
                </a>
            </div>
        </div>
    </div>
    
    <main class="mx-auto max-w-screen-2xl mb-4 md:pt-4 px-4 lg:px-0">
            <div class="px-2 py-5 sm:px-4 md:px-8 lg:px-12 mx-auto max-w-4xl">
        <ul class="mt-2 pl-[20px] flex flex-wrap gap-2 sm:gap-4">
            <li>
                <a href="/blog" class="text-sm sm:text-base text-blue-500 hover:underline px-2 py-1 rounded">Go Back</a>
            </li>
                                                                <li>
                        <a href="/blog/2025-09-20/pl/parquet-wprowadzenie"
                           class="text-sm sm:text-lg px-2 py-1 rounded hover:opacity-80"
                           title="Polish">ğŸ‡µğŸ‡± Polish</a>
                    </li>
                                                                                <li>
                        <a href="/blog/2025-09-20/de/parquet-einfuehrung"
                           class="text-sm sm:text-lg px-2 py-1 rounded hover:opacity-80"
                           title="Deutsch">ğŸ‡©ğŸ‡ª Deutsch</a>
                    </li>
                                                                                <li>
                        <a href="/blog/2025-09-20/es/parquet-introduccion"
                           class="text-sm sm:text-lg px-2 py-1 rounded hover:opacity-80"
                           title="Spanish">ğŸ‡ªğŸ‡¸ Spanish</a>
                    </li>
                                                                                <li>
                        <a href="/blog/2025-09-20/parquet-introduction"
                           class="text-sm sm:text-lg px-2 py-1 rounded hover:opacity-80"
                           title="English">ğŸ‡ºğŸ‡¸ English</a>
                    </li>
                                                                                <li>
                        <a href="/blog/2025-09-20/it/parquet-introduzione"
                           class="text-sm sm:text-lg px-2 py-1 rounded hover:opacity-80"
                           title="Italian">ğŸ‡®ğŸ‡¹ Italian</a>
                    </li>
                                    </ul>

                    <div class="mt-4 p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
                <div class="flex items-start">
                    <div class="flex-shrink-0">
                        <svg class="h-5 w-5 text-yellow-400" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"/>
                        </svg>
                    </div>
                    <div class="ml-3">
                        <h3 class="font-medium text-yellow-800">
                            Translation Notice
                        </h3>
                        <div class="mt-2 text-yellow-700">
                            <p>
                                This is an automatically translated version of that Article. Despite my best efforts, it might not be perfect.<br/>
                                Native speakers are welcome to
                                <a href="https://github.com/norberttech/norbert.tech/edit/main/templates/blog/posts/2025-09-20/parquet-introduction-fr/post.html.twig"
                                   class="underline hover:text-yellow-800" target="_blank" rel="noopener">open pull requests
                                </a> to correct anything that doesn't sound right.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
            </div>
    <article class="blog-post">
            <div class="img-wide">
        <img src="https://norbert.tech/assets/images/blog/parquet-introduction/parquet-026fc09c95c7c7b4728c30bb85593777.jpg" alt="Parquet - Introduction" />
    </div>

    <h1 class="font-bold text-4xl mb-2" id="title">Parquet - Introduction</h1>
    <div class="mb-2">
        <small class="text-sm">Date de Publication September 20, 2025 00:00</small>
    </div>
    <div class="mb-4">
                    <small><span class="badge badge-info">parquet</span></small>
                    <small><span class="badge badge-info">binaire</span></small>
                    <small><span class="badge badge-info">colonnaire</span></small>
                    <small><span class="badge badge-info">format de fichier</span></small>
                    <small><span class="badge badge-info">compression de donnÃ©es</span></small>
                    <small><span class="badge badge-info">mÃ©tadonnÃ©es</span></small>
                    <small><span class="badge badge-info">chiffrement</span></small>
                    <small><span class="badge badge-info">Apache Thrift</span></small>
                    <small><span class="badge badge-info">Flow PHP</span></small>
            </div>
    <p>
        Parquet, un format de fichier binaire et colonnaire crÃ©Ã© pour le stockage et la recherche efficaces de donnÃ©es.
    </p>
    <p>
        Sur internet, il y a plein d'articles sur Parquet, alors pourquoi en ajouter un de plus ?<br/>
        Voici ma vision de ce format fantastique, qui est essentiellement le rÃ©sultat de mes expÃ©riences de travail sur
        l'Ã©criture d'une implÃ©mentation de Parquet en PHP pur.
    </p>
    <p>
        Pour ceux qui sont arrivÃ©s ici par hasard, je mentionnerai juste que je suis l'auteur du premier framework de traitement
        de donnÃ©es en PHP, appelÃ© <a href="https://flow-php.com" target="_blank">Flow PHP</a>.<br/>
        Comme il convient Ã  un Data Frame, Flow doit pouvoir lire et Ã©crire des donnÃ©es dans diffÃ©rents formats, y compris Parquet<br/>
    </p>
    <p>
        Cependant, comme la seule implÃ©mentation que j'ai trouvÃ©e Ã©tait essentiellement un port direct de C#, qui en plus
        ne gÃ¨re pas complÃ¨tement les structures profondÃ©ment imbriquÃ©es et possÃ¨de beaucoup de fonctions manquantes, j'ai dÃ©cidÃ©
        dans le cadre de l'apprentissage, d'Ã©crire ma propre implÃ©mentation Ã  partir de zÃ©ro, ce qui s'est avÃ©rÃ© Ãªtre une expÃ©rience extrÃªmement prÃ©cieuse mais aussi trÃ¨s amusante.
    </p>
    <a href="#why-parquet"><h2 id="why-parquet">Pourquoi Parquet</h2></a>
    <ul>
        <li><a href="#binary-format">Format Binaire - des fichiers jusqu'Ã  10x plus petits</a></li>
        <li><a href="#metadata">MÃ©tadonnÃ©es - accÃ¨s plus facile aux donnÃ©es sÃ©lectionnÃ©es</a></li>
        <li><a href="#schema">SchÃ©ma - garantie de structure correcte</a></li>
        <li><a href="#compression">Compression - rÃ©duction supplÃ©mentaire de la taille</a></li>
        <li><a href="#encryption">Chiffrement - au niveau du fichier, des mÃ©tadonnÃ©es, des colonnes ou des pages</a></li>
    </ul>

    <a href="#binary-format"><h2 id="binary-format">Format Binaire</h2></a>
    <p>
        GrÃ¢ce au fait que ce format est orientÃ© colonnes, pas lignes, il permet une compression de donnÃ©es trÃ¨s efficace,
        ce qui se traduit par une taille de fichier significativement plus petite. Sans beaucoup d'effort, Parquet peut comprimer les donnÃ©es jusqu'Ã  <strong>10 fois</strong>,
        comparÃ© aux formats traditionnels comme CSV ou XML.
    </p>
    <p>
        Donc, si les mÃªmes donnÃ©es sauvegardÃ©es au format CSV occupent 1Go, au format Parquet elles peuvent n'occuper que 100Mo.<br/>
    </p>

    <p>
        Pour les besoins de cet article, j'ai gÃ©nÃ©rÃ© 2 fichiers, un au format CSV, l'autre au format Parquet.<br/>
        La structure de ces fichiers est trÃ¨s simple, elle contient 10 colonnes et 10 millions de lignes, qui ressemblent Ã  peu prÃ¨s Ã  ceci :
    </p>
    <pre><code class="code-shell" data-controller="syntax-highlight">index,order_id,created_at,updated_at,discount,email,customer,address,notes,items
0,254d61c5-22c8-4407-83a2-76f1cab53af2,2025-01-01T12:00:00+00:00,2025-01-01T12:10:00+00:00,24.4,user-0@example.com,&quot;John Doe 0&quot;,&quot;{&quot;&quot;street&quot;&quot;:&quot;&quot;123 Main St, Apt 0&quot;&quot;,&quot;&quot;city&quot;&quot;:&quot;&quot;City &quot;&quot;,&quot;&quot;zip&quot;&quot;:&quot;&quot;12345-0&quot;&quot;,&quot;&quot;country&quot;&quot;:&quot;&quot;PL&quot;&quot;}&quot;,&quot;[&quot;&quot;Note 1 for order 0&quot;&quot;,&quot;&quot;Note 2 for order 0&quot;&quot;,&quot;&quot;Note 3 for order 0&quot;&quot;]&quot;,&quot;[{&quot;&quot;sku&quot;&quot;:&quot;&quot;SKU_0001&quot;&quot;,&quot;&quot;quantity&quot;&quot;:1,&quot;&quot;price&quot;&quot;:0.14},{&quot;&quot;sku&quot;&quot;:&quot;&quot;SKU_0002&quot;&quot;,&quot;&quot;quantity&quot;&quot;:2,&quot;&quot;price&quot;&quot;:25.13}]&quot;
1,254d61c5-22c8-4407-83a2-76f1cab53af2,2025-01-01T12:00:00+00:00,2025-01-01T12:10:00+00:00,24.4,user-1@example.com,&quot;John Doe 1&quot;,&quot;{&quot;&quot;street&quot;&quot;:&quot;&quot;123 Main St, Apt 1&quot;&quot;,&quot;&quot;city&quot;&quot;:&quot;&quot;City &quot;&quot;,&quot;&quot;zip&quot;&quot;:&quot;&quot;12345-1&quot;&quot;,&quot;&quot;country&quot;&quot;:&quot;&quot;PL&quot;&quot;}&quot;,&quot;[&quot;&quot;Note 1 for order 1&quot;&quot;,&quot;&quot;Note 2 for order 1&quot;&quot;,&quot;&quot;Note 3 for order 1&quot;&quot;]&quot;,&quot;[{&quot;&quot;sku&quot;&quot;:&quot;&quot;SKU_0001&quot;&quot;,&quot;&quot;quantity&quot;&quot;:1,&quot;&quot;price&quot;&quot;:0.14},{&quot;&quot;sku&quot;&quot;:&quot;&quot;SKU_0002&quot;&quot;,&quot;&quot;quantity&quot;&quot;:2,&quot;&quot;price&quot;&quot;:25.13}]&quot;
2,254d61c5-22c8-4407-83a2-76f1cab53af2,2025-01-01T12:00:00+00:00,,,user-2@example.com,&quot;John Doe 2&quot;,&quot;{&quot;&quot;street&quot;&quot;:&quot;&quot;123 Main St, Apt 2&quot;&quot;,&quot;&quot;city&quot;&quot;:&quot;&quot;City &quot;&quot;,&quot;&quot;zip&quot;&quot;:&quot;&quot;12345-2&quot;&quot;,&quot;&quot;country&quot;&quot;:&quot;&quot;PL&quot;&quot;}&quot;,&quot;[&quot;&quot;Note 1 for order 2&quot;&quot;,&quot;&quot;Note 2 for order 2&quot;&quot;,&quot;&quot;Note 3 for order 2&quot;&quot;]&quot;,&quot;[{&quot;&quot;sku&quot;&quot;:&quot;&quot;SKU_0001&quot;&quot;,&quot;&quot;quantity&quot;&quot;:1,&quot;&quot;price&quot;&quot;:0.14},{&quot;&quot;sku&quot;&quot;:&quot;&quot;SKU_0002&quot;&quot;,&quot;&quot;quantity&quot;&quot;:2,&quot;&quot;price&quot;&quot;:25.13}]&quot;
3,254d61c5-22c8-4407-83a2-76f1cab53af2,2025-01-01T12:00:00+00:00,,24.4,user-3@example.com,&quot;John Doe 3&quot;,&quot;{&quot;&quot;street&quot;&quot;:&quot;&quot;123 Main St, Apt 3&quot;&quot;,&quot;&quot;city&quot;&quot;:&quot;&quot;City &quot;&quot;,&quot;&quot;zip&quot;&quot;:&quot;&quot;12345-3&quot;&quot;,&quot;&quot;country&quot;&quot;:&quot;&quot;PL&quot;&quot;}&quot;,&quot;[&quot;&quot;Note 1 for order 3&quot;&quot;,&quot;&quot;Note 2 for order 3&quot;&quot;,&quot;&quot;Note 3 for order 3&quot;&quot;]&quot;,&quot;[{&quot;&quot;sku&quot;&quot;:&quot;&quot;SKU_0001&quot;&quot;,&quot;&quot;quantity&quot;&quot;:1,&quot;&quot;price&quot;&quot;:0.14},{&quot;&quot;sku&quot;&quot;:&quot;&quot;SKU_0002&quot;&quot;,&quot;&quot;quantity&quot;&quot;:2,&quot;&quot;price&quot;&quot;:25.13}]&quot;
</code></pre>

    <p>
        L'effet de compression est vraiment impressionnant :
    </p>

    <pre><code class="code-shell" data-controller="syntax-highlight">4.1G Sep 20 18:32 orders.csv
437M Sep 20 18:47 orders.parquet</code></pre>

    <p>
        Cela se traduit non seulement par des coÃ»ts de stockage, mais aussi de traitement des donnÃ©es.<br/>
        Surtout quand nos donnÃ©es vivent dans le cloud, que ce soit sur Azure Bucket ou AWS S3. L'un des plus grands facteurs affectant
        la facture n'est pas tant la taille des donnÃ©es, mais combien de trafic nous utilisons pour lire/Ã©crire ces donnÃ©es.
    </p>
    <p>
        Donc en rÃ©duisant la taille du fichier, nous rÃ©duisons non seulement le coÃ»t de le stocker, mais aussi de le traiter.
        Il est important de comprendre que le traitement est en rÃ©alitÃ© toute forme d'accÃ¨s, c'est-Ã -dire Ã©criture/lecture.
    </p>
    <p>
        Cela revient donc Ã  dire qu'en choisissant le format de fichier appropriÃ©, les Ã©conomies peuvent Ãªtre vraiment importantes,
        surtout quand on parle de plus grandes quantitÃ©s de donnÃ©es.
    </p>
    <p>
        Que signifie exactement que Parquet est un format binaire ?
    </p>
    <p>
        Cela signifie Ã  peu prÃ¨s que les donnÃ©es sont stockÃ©es sous forme binaire, c'est-Ã -dire d'une maniÃ¨re qui ne peut pas Ãªtre
        lue directement en utilisant des Ã©diteurs de texte populaires.
    </p>
    <p>
        Mais tout finalement est stockÃ© sous forme binaire, non ?
    </p>
    <p>
        Oui, gÃ©nÃ©ralement les fichiers texte sont aussi des fichiers binaires, la diffÃ©rence est que dans les fichiers texte la structure
        du fichier est toujours la mÃªme et chaque information est sauvegardÃ©e de la mÃªme maniÃ¨re.
    </p>
    <p>
        Par exemple, si nous voulions sauvegarder "12345" dans un fichier texte, la version binaire ressemblerait Ã  ceci :
    </p>
    <pre><code class="code-shell" data-controller="syntax-highlight">STRING: &quot;12345&quot;
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Character:   &#039;1&#039;       &#039;2&#039;      &#039;3&#039;      &#039;4&#039;     &#039;5&#039;      &#039;\0&#039;
ASCII:       49        50       51        52     53        0
Binary:    00110001 00110010 00110011 00110100 00110101 00000000
           â””â”€byteâ”€â”˜ â””â”€byteâ”€â”˜ â””â”€byteâ”€â”˜ â””â”€byteâ”€â”˜ â””â”€byteâ”€â”˜ â””â”€byteâ”€â”˜

Total: 6 bytes (including null terminator)</code></pre>
    <p>
        La mÃªme chaÃ®ne sauvegardÃ©e au format binaire comme int32 (entier sous forme 32 bits) ressemblerait Ã  ceci :
    </p>
    <pre><code class="code-shell" data-controller="syntax-highlight">INTEGER: 12345
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Integer:     0         0       48       57
Binary:  00000000  00000000 00110000 00111001
         â””â”€byteâ”€â”˜  â””â”€byteâ”€â”˜ â””â”€byteâ”€â”˜ â””â”€byteâ”€â”˜

Total: 4 bytes for a 32-bit integer</code></pre>

    <p>
        Remarquons que dans le cas de sauvegarder un entier sous forme binaire, on ne peut pas simplement le lire de gauche Ã  droite (ou vice-versa).
        Ici nous devons dÃ©jÃ  savoir comment interprÃ©ter ces bits pour comprendre ce qu'ils signifient.
        Dans le cas des fichiers texte nous n'avons pas ce problÃ¨me, puisque nous savons que chaque caractÃ¨re est sauvegardÃ© sous forme 8 bits.
    </p>
    <p>
        Ã€ peu prÃ¨s pour cette raison n'importe quel Ã©diteur de texte est capable d'ouvrir n'importe quel fichier texte et de nous afficher quelque chose qui aura plus ou moins de sens.
    </p>
    <p>
        Cependant, si nous essayons d'ouvrir un fichier type Parquet dans un Ã©diteur de texte, nous obtiendrons une chaÃ®ne de caractÃ¨res semblant trÃ¨s alÃ©atoire et n'ayant pas beaucoup de sens.
    </p>

    <a href="#columns-rows"><h2 id="columns-rows">Colonnaire / Par Lignes</h2></a>
    <p>
        Il est prÃ©fÃ©rable d'expliquer la diffÃ©rence entre ces formats Ã  l'aide de visualisation.
    </p>
    <p>
        Dans le modÃ¨le classique par lignes chaque ligne contient toutes les colonnes, comme par exemple au format CSV
    </p>

    <pre><code class="code-shell" data-controller="syntax-highlight">+------+------+------+
| Col1 | Col2 | Col3 |
+------+------+------+
|  A1  |  B1  |  C1  |
|  A2  |  B2  |  C2  |
|  A3  |  B3  |  C3  |
+------+------+------+
</code></pre>

    <p>
        Le format colonnaire est intÃ©ressant car au lieu de stocker les donnÃ©es ligne par ligne, il les stocke colonne par colonne.
    </p>

    <pre><code class="code-shell" data-controller="syntax-highlight">+------+------+------+------+
| Col1 |  A1  |  A2  |  A3  |
+------+------+------+------+
| Col2 |  B1  |  B2  |  B3  |
+------+------+------+------+
| Col3 |  C1  |  C2  |  C3  |
+------+------+------+------+
</code></pre>

    <p>
        Stocker les donnÃ©es au format colonnaire apporte de nombreux avantages, comme :
    </p>
    <ul>
        <li>Bien meilleure capacitÃ© de compression des donnÃ©es</li>
        <li>PossibilitÃ© de lire seulement les colonnes sÃ©lectionnÃ©es</li>
        <li>PossibilitÃ© de chiffrer les colonnes sÃ©lectionnÃ©es ou toutes</li>
    </ul>

    <p>
        Dans le cas du format par lignes, pour lire seulement une colonne, nous devons quand mÃªme parcourir tout le fichier.<br/>
        Dans le cas du format colonnaire nous pouvons lire seulement les colonnes qui nous intÃ©ressent.<br/>
        C'est particuliÃ¨rement utile dans le cas de trÃ¨s gros ensembles de donnÃ©es, oÃ¹ souvent nous n'avons besoin que d'une partie de l'information.
    </p>


    <a href="#immutable"><h2 id="immutable">Immuable</h2></a>
    <p>
        En raison de la faÃ§on dont les donnÃ©es sont stockÃ©es au format colonnaire, les fichiers Parquet sont immuables.<br/>
        Cela ne signifie pas cependant qu'on ne peut pas les modifier. On peut, mais la seule opÃ©ration sensÃ©e est d'ajouter des donnÃ©es Ã  la fin.
    </p>
    <p>
        Pourquoi ? Parquet stocke les donnÃ©es au format colonnaire, cela signifie que si nous avons une colonne <code>email</code>
        toutes les lignes (dans un groupe de lignes et une page donnÃ©s - de cela plus tard) seront Ã©crites l'une aprÃ¨s l'autre. </br>
        Essayer de modifier une ligne est donc impossible, parce que cela nÃ©cessiterait de dÃ©placer pratiquement tout le fichier.
    </p>
    <p>
        Il est cependant possible d'ajouter un nouveau groupe de lignes Ã  la fin du fichier. Cela se fait en retirant les mÃ©tadonnÃ©es de la fin du fichier,
        qui temporairement vont en mÃ©moire. Ã€ leur place on Ã©crit le nouveau groupe de lignes (qu'il faut aussi ajouter aux mÃ©tadonnÃ©es),
        et ensuite Ã  la fin on rÃ©Ã©crit les mÃ©tadonnÃ©es.
    </p>
    <p>
        Pour cette raison, si nous voulons supprimer quelque chose d'un fichier Parquet, en pratique nous devons rÃ©Ã©crire tout le fichier, en omettant
        les donnÃ©es indÃ©sirables.
    </p>

    <a href="#metadata"><h2 id="metadata">Structure Forte</h2></a>
    <p>
        Parquet est un format basÃ© sur le typage fort. Cela signifie que la structure de tout le fichier est dÃ©finie et stockÃ©e dans le pied de page,
        grÃ¢ce Ã  quoi il suffit de lire seulement le segment appropriÃ© pour comprendre quelles donnÃ©es nous avons dans le fichier, et dans quelles
        rÃ©gions du fichier ces donnÃ©es sont sauvegardÃ©es.
    </p>
    <p>
        Nous pouvons penser Ã  cela comme Ã  une carte du fichier, une carte qui nous dira oÃ¹ exactement dans le fichier se trouvent
        les donnÃ©es qui nous intÃ©ressent.
    </p>
    <p>
        Voici comment ressemble Ã  peu prÃ¨s la structure simplifiÃ©e d'un fichier au format Parquet :
    </p>
    <pre><code class="code-shell" data-controller="syntax-highlight">+-----------------+
| PAR1            |
+-----------------+
| Data            |
| .............   |
| .............   |
+-----------------+
| File Metadata   |
+-----------------+
| PAR1            |
+-----------------+</code></pre>

    <p>
        Dans l'exemple ci-dessus nous voyons 3 Ã©lÃ©ments :
    </p>

    <ul>
        <li><code>PAR1</code> - c'est-Ã -dire "Parquet Magic Bytes" - 4 octets ouvrant et fermant les fichiers au format Parquet</li>
        <li><code>Data</code> - ici sont sauvegardÃ©es toutes les colonnes (de cela plus tard)</li>
        <li><code>Metadata</code> - mÃ©tadonnÃ©es, c'est-Ã -dire la carte du fichier</li>
    </ul>

    <p>
        La premiÃ¨re Ã©tape pour lire correctement un fichier Parquet est de vÃ©rifier si les 4 premiers octets sont <code>PAR1</code>.<br/>
        Si c'est le cas, nous devons sauter Ã  la fin du fichier (seek) et lire les 4 derniers octets.
    </p>
    <p>
        Si la fin et le dÃ©but du fichier contiennent <code>PAR1</code> nous pouvons procÃ©der Ã  la lecture des mÃ©tadonnÃ©es.
    </p>
    <p>
        Pour cela nous reculons de 8 octets depuis la fin du fichier et lisons 4 octets reprÃ©sentant la taille des mÃ©tadonnÃ©es.
        En d'autres termes, nous lisons les octets <code>-8</code> Ã  <code>-4</code>
    </p>
    <p>
        Ces 4 octets sont un <code>integer</code> nous disant sur combien d'octets sont Ã©crites les mÃ©tadonnÃ©es. Ayant
        cette information nous pouvons lire les mÃ©tadonnÃ©es, qui sont sÃ©rialisÃ©es de maniÃ¨re binaire Ã  l'aide d'<a href="https://thrift.apache.org/" target="_blank">Apache Thrift</a>
    </p>
    <a href="#apache-thrift"><h2 id="apache-thrift">Apache Thrift</h2></a>
    <p>
        Apache Thrift est un outil trÃ¨s intelligent permettant la sÃ©rialisation binaire d'interfaces / types dans pratiquement chaque
        langage de programmation.
    </p>
    <p>
        <a href="https://github.com/flow-php/flow/blob/1.x/src/lib/parquet/src/Flow/Parquet/Resources/Thrift/parquet_clean.thrift" target="_blank">Ici</a>
        nous pouvons voir comment ressemble la dÃ©finition des mÃ©tadonnÃ©es au format Parquet.
    </p>
    <p>
        Ce format ressemble un peu Ã  du pseudocode, qui ensuite Ã  l'aide de l'application appropriÃ©e est utilisÃ© pour gÃ©nÃ©rer
        du code dans un langage de programmation donnÃ©.
    </p>
    <p>
        <a href="https://github.com/flow-php/flow/tree/1.x/src/lib/parquet/src/Flow/Parquet/Thrift" target="_blank">Ici</a>
        nous pouvons voir comment ressemble le code gÃ©nÃ©rÃ© en PHP.
    </p>
    <p>
        Quand nous avons dÃ©jÃ  les structures/interfaces/modÃ¨les gÃ©nÃ©rÃ©s nous pouvons procÃ©der Ã  la lecture.
    </p>

    <pre><code class="code-php" data-controller="syntax-highlight">&lt;?php

use Flow\Parquet\Thrift\FileMetaData;
use Thrift\Protocol\TCompactProtocol;
use Thrift\Transport\TMemoryBuffer;

$metadataLength = \unpack($this-&gt;byteOrder-&gt;value, $this-&gt;stream-&gt;read(4, $fileTotalSize - 8))[1];

$fileMetadata = new FileMetaData();
$fileMetadata-&gt;read(
    new TCompactProtocol(
        new TMemoryBuffer(
            $this-&gt;stream-&gt;read($metadataLength, $fileTotalSize - ($metadataLength + 8))
        )
    )
);</code></pre>

    <p>
        Pour cela nous aurons besoin de la bibliothÃ¨que Thrift pour le langage de programmation choisi.
        Toutes les implÃ©mentations sont disponibles dans le dÃ©pÃ´t <a href="https://github.com/apache/thrift" target="_blank">apache/thrift</a>.
    </p>

    <p>
        Ayant accÃ¨s Ã  <code>$metadata</code> nous pouvons commencer Ã  analyser notre fichier pour comprendre sa structure.<br/>
    </p>

    <a href="#parquet-file-metadata"><h2 id="parquet-file-metadata">Parquet - FileMetaData</h2></a>

    <pre><code class="code-shell" data-controller="syntax-highlight">struct FileMetaData {
  1: required i32 version
  2: required list&lt;SchemaElement&gt; schema;
  3: required i64 num_rows
  4: required list&lt;RowGroup&gt; row_groups
  5: optional list&lt;KeyValue&gt; key_value_metadata
  6: optional string created_by
  7: optional list&lt;ColumnOrder&gt; column_orders;
  8: optional EncryptionAlgorithm encryption_algorithm
  9: optional binary footer_signing_key_metadata
}</code></pre>

    <p>
        Les informations clÃ©s sur le fichier sont stockÃ©es dans la structure <code>FileMetaData</code>.
        Les plus importantes d'entre elles sont :
    </p>
    <ul>
        <li><code>version</code> - version du format Parquet</li>
        <li><code>num_rows</code> - nombre de lignes dans le fichier</li>
        <li><code>schema</code> - schÃ©ma des donnÃ©es</li>
        <li><code>row_groups</code> - ici sont stockÃ©es nos donnÃ©es</li>
    </ul>

    <a href="#format-versions"><h2 id="format-versions">Versions du Format</h2></a>
    <p>
        Au moment d'Ã©crire cet article le format Parquet Ã©tait dÃ©jÃ  disponible en version <code>2.12.0</code>.
    </p>
    <p>
        Les changements les plus cruciaux entre les versions 1.0 et 2.0 sont :
    </p>
    <ul>
        <li><strong>Nouveaux schÃ©mas d'encodage :</strong> DELTA_BINARY_PACKED pour les nombres, DELTA_BYTE_ARRAY pour les chaÃ®nes, RLE_DICTIONARY remplaÃ§ant PLAIN_DICTIONARY</li>
        <li><strong>Structure Data Page V2 :</strong> Ã‰liminÃ© la surcharge de mÃ©tadonnÃ©es, permis le filtrage au niveau des pages</li>
    </ul>
    <p>
        Bien que la version 2.0 introduise de nombreuses amÃ©liorations, les plus grands acteurs utilisent encore la version 1 par dÃ©faut.
    </p>
    <a href="#rows-count"><h2 id="rows-count">Nombre de Lignes</h2></a>
    <p>
        Cette information peut sembler peu intuitive au dÃ©but dans le contexte du format colonnaire.<br/>
        Nous devons cependant nous rappeler que le format colonnaire n'est qu'une faÃ§on de stocker les valeurs et non la structure des donnÃ©es.
    </p>
    <p>
        Bien que les donnÃ©es soient groupÃ©es sur la base des colonnes et de leur type, la lecture/Ã©criture se fait encore de maniÃ¨re classique,
        c'est-Ã -dire ligne par ligne.
    </p>
    <p>
        La diffÃ©rence est qu'on ne lit pas une ligne Ã  la fois, mais tout un groupe de lignes, chargeant en mÃ©moire
        colonne par colonne, puis reconstruisant les lignes sur la base des index appropriÃ©s.
    </p>
    <div class="notice">
    <p>
        En gardant Ã  l'esprit que pour Ã©crire correctement les donnÃ©es au format colonnaire nous devons opÃ©rer sur des groupes logiques, et non sur des lignes individuelles.
        Nous pouvons de maniÃ¨re relativement facile gÃ©rer le rapport entre mÃ©moire et quantitÃ© d'opÃ©rations IO.
    </p>
    </div>
    <p>
        L'Ã©criture et la lecture depuis la mÃ©moire est plus rapide que l'Ã©criture et la lecture depuis le disque (<a href="https://www.bitflux.ai/blog/memory-is-slow-part1/" target="_blank">bien que pas toujours</a>).
        En augmentant la quantitÃ© de lignes qui seront Ã©crites dans un groupe, nous rÃ©duisons le nombre de groupes, c'est-Ã -dire le nombre d'opÃ©rations IO. <br/>
        Ainsi nous augmentons la vitesse d'Ã©criture/lecture, tout en augmentant l'utilisation de la mÃ©moire.
    </p>
    <p>
        Cela marche aussi dans l'autre sens, en rÃ©duisant la quantitÃ© de lignes dans un groupe, nous augmentons le nombre de groupes dans le fichier, ainsi
        augmentant le nombre d'opÃ©rations IO.
    </p>
    <p>
        <strong>Taille du groupe, pas quantitÃ© de lignes</strong> - Parquet permet de dÃ©finir non pas la quantitÃ© de lignes, mais la taille maximale
        du groupe de lignes. <br/>
        Il faut cependant se rappeler que ce ne sont pas des valeurs absolues (de cela un peu plus tard), donc
        certains groupes peuvent Ãªtre plus petits/plus gros que la taille permise et cela dÃ©pend principalement de l'implÃ©mentation de la bibliothÃ¨que
        pour Parquet.
    </p>
    <p>
        Dans la documentation du format Parquet nous trouverons l'information que la taille suggÃ©rÃ©e du groupe est <code>512Mo - 1Go</code>.
        Il vaut cependant la peine d'aborder cela avec un peu de bon sens, surtout si pour la lecture/Ã©criture nous ne dÃ©pendons pas de HDFS (Hadoop Distributed File System). <br/>
        La valeur suggÃ©rÃ©e est Ã©tablie de telle maniÃ¨re qu'un groupe de lignes tienne dans un bloc HDFS, garantissant que la lecture
        se fasse depuis exactement un nÅ“ud.
    </p>
    <p>
        Il vaut la peine de s'en souvenir, cependant si nous ne prÃ©voyons pas d'utiliser Parquet avec un systÃ¨me de fichiers distribuÃ©, des groupes de lignes plus petits
        permettront d'Ã©conomiser beaucoup de mÃ©moire.
    </p>
    <p>
        Un trÃ¨s bon exemple de cas oÃ¹ des groupes plus petits sont plus efficaces est le cas oÃ¹ nous voudrions lire
        seulement une petite section de lignes quelque part au milieu du fichier (pagination).
    </p>
    <p>
        En supposant que nous devons lire seulement 100 lignes d'un fichier qui contient 10 millions de lignes, Ã©tablir une taille de groupe plus petite
        permettra d'Ã©conomiser beaucoup en mÃ©moire. Pourquoi ?
    </p>
    <p>
        Si nous divisons 10 millions en disons 10 groupes, chaque groupe contient 1 million de lignes. Cela signifie qu'en pratique
        nous devons lire tout le groupe, puis extraire seulement les 100 lignes qui nous intÃ©ressent.
    </p>
    <p>
        Dans le cas d'Ã©tablir une taille de groupe plus petite, qui permettrait de diviser 10 millions en 1000 groupes, en analysant
        les mÃ©tadonnÃ©es du fichier, nous pourrons sauter une plus grande quantitÃ© de groupes et charger en mÃ©moire une quantitÃ© beaucoup plus petite de lignes.
    </p>
    <div class="notice">
    <p>
        La dÃ©cision sur la taille du groupe de lignes devrait Ãªtre rÃ©flÃ©chie tant pour la performance d'Ã©criture que de lecture
        du fichier spÃ©cifique. La configuration appropriÃ©e se traduit directement par l'utilisation de ressources ce qui finalement se traduit
        par de l'argent.
    </p>
    </div>

    <a href="#schema"><h2 id="schema">SchÃ©ma</h2></a>

    <p>
        Lentement nous arrivons au cÅ“ur de Parquet, c'est-Ã -dire <code>Row Groups</code>. Mais avant d'analyser leur structure, nous devons
        revenir Ã  un autre aspect trÃ¨s important de Parquet, le schÃ©ma des donnÃ©es.
    </p>

    <p>
        CommenÃ§ons par les types de donnÃ©es. Parquet consiste en types physiques et logiques.
    </p>

    <h3>Types Physiques</h3>

    <p>
        Les types physiques sont les types de donnÃ©es de base qui sont utilisÃ©s pour stocker les valeurs dans le fichier Parquet.
        Ce sont des types tels que :
    </p>

    <ul>
        <li>Boolean</li>
        <li>Byte Array</li>
        <li>Double</li>
        <li>Fixed Len Byte Array</li>
        <li>Float</li>
        <li>Int32</li>
        <li>Int64</li>
        <li>Int96 - (dÃ©prÃ©ciÃ© - utilisÃ© seulement par les anciennes implÃ©mentations)</li>
    </ul>

    <p>
        Les types logiques sont des types qui sont utilisÃ©s pour reprÃ©senter des structures de donnÃ©es plus complexes. On peut
        penser Ã  eux comme Ã  une extension des types physiques.
    </p>

    <h3>Types Logiques</h3>

    <ul>
        <li>Bson</li>
        <li>Date</li>
        <li>Decimal</li>
        <li>Enum</li>
        <li>Integer</li>
        <li>Json</li>
        <li>List</li>
        <li>Map</li>
        <li>String</li>
        <li>Time</li>
        <li>Timestamp</li>
        <li>Uuid</li>
    </ul>

    <p>
        La structure actuelle peut toujours Ãªtre vÃ©rifiÃ©e Ã  la source, <a href="https://github.com/apache/parquet-format/blob/master/src/main/thrift/parquet.thrift" target="_blank">apache/parquet-format</a>
    </p>

    <p>
        Outre la division en types logiques et physiques, Parquet distingue aussi les colonnes plates et imbriquÃ©es.<br/>
        <strong>Les colonnes plates</strong> sont celles qui stockent une seule valeur, par exemple <code>Int32</code>, <code>Boolean</code>, <code>Float</code>, etc.<br/>
        <strong>Les colonnes imbriquÃ©es</strong> sont celles qui stockent plus d'une valeur, par exemple <code>List</code>, <code>Map</code>, etc.
    </p>

    <p>
        En principe il existe 3 types de colonnes imbriquÃ©es :
    </p>
    <ul>
        <li>List</li>
        <li>Map</li>
        <li>Struct</li>
    </ul>
    <p>
        <strong>Struct</strong>, est un type spÃ©cial de colonne qui permet d'imbriquer n'importe quels autres types, permettant de crÃ©er
        pratiquement n'importe quelle structure de donnÃ©es.
    </p>
    <p>
        En utilisant les types ci-dessus nous sommes capables de modÃ©liser pratiquement n'importe quelle
        structure de donnÃ©es, puis de la stocker et de la rechercher efficacement.
    </p>
    <p>
        Regardons donc les dÃ©finitions Thrift <code>SchemaElement</code> et quelques Ã©lÃ©ments liÃ©s.
    </p>

    <pre><code class="code-shell" data-controller="syntax-highlight">struct SchemaElement {
  1: optional Type type;
  2: optional i32 type_length;
  3: optional FieldRepetitionType repetition_type;
  4: required string name;
  5: optional i32 num_children;
  6: optional ConvertedType converted_type;
  7: optional i32 scale
  8: optional i32 precision
  9: optional i32 field_id;
  10: optional LogicalType logicalType
}

enum FieldRepetitionType {
  REQUIRED = 0;
  OPTIONAL = 1;
  REPEATED = 2;
}

enum Type {
  BOOLEAN = 0;
  INT32 = 1;
  INT64 = 2;
  INT96 = 3;
  FLOAT = 4;
  DOUBLE = 5;
  BYTE_ARRAY = 6;
  FIXED_LEN_BYTE_ARRAY = 7;
}

union LogicalType {
  1:  StringType STRING
  2:  MapType MAP
  3:  ListType LIST
  4:  EnumType ENUM
  5:  DecimalType DECIMAL
  6:  DateType DATE
  7:  TimeType TIME
  8:  TimestampType TIMESTAMP
  10: IntType INTEGER
  11: NullType UNKNOWN
  12: JsonType JSON
  13: BsonType BSON
  14: UUIDType UUID
}</code></pre>

    <p>
        La plupart des valeurs devraient Ãªtre assez Ã©videntes, regardons cependant <code>FieldRepetitionType</code>.
    </p>

    <p>
        Cette valeur nous dit si une colonne donnÃ©e est requise, optionnelle ou rÃ©pÃ©table.<br/>
        Si une colonne est requise, cela signifie que la valeur ne peut pas Ãªtre nulle. <br/>
        Si une colonne est optionnelle la valeur peut Ãªtre nulle, et si elle est rÃ©pÃ©table, cela signifie qu'elle peut contenir plusieurs valeurs (par exemple une liste).
    </p>

    <p>
        Voici comment peut ressembler le schÃ©ma d'un fichier de commandes (sous forme DDL)
    </p>

    <pre><code class="code-shell" data-controller="syntax-highlight">message orders_scheme {
    required fixed_len_byte_array(16) order_id (UUID)
    required int64 created_at (TIMESTAMP(MICROS,false))
    optional int64 updated_at (TIMESTAMP(MICROS,false))
    optional float discount
    required binary email (STRING)
    required binary customer (STRING)
    required group address {
          required binary street (STRING);
          required binary city (STRING);
          required binary zip (STRING);
          required binary country (STRING);
    }
    required group notes (LIST) {
          repeated group list {
                required binary element (STRING);
          }
    }
    required group items (LIST) {
          repeated group list {
                required group element {
                      required binary sku (STRING);
                      required int64 quantity (INTEGER(64,true));
                      required float price;
                }
          }
    }
}</code></pre>

    <a href="#nested-types"><h2 id="nested-types">Types ImbriquÃ©s</h2></a>

    <p>
        Pour comprendre pleinement la structure des groupes de lignes nous devons d'abord comprendre comment Parquet aplatit les types imbriquÃ©s.<br/>
        Alors que des structures simples comme <code>address</code> de l'exemple ci-dessus peuvent Ãªtre rÃ©duites essentiellement Ã  4 colonnes simples :
    </p>
    <ul>
        <li><code>address.street</code> - String</li>
        <li><code>address.city</code> - String</li>
        <li><code>address.zip</code> - String</li>
        <li><code>address.country</code> - String</li>
    </ul>
    <p>
        Dans le cas de <code>Map</code> ou <code>List</code> la situation est un peu plus compliquÃ©e.
    </p>
    <p>
        Par exemple, si nous voulions aplatir <code>Map&lt;string,int32&gt;</code> nous obtiendrions quelque chose comme ceci :
    </p>
    <ul>
        <li><code>map_column.key_value.key</code> - String</li>
        <li><code>map_column.key_value.value</code> - Int32</li>
    </ul>
    <p>
        Donc pour l'exemple ci-dessus le chemin plat vers <code>sku</code> ressemblerait Ã  ceci :
        <code>items.list.element.sku</code>, tandis que la structure plate complÃ¨te ressemblerait Ã  ceci :
    </p>
    <pre><code class="code-shell" data-controller="syntax-highlight">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Columns â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ path                        â”‚ type                     â”‚ logical type â”‚ repetition â”‚ max repetition â”‚ max definition â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ order_id                    â”‚ FIXED_LEN_BYTE_ARRAY(16) â”‚ UUID         â”‚ REQUIRED   â”‚ 0              â”‚ 0              â”‚
â”‚ created_at                  â”‚ INT64                    â”‚ TIMESTAMP    â”‚ REQUIRED   â”‚ 0              â”‚ 0              â”‚
â”‚ updated_at                  â”‚ INT64                    â”‚ TIMESTAMP    â”‚ OPTIONAL   â”‚ 0              â”‚ 1              â”‚
â”‚ discount                    â”‚ FLOAT                    â”‚ -            â”‚ OPTIONAL   â”‚ 0              â”‚ 1              â”‚
â”‚ email                       â”‚ BYTE_ARRAY               â”‚ STRING       â”‚ REQUIRED   â”‚ 0              â”‚ 0              â”‚
â”‚ customer                    â”‚ BYTE_ARRAY               â”‚ STRING       â”‚ REQUIRED   â”‚ 0              â”‚ 0              â”‚
â”‚ address.street              â”‚ BYTE_ARRAY               â”‚ STRING       â”‚ REQUIRED   â”‚ 0              â”‚ 0              â”‚
â”‚ address.city                â”‚ BYTE_ARRAY               â”‚ STRING       â”‚ REQUIRED   â”‚ 0              â”‚ 0              â”‚
â”‚ address.zip                 â”‚ BYTE_ARRAY               â”‚ STRING       â”‚ REQUIRED   â”‚ 0              â”‚ 0              â”‚
â”‚ address.country             â”‚ BYTE_ARRAY               â”‚ STRING       â”‚ REQUIRED   â”‚ 0              â”‚ 0              â”‚
â”‚ notes.list.element          â”‚ BYTE_ARRAY               â”‚ STRING       â”‚ REQUIRED   â”‚ 1              â”‚ 1              â”‚
â”‚ items.list.element.sku      â”‚ BYTE_ARRAY               â”‚ STRING       â”‚ REQUIRED   â”‚ 1              â”‚ 1              â”‚
â”‚ items.list.element.quantity â”‚ INT64                    â”‚ -            â”‚ REQUIRED   â”‚ 1              â”‚ 1              â”‚
â”‚ items.list.element.price    â”‚ FLOAT                    â”‚ -            â”‚ REQUIRED   â”‚ 1              â”‚ 1              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>

    <a href="#row-groups"><h2 id="row-groups">Groupes de Lignes</h2></a>

    <pre><code class="code-shell" data-controller="syntax-highlight">+-----------------------------------+
| PAR1                              |
+-----------------------------------+
| Row Group 1                       |
|   +-----------------------------+ |
|   | Column Chunk 1              | |
|   |   (Metadata + Data Pages)   | |
|   +-----------------------------+ |
|   | Column Chunk 2              | |
|   |   (Metadata + Data Pages)   | |
|   +-----------------------------+ |
|   ...                             |
+-----------------------------------+
| Row Group 2                       |
|   +-----------------------------+ |
|   | Column Chunk 1              | |
|   |   (Metadata + Data Pages)   | |
|   +-----------------------------+ |
|   | Column Chunk 2              | |
|   |   (Metadata + Data Pages)   | |
|   +-----------------------------+ |
|   ...                             |
+-----------------------------------+
| ...                               |
+-----------------------------------+
| Metadata                          |
+-----------------------------------+
| PAR1                              |
+-----------------------------------+</code></pre>

    <p>
        ConformÃ©ment Ã  ce que nous savons dÃ©jÃ , un fichier Parquet est divisÃ© en groupes de lignes, l'Ã©criture au fichier fonctionne en rÃ©sumÃ© ainsi :
    </p>
    <ul>
        <li>1) crÃ©er le fichier et ajouter 4 octets <code>PAR1</code></li>
        <li>2) crÃ©er une structure de mÃ©tadonnÃ©es basÃ©e sur le schÃ©ma et la garder en mÃ©moire</li>
        <li>3) aplatir la ligne passÃ©e (en vÃ©rifiant si elle correspond au schÃ©ma)</li>
        <li>4) Ã©crire la ligne aplatie en mÃ©moire sous forme binaire</li>
        <li>
            5) vÃ©rifier si la taille du groupe de lignes que nous avons actuellement en mÃ©moire rentre dans la taille maximale permise
            <ul>
                <li>a) Ã©crire le groupe de lignes au fichier</li>
                <li>b) mettre Ã  jour les mÃ©tadonnÃ©es en mÃ©moire en leur ajoutant les mÃ©tadonnÃ©es du groupe que nous venons d'Ã©crire</li>
            </ul>
        </li>
        <li>
            6) retourner Ã  l'Ã©tape 2
        </li>
        <li>
            7) Ã‰crire les mÃ©tadonnÃ©es Ã  la fin du fichier aprÃ¨s avoir Ã©crit tous les groupes de lignes
        </li>
        <li>
            8) Fermer le fichier avec 4 octets <code>PAR1</code>
        </li>
    </ul>
    <div class="notice">
    <p>
        Bien sÃ»r cette description est trÃ¨s simplifiÃ©e, en rÃ©alitÃ© c'est un peu plus complexe, de plus diffÃ©rentes implÃ©mentations
        peuvent diffÃ©rer dans les dÃ©tails.
    </p>
    </div>

    <p>
        Concentrons-nous sur la structure du groupe de lignes, regardons d'abord les dÃ©finitions Thrift <code>RowGroup</code>.
    </p>

    <pre><code class="code-shell" data-controller="syntax-highlight">struct RowGroup {
  1: required list&lt;ColumnChunk&gt; columns
  2: required i64 total_byte_size
  3: required i64 num_rows
  4: optional list&lt;SortingColumn&gt; sorting_columns
  5: optional i64 file_offset
  6: optional i64 total_compressed_size
  7: optional i16 ordinal
}
</code></pre>

    <p>
        DÃ©jÃ  Ã  cette Ã©tape on voit combien d'informations sur un groupe spÃ©cifique de lignes sont stockÃ©es dans les mÃ©tadonnÃ©es.<br/>
        Pour l'instant concentrons-nous sur trois champs :
    </p>
    <ul>
        <li><code>file_offset</code> - c'est-Ã -dire combien d'octets depuis le dÃ©but du fichier il faut sauter pour lire le groupe donnÃ©</li>
        <li><code>total_byte_size</code> - sur combien d'octets est Ã©crit le groupe de lignes</li>
        <li><code>columns</code> - informations dÃ©taillÃ©es sur chaque colonne Ã©crite dans le cadre du groupe donnÃ©</li>
    </ul>

    <div class="important">
        <p>
            <strong>Important :</strong> chaque groupe de lignes contient toujours toutes les colonnes dÃ©finies dans le schÃ©ma.<br/>
            MÃªme si sur l'Ã©tendue de tout le groupe une colonne ne contient que des valeurs nulles.
        </p>
    </div>

    <a href="#column-chunks"><h2 id="column-chunks">Chunks de Colonne</h2></a>

    <p>
        Allons plus profond et regardons la dÃ©finition Thrift <code>ColumnChunk</code>
    </p>
    <pre><code class="code-shell" data-controller="syntax-highlight">struct ColumnChunk {
  1: optional string file_path
  2: required i64 file_offset
  3: optional ColumnMetaData meta_data
  4: optional i64 offset_index_offset
  5: optional i32 offset_index_length
  6: optional i64 column_index_offset
  7: optional i32 column_index_length
  8: optional ColumnCryptoMetaData crypto_metadata
  9: optional binary encrypted_column_metadata
}

struct ColumnMetaData {
  1: required Type type
  2: required list&lt;Encoding&gt; encodings
  3: required list&lt;string&gt; path_in_schema
  4: required CompressionCodec codec
  5: required i64 num_values
  6: required i64 total_uncompressed_size
  7: required i64 total_compressed_size
  8: optional list&lt;KeyValue&gt; key_value_metadata
  9: required i64 data_page_offset
  10: optional i64 index_page_offset
  11: optional i64 dictionary_page_offset
  12: optional Statistics statistics;
  13: optional list&lt;PageEncodingStats&gt; encoding_stats;
  14: optional i64 bloom_filter_offset;
  15: optional i32 bloom_filter_length;
}
</code></pre>

    <div class="notice">
        <p>
            <strong>Rappel :</strong> Tout ce sur quoi nous avons regardÃ© jusqu'Ã  maintenant fait encore partie des mÃ©tadonnÃ©es. <br/>
            Cela signifie que toute cette information sur les colonnes, groupes de lignes ou les donnÃ©es elles-mÃªmes nous l'obtenons en lisant
            seulement la fin du fichier, indÃ©pendamment de si le fichier fait 1Mo ou 1To.
        </p>
    </div>

    <p>
        Ici nous arrivons essentiellement Ã  l'endroit qui nous permet de lire les donnÃ©es du fichier. <br/>
        Mais avant que cela n'arrive nous devons connaÃ®tre la derniÃ¨re structure de donnÃ©es nÃ©cessaire Ã  la lecture.
    </p>

    <a href="#data-pages"><h2 id="data-pages">Pages de DonnÃ©es</h2></a>

    <p>
        <code>Pages</code>, c'est-Ã -dire une autre division logique dans la structure du fichier Parquet.<br/>
        <code>Row Group -> Column Chunk -> Data Pages</code>
    </p>

    <ul>
        <li><code>RowGroup</code> - groupe de lignes (partition)</li>
        <li><code>ColumnChunk</code> - chaque groupe de lignes contient exactement 1 <code>ColumnChunk</code> pour chaque colonne dans le groupe</li>
        <li><code>Data Page</code> - page, la plus petite unitÃ© logique dans Parquet agrÃ©geant les donnÃ©es</li>
    </ul>

    <p>
        En fait la lecture de Parquet se rÃ©sume Ã  analyser la structure des mÃ©tadonnÃ©es, localiser l'adresse du dÃ©but d'un groupe spÃ©cifique de lignes, puis
        une colonne spÃ©cifique dans le groupe, puis itÃ©rer et lire les donnÃ©es de chaque page.
    </p>

    <p>
        Mais avant de commencer Ã  lire les pages, nous devons comprendre si nous avons affaire Ã  <code>DataPage</code>, <code>IndexPage</code> ou <code>DictionaryPage</code>.
    </p>
    <p>
        Pour cela nous lisons d'abord <code>PageHeader</code> c'est-Ã -dire l'en-tÃªte de la page, dont la dÃ©finition Thrift ressemble Ã  ceci
    </p>

    <pre><code class="code-shell" data-controller="syntax-highlight">struct PageHeader {
  1: required PageType type
  2: required i32 uncompressed_page_size
  3: required i32 compressed_page_size
  4: optional i32 crc
  5: optional DataPageHeader data_page_header;
  6: optional IndexPageHeader index_page_header;
  7: optional DictionaryPageHeader dictionary_page_header;
  8: optional DataPageHeaderV2 data_page_header_v2;
}

enum PageType {
  DATA_PAGE = 0;
  INDEX_PAGE = 1;
  DICTIONARY_PAGE = 2;
  DATA_PAGE_V2 = 3;
}</code></pre>

    <p>
        Pour lire l'en-tÃªte nous devons connaÃ®tre son adresse relative au dÃ©but du fichier, voici comment nous pouvons la calculer pour un groupe de lignes et une colonne sÃ©lectionnÃ©s :
    </p>

    <ol>
        <li>Nous lisons <code>FileMetadata</code></li>
        <li>Nous trouvons le <code>RowGroup</code> appropriÃ© et recherchons le <code>ColumnChunk</code> pertinent pour nous</li>
        <li>Ayant <code>ColumnChunk</code> nous obtiendrons l'adresse <code>file_offset</code> du dÃ©but de <code>ColumnChunk</code> relative au dÃ©but du fichier.</li>
    </ol>

    <div class="important">
        <p>
            <strong>Important :</strong> Ã€ cette Ã©tape nous n'avons pas encore besoin de charger physiquement les octets en mÃ©moire.<br/>
            Il suffit que nous crÃ©ions un <code>stream</code> permettant de lire les donnÃ©es directement depuis le fichier.
        </p>
    </div>

    <p>
        La premiÃ¨re chose qu'il faut lire est l'en-tÃªte, <code>PageHeader</code>, en le faisant avec Thrift, en passant
        le stream et en configurant appropriÃ©ment l'adresse du dÃ©but nous obtiendrons la structure de donnÃ©es <code>PageHeader</code>, qui nous dira exactement comment lire
        la page elle-mÃªme.
    </p>
    <p>
        Il existe 3 types de pages :
    </p>
    <h3><code>DataPage</code></h3>
    <p>
        Page contenant la reprÃ©sentation binaire des donnÃ©es de la colonne sÃ©lectionnÃ©e des lignes qui sont allÃ©es dans le groupe de lignes sÃ©lectionnÃ©.<br/>
        C'est le type de page le plus simple et le plus direct. Elle contient "seulement" des donnÃ©es.
    </p>
    <p>
        En lisant une colonne de type entier, ce qui nous intÃ©resse c'est vraiment le nombre de lignes dans le groupe spÃ©cifique (chaque ligne est une valeur dans <code>DataPage</code>).
        Donc en sachant que dans ce groupe nous avons disons 100 valeurs, nous savons que nous devons lire 400 octets (int32 est Ã©crit sur 4 octets). <br/>
    </p>
    <p>
        Bon, mais que se passe-t-il quand la colonne est optionnelle ? Cela signifie qu'elle peut contenir des valeurs nulles.<br/>
        Ici la situation devient un peu plus compliquÃ©e parce que nous devons savoir quelles lignes contiennent une valeur nulle.<br/>
        D'oÃ¹ vient cette connaissance ?<br/>
        <code>Definition Levels</code>
    </p>
    <p>
        La situation se complique un peu, au dÃ©but j'ai Ã©crit que <code>DataPage</code> contient seulement des donnÃ©es, et maintenant j'ajoute des <code>Definition Levels</code>.<br/>
    </p>
    <p>
        En rÃ©alitÃ© la structure de data page ressemble Ã  peu prÃ¨s Ã  ceci :
    </p>
    <pre><code class="code-shell" data-controller="syntax-highlight">Parquet Data Page: int32
=======================================
[ Repetition Levels ]: 0, 0, 0, 0, 0
---------------------------------------
[ Definition Levels ]: 1, 0, 1, 1, 0
---------------------------------------
[ Values           ]: 42, 73, 19
=======================================
</code></pre>
    <p>
        Pour l'instant, concentrons-nous seulement sur <code>Definition Levels</code> et <code>Values</code>. Il est trÃ¨s facile de remarquer la relation entre eux.
        La quantitÃ© de <code>Definition Level</code> et <code>Repetition Levels</code> dans chaque page est toujours Ã©gale Ã  la quantitÃ© de valeurs dans la colonne.<br/>
        Peu importe s'il y a des nulls ou pas. <code>Definition Levels</code> nous disent si une ligne donnÃ©e contient une valeur ou null.
    </p>
    <p>
        Sur cette base, nous pouvons facilement dÃ©terminer la quantitÃ© totale de <code>Values</code> non vides ce qui nous permettra de les lire. <br/>
        Dans l'exemple ci-dessus nous avons 5 lignes, dont 3 constituent des valeurs, puisque <code>int32</code> nous l'Ã©crivons sur 4 octets,
        nous savons dÃ©jÃ  que nous devons lire en total 12 octets.<br/>
        Nous savons aussi qu'en transformant la colonne en lignes, la premiÃ¨re ligne contiendra la valeur <code>42</code>, la deuxiÃ¨me <code>null</code>,
        la troisiÃ¨me <code>73</code>, la quatriÃ¨me <code>19</code> et la cinquiÃ¨me <code>null</code>.
    </p>
    <div class="important">
        <p>
            <strong>Important :</strong> <code>Repetition Levels</code> et <code>Definition Levels</code> sont cependant beaucoup plus compliquÃ©s, un peu plus plus tard.<br/>
        </p>
    </div>
    <p>
        Voici comment se prÃ©sente Ã  peu prÃ¨s la structure de <code>DataPage</code>.
    </p>
    <h3><code>DictionaryPage</code></h3>
    <p>
        Si nous gardons les donnÃ©es dans <code>DataPage</code>, quel but a <code>DictionaryPage</code> ?<br/>
        Eh bien <code>DictionaryPage</code> est une page qui contient un dictionnaire de valeurs.<br/>
        Dictionnaire, utilisÃ© pour lire les donnÃ©es, surtout dans le cas de colonnes contenant des valeurs rÃ©pÃ©tables.
    </p>

    <p>
        Cela marche Ã  peu prÃ¨s ainsi qu'en lisant <code>ColumChunk</code>, nous commenÃ§ons par la premiÃ¨re page, si cette page est <code>DictionaryPage</code>,
        nous savons que nous avons affaire Ã  un dictionnaire (en fait nous le savons depuis le dÃ©but, parce que c'est Ã©crit dans les mÃ©tadonnÃ©es de la colonne).
    </p>
    <p>
        Si par exemple nous lisons une colonne avec haute rÃ©pÃ©tabilitÃ©, ex. une colonne avec le nom du pays, au lieu d'Ã©crire dans <code>DataPage</code> le nom complet du pays pour chaque ligne,
        nous Ã©crivons seulement sa position dans le dictionnaire.<br/>
        Dans le cas d'une telle colonne la premiÃ¨re page dans la colonne sera <code>DictionaryPage</code>, et les suivantes seront <code>DataPage</code>.
    </p>
    <p>
        La diffÃ©rence est que dans <code>DataPage</code> au lieu de la valeur complÃ¨te, il y aura des positions dans le dictionnaire, que nous garderons en mÃ©moire pour reconstruire les lignes.<br/>
    </p>
    <div class="important">
        <p>
            <strong>Important :</strong> Chaque <code>ColumnChunk</code> peut contenir seulement une page <code>DictionaryPage</code>.
        </p>
    </div>
    <p>
        Cela peut donner d'Ã©normes Ã©conomies, au lieu de disons Ã©crire de maniÃ¨re binaire le mot <code>Pologne</code> 10 mille fois, c'est-Ã -dire 70k octets,
        nous Ã©crirons seulement la position dans l'index (c'est-Ã -dire 4 octets), qui en plus seront empaquetÃ©s en utilisant l'algorithme <a href="https://parquet.apache.org/docs/file-format/data-pages/encodings/#RLE" target="_blank">Run Length Encoding / Bit-Packing Hybrid</a>.
        Qui, se basant aussi sur la rÃ©pÃ©tabilitÃ© des valeurs consÃ©cutives rÃ©duira la quantitÃ© totale d'octets nÃ©cessaires.
    </p>

    <h3><code>IndexPage</code></h3>
    <p>
        Le dernier type de page est <code>IndexPage</code>.<br/>
        Cette page ne contient pas de donnÃ©es, donc elle n'est pas nÃ©cessaire pour la lecture ni l'Ã©criture.<br/>
        Chaque <code>ColumnChunk</code> peut contenir seulement une page de type <code>IndexPage</code> et elle se trouve toujours Ã  la fin, aprÃ¨s <code>DictionaryPage</code> et toutes les <code>DataPage</code>.
    </p>
    <p>
        Le but de cette page est de stocker des statistiques concernant <code>ColumnChunk</code>, comme les valeurs <code>Min/Max</code>, quantitÃ© de <code>nulls</code> ou maniÃ¨re de tri pour chaque page dans un <code>ColumnChunk</code> spÃ©cifique.
        Cela permet un filtrage rapide et de trouver seulement des pages spÃ©cifiques dans le cadre d'un <code>ColumnChunk</code> donnÃ©, ce qui accÃ©lÃ¨re significativement la recherche dans le fichier, si des informations spÃ©cifiques nous intÃ©ressent.
    </p>
    <div class="notice">
        <p>
            <strong>Attention :</strong> Chaque <code>ColumnChunk</code> dans ses mÃ©tadonnÃ©es contient des statistiques similaires Ã  <code>IndexPage</code>, mais pas pour chaque page mais pour tout le <code>ColumnChunk</code>.<br/>
            GrÃ¢ce Ã  cela, en premier lieu nous pouvons sauter des colonnes complÃ¨tes qui ne nous intÃ©ressent pas et ensuite mÃªme des pages spÃ©cifiques, rÃ©duisant au minimum absolu la quantitÃ© de donnÃ©es que nous devons lire.
        </p>
    </div>

    <p>
        ConsidÃ©rant que cette information se trouve dans les mÃ©tadonnÃ©es du fichier, mÃªme les plus gros fichiers Parquet peuvent Ãªtre lus et filtrÃ©s instantanÃ©ment mÃªme s'ils ne sont disponibles qu'Ã  travers le rÃ©seau.<br/>
        Il suffit que nous rÃ©ussissions Ã  lire les mÃ©tadonnÃ©es, sur leur base localiser un groupe spÃ©cifique de lignes, puis une colonne sÃ©lectionnÃ©e et Ã  la fin des pages spÃ©cifiques. <br/>
        Nous obtiendrons de cette maniÃ¨re une localisation trÃ¨s prÃ©cise de nos donnÃ©es, que nous pourrons lire en utilisant l'en-tÃªte <code>Http Range Header</code>.
    </p>
    <p>
        C'est prÃ©cisÃ©ment une des raisons pour lesquelles Parquet est si puissant, nous ne parlons plus de tÃ©lÃ©chargement brutal et d'itÃ©ration sur un fichier de gigaoctets. Parquet permet avec la prÃ©cision d'un chirurgien
        de tÃ©lÃ©charger et lire seulement les zones du fichier qui nous intÃ©ressent vraiment.
    </p>

    <a href="#dremel"><h2 id="dremel">Dremel</h2></a>

    <p>
        En discutant de la structure de <code>DataPage</code> j'ai mentionnÃ© <code>Definition Levels</code> et <code>Repetition Levels</code>.
    </p>
    <p>
        L'exemple discutÃ© Ã©tait trÃ¨s simple, parce qu'il concernait une colonne simple (int32), donc <code>Repetition Levels</code> n'ont pas d'application du tout.<br/>
        La situation change diamÃ©tralement quand nous avons affaire Ã  une colonne imbriquÃ©e, ex. structure, liste ou carte.
        Regardons un exemple.
    </p>
    <p>
        <code>[{"sku":"abc", "quantity": 1, "price": 100}, {"sku":"def", "quantity": 2, "price": 200}]</code>
    </p>
    <p>
        En revenant Ã  la partie antÃ©rieure de cet article, spÃ©cifiquement aux <a href="#nested-types">types imbriquÃ©s</a>.<br/>
        Nous savons que nos donnÃ©es aprÃ¨s aplatissement ressembleront Ã  ceci :
    </p>
    <ul>
        <li><code>items.list.element.sku</code> - <code>"abc","def"</code></li>
        <li><code>items.list.element.quantity</code> - <code>1,2</code></li>
        <li><code>items.list.element.price</code> - <code>100,200</code></li>
    </ul>
    <p>
        Nous avons ici 3 colonnes, chacune d'elles se trouvera dans un <code>Column Chunk</code> sÃ©parÃ© et chacune contiendra
        une ou plusieurs pages.
    </p>
    <p>
        Alors comment sur la base de ces deux valeurs (<code>Repetition / Definition Levels)</code> les bibliothÃ¨ques lisant les fichiers savent-elles Ã  quelle profondeur dans la structure se trouvent les valeurs et Ã  quel Ã©lÃ©ment elles appartiennent ?<br/>
        Que se passerait-il si notre structure ressemblait Ã  ceci :
    </p>
    <p>
        <code>[{"sku":"abc", "quantity": 1, "price": 100}, {"sku":null, "quantity": 10, "price": 100}, {"sku":"def", "quantity": 2, "price": 200}]</code>
        (dans le deuxiÃ¨me Ã©lÃ©ment sku a la valeur null). <br/>
    </p>
    <p>Que se passe-t-il quand la structure est beaucoup plus imbriquÃ©e, comment savons-nous quelle valeur va Ã  quel niveau d'imbrication ?</p>
    <p>
        La rÃ©ponse Ã  cette et beaucoup d'autres questions nous la trouverons dans le document publiÃ© par Google <a href="https://static.googleusercontent.com/media/research.google.com/pl//pubs/archive/36632.pdf" target="_blank">Dremel: Interactive Analysis of Web-Scale Datasets</a>
        qui dÃ©crit comment Google stocke et recherche les structures de donnÃ©es imbriquÃ©es.
    </p>
    <p>
        L'outil utilisÃ© par Google s'appelle Dremel et c'est un systÃ¨me distribuÃ© de recherche de gros ensembles de donnÃ©es. <br/>
        Il se base sur 2 algorithmes, <code>Shredding</code> et <code>Assembling</code>, qui sont dÃ©crits trÃ¨s briÃ¨vement dans le document ci-dessus.
    </p>
    <div class="notice">
        <p>
            <strong>Attention :</strong> DÃ©crire le fonctionnement exact de ces algorithmes dÃ©passe le cadre de cet article dÃ©jÃ  long.<br/>
            Si de l'intÃ©rÃªt apparaÃ®t pour le sujet, j'essaierai d'aborder aussi ce fil dans les prochains articles.
        </p>
    </div>
    <p>
        Ces algorithmes se basent sur ces 3 dÃ©finitions :
    </p>
    <ul>
        <li>Repetition Levels</li>
        <li>Definition Levels</li>
        <li>Values</li>
    </ul>
    <p>
        Comme nous l'avons dÃ©jÃ  mentionnÃ© <code>Definition Level</code> dÃ©termine si une ligne donnÃ©e contient une valeur, ou pas, <code>Repetition Level</code> qui dans le cas de colonnes plates est toujours 0.
        Pour les structures il dÃ©terminera si la valeur (ou null) doit Ãªtre rÃ©pÃ©tÃ©e, et Ã  quel niveau de profondeur.
    </p>
    <div class="notice">
        <p>
            <strong>Attention :</strong> La connaissance de comment fonctionnent exactement les algorithmes de Dremel, n'est pas nÃ©cessaire pour l'utilisation optimale de Parquet.<br/>
            Pour cette raison, je ne vais pas m'Ã©tendre sur ce sujet, cependant si de l'intÃ©rÃªt apparaÃ®t pour le sujet, j'essaierai d'aborder aussi ce fil dans les prochains articles.
        </p>
    </div>
    <p>
         Ci-dessous je prÃ©senterai seulement Ã  peu prÃ¨s comment ressembleront les donnÃ©es aplaties.
    </p>
    <pre>
        <code class="code-shell" data-controller="syntax-highlight">Input:
[
    &#039;items&#039; =&gt; [
        [&#039;sku&#039; =&gt; &#039;abc&#039;, ...],
        [&#039;sku&#039; =&gt; &#039;def&#039;, ...],
    ]
]

Output:
{
  [&quot;sku&quot;] =&gt;
  {
    [&quot;repetition_levels&quot;] =&gt; { [0] =&gt; int(0) [1] =&gt; int(1) }
    [&quot;definition_levels&quot;] =&gt; { [0] =&gt; int(1) [1] =&gt; int(1) }
    [&quot;values&quot;] =&gt; { [0] =&gt; string(3) &quot;abc&quot; [1] =&gt; string(3) &quot;def&quot; }
  }
}</code>
    </pre>
    <p>
        C'est-Ã -dire qu'en rÃ©alitÃ© nous Ã©crivons <code>0, 1, 0, 1, "abc", "def"</code> et non seulement <code>"abc", "def"</code>. <br/>
        Ce sont prÃ©cisÃ©ment ces nombres additionnels qui disent comment reconstruire n'importe quelle structure imbriquÃ©e.
    </p>
    <p>
        C'est curieux que mÃªme les repetition levels et definition levels pour l'optimisation sont empaquetÃ©s appropriÃ©ment en utilisant l'algorithme
        <a href="https://parquet.apache.org/docs/file-format/data-pages/encodings/#RLE" target="_blank">Run Length Encoding / Bit-Packing Hybrid</a>.
    </p>
    <p>
        Ã‡a ne s'arrÃªte pas lÃ , parce que non seulement les niveaux sont empaquetÃ©s, mais aussi les valeurs elles-mÃªmes.<br/>
        Selon le type de colonne, les valeurs peuvent Ãªtre empaquetÃ©es de diffÃ©rentes maniÃ¨res, la liste de tous les algorithmes d'empaquetage supportÃ©s par Parquet (au moins en thÃ©orie) nous la trouverons
        <a href="https://parquet.apache.org/docs/file-format/data-pages/encodings" target="_blank">dans la documentation officielle</a>.
    </p>
    <p>
        Tandis que l'information sur quel algorithme a Ã©tÃ© utilisÃ© pour empaqueter les donnÃ©es avant l'Ã©criture nous la trouverons dans les mÃ©tadonnÃ©es, sous ce chemin <code>RowGroups[x].ColumnChunk[y].PageHeader[z].data_page_header.encoding</code>
    </p>
    <p>
        Mais ce n'est pas le dernier mot de Parquet dans le contexte d'optimisation !
    </p>
    <a href="#compression"><h2 id="compression">Compression</h2></a>
    <p>
        AprÃ¨s empaquetage et Ã©criture sous forme binaire de nos donnÃ©es pour une page spÃ©cifique, chaque page est additionnellement compressÃ©e.
    </p>
    <p>
        Selon l'implÃ©mentation Parquet permet l'utilisation de diffÃ©rents algorithmes de compression :
    </p>
    <ul>
        <li>UNCOMPRESSED</li>
        <li>SNAPPY</li>
        <li>GZIP</li>
        <li>LZO</li>
        <li>BROTLI</li>
        <li>LZ4</li>
        <li>ZSTD</li>
        <li>LZ4_RAW</li>
    </ul>
    <p>
        Une option trÃ¨s populaire est <a href="https://github.com/google/snappy" target="_blank">Snappy</a>, qui offre un trÃ¨s bon compromis entre vitesse et degrÃ© de compression.
    </p>
    <p>
        Des outils comme <a href="https://spark.apache.org/" target="_blank">Apache Spark</a> l'utilisent mÃªme par dÃ©faut.
    </p>
    <a href="#encryption"><h2 id="encryption">Chiffrement</h2></a>
    <p>
        Une des derniÃ¨res caractÃ©ristiques intÃ©ressantes que je veux discuter, c'est le chiffrement !
    </p>
    <p>
        Oui, Parquet permet de chiffrer les donnÃ©es, chiffrer Ã  plusieurs niveaux.
    </p>
    <ul>
        <li>MÃ©tadonnÃ©es - les mÃ©tadonnÃ©es chiffrÃ©es rendent effectivement difficile la lecture du contenu du fichier, mais ce n'est pas impossible</li>
        <li>DonnÃ©es - les donnÃ©es chiffrÃ©es rendent pratiquement impossible la lecture</li>
        <li>Colonnes - particuliÃ¨rement utile si seulement certaines colonnes contiennent des donnÃ©es sensibles.</li>
        <li>Pages</li>
    </ul>
    <div class="notice">
        <p>
            <strong>Attention :</strong> Le chiffrement est une de ces caractÃ©ristiques que je n'ai pas encore couvertes dans <a href="https://flow-php.com/documentation/components/libs/parquet/">l'implÃ©mentation pour PHP</a><br/>
            Pour cette raison je ne vais pas m'Ã©tendre sur ce sujet, dÃ¨s que j'aurai l'occasion d'implÃ©menter cette fonctionnalitÃ©, j'essaierai de complÃ©ter l'article.
        </p>
    </div>
    <p>
        Le chiffrement dans Parquet se base sur <a href="https://parquet.apache.org/docs/file-format/data-pages/encryption/" target="_blank">Parquet Modular Encryption</a> et utilise
        <a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf" target="_blank">AES</a> pour chiffrer les donnÃ©es.
    </p>
    <p>
        Le chiffrement, surtout de colonnes sÃ©lectionnÃ©es, Ã©lÃ¨ve Parquet Ã  un niveau supÃ©rieur de stockage de donnÃ©es. <br/> GrÃ¢ce Ã  cela de maniÃ¨re relativement facile, avec peu de surcharge,
        nous pouvons protÃ©ger en plus les donnÃ©es que nous stockons dans les fichiers Parquet. <br/>
    </p>
    <p>
        Imaginons que Parquet est utilisÃ© pour stocker des donnÃ©es de clients, oÃ¹ la colonne <code>email</code> et <code>phone</code> contiennent des donnÃ©es sensibles.<br/>
        Dans cette situation, il est demandÃ© que ces deux colonnes soient protÃ©gÃ©es en plus. MÃªme si quelqu'un rÃ©ussit Ã  obtenir un accÃ¨s physique au fichier, sans la clÃ© il ne
        pourra toujours pas lire les donnÃ©es.
    </p>
    <a href="#summary"><h2 id="summary">RÃ©sumÃ©</h2></a>
    <p>
        C'est prÃ©cisÃ©ment le secret de Parquet et la faÃ§on d'atteindre l'efficacitÃ©. Au lieu de stocker des donnÃ©es arbitraires sous forme textuelle, Parquet va plusieurs Ã©tapes plus loin. <br/>
        En premier lieu il force un schÃ©ma de donnÃ©es basÃ© sur des types simples mais incroyablement flexibles, dont chacun peut Ãªtre
        reprÃ©sentÃ© sous forme binaire.<br/>
        Ensuite la forme binaire est appropriÃ©ment empaquetÃ©e, pour Ã©viter les rÃ©pÃ©titions inutiles d'octets, ce qui Ã  la fin est
        additionnellement compressÃ© Ã  l'aide d'algorithmes trÃ¨s efficaces.<br/>
        La cerise sur le gÃ¢teau sont les mÃ©tadonnÃ©es avancÃ©es et dÃ©taillÃ©es, disponibles Ã  plusieurs niveaux, permettant de filtrer
        les partitions inutiles, ou mÃªme des fichiers entiers sans lire leur contenu.
    </p>
    <p>
        De plus grÃ¢ce Ã  la division logique appropriÃ©e, sur laquelle nous avons un contrÃ´le complet (taille des groupes et pages) nous pouvons
        dÃ©cider ce qui est plus important pour nous, vitesse ou Ã©conomie de mÃ©moire. Recherche ou lecture de donnÃ©es ou peut-Ãªtre
        sÃ©curitÃ©, pour laquelle nous utiliserons un chiffrement additionnel.
    </p>
    <p>
        Parquet est vraiment un outil puissant qui dans les bonnes mains permet un stockage et une recherche efficaces
        d'Ã©normes quantitÃ©s de donnÃ©es.<br/>
    </p>
    <p>
        Si cet article t'a inspirÃ© Ã  expÃ©rimenter avec ce format de donnÃ©es rÃ©volutionnaire, fais-le savoir dans les commentaires !
    </p>
    <a href="#help"><h2 id="help">Aide</h2></a>
    <p>
        Si tu as besoin d'aide dans la construction d'un entrepÃ´t central de donnÃ©es, je serai ravi de t'aider.<br/>
        <a href="https://norbert.tech/consulting">Contacte-moi</a>, et ensemble nous crÃ©erons une solution qui sera parfaitement adaptÃ©e Ã  tes besoins.
    </p>
    <p>
        Je t'encourage aussi Ã  visiter le serveur <a href="https://discord.gg/5dNXfQyACW" target="_blank">Discord - Flow PHP</a>, oÃ¹
        nous pouvons parler directement.
    </p>
    <div class="img-wide">
        <img src="https://norbert.tech/assets/images/blog/analytics-in-transactional-distributed-systems/consulting_01-fa277dfb3736a033cbfcf1ac931afb08.jpg" alt="Conseil" />
    </div>

    </article>
    <div class="mb-2 mx-auto max-w-screen-lg text-center">
        <script src="https://giscus.app/client.js"
                data-repo="norberttech/norbert.tech"
                data-repo-id="MDEwOlJlcG9zaXRvcnkyMjQ0MDQwNDA="
                data-category="Comments"
                data-category-id="DIC_kwDODWAiSM4CionD"
                data-mapping="pathname"
                data-strict="0"
                data-reactions-enabled="0"
                data-emit-metadata="0"
                data-input-position="bottom"
                data-theme="light"
                data-lang="en"
                crossorigin="anonymous"
                async>
        </script>
    </div>
    </main>

    <footer class="p-4 bg-sky-50 absolute bottom-0 w-full">
        <div class="mx-auto max-w-screen-2xl text-center">
            <a href="/">by @norbert_tech</a>
        </div>
    </footer>
</body>
</html>