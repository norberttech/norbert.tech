<!doctype html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Parquet - EinfÃ¼hrung</title>
    <meta property="og:title" content="Parquet - EinfÃ¼hrung" />
    <meta name="twitter:title" content="Parquet - EinfÃ¼hrung" >

    <meta name="description" content="VollstÃ¤ndiger Leitfaden zu Apache Parquet - dem binÃ¤ren, spaltenorientierten Dateiformat. Erfahren Sie, wie Sie 10x kleinere Dateien erreichen, Metadaten fÃ¼r blitzschnelle Filterung nutzen, die Struktur von Row Groups und Data Pages verstehen und erweiterte Funktionen wie VerschlÃ¼sselung und Dremel-Algorithmen kennenlernen.">
    <meta property="og:description" content="VollstÃ¤ndiger Leitfaden zu Apache Parquet - dem binÃ¤ren, spaltenorientierten Dateiformat. Erfahren Sie, wie Sie 10x kleinere Dateien erreichen, Metadaten fÃ¼r blitzschnelle Filterung nutzen, die Struktur von Row Groups und Data Pages verstehen und erweiterte Funktionen wie VerschlÃ¼sselung und Dremel-Algorithmen kennenlernen.">
    <meta name="twitter:description" content="VollstÃ¤ndiger Leitfaden zu Apache Parquet - dem binÃ¤ren, spaltenorientierten Dateiformat. Erfahren Sie, wie Sie 10x kleinere Dateien erreichen, Metadaten fÃ¼r blitzschnelle Filterung nutzen, die Struktur von Row Groups und Data Pages verstehen und erweiterte Funktionen wie VerschlÃ¼sselung und Dremel-Algorithmen kennenlernen.">

    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://norbert.tech/blog/2025-09-20/de/parquet-einfuehrung" />
                <meta property="og:image" content="https://norbert.tech/assets/images/blog/parquet-introduction/parquet-026fc09c95c7c7b4728c30bb85593777.jpg" />
                    
    <meta name="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://norbert.tech/blog/2025-09-20/de/parquet-einfuehrung" />
    <meta name="twitter:image" content="https://norbert.tech/assets/images/avatar-8f3c52c37f20d07c5e1631e1512bdeca.jpeg">
    <meta name="twitter:site" content="@norbert_tech" />
    <meta name="twitter:creator" content="@norbert_tech" />

    <link rel="apple-touch-icon" sizes="180x180" href="https://norbert.tech/assets/images/favicons/apple-touch-icon-9cae7ee880b4fe0bd755d300e1bca71e.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://norbert.tech/assets/images/favicons/favicon-32x32-b7a4ad4b584ab95534144e071f0e8587.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://norbert.tech/assets/images/favicons/favicon-16x16-154ca21abc06ae116c8d7ffc5713c000.png">
    <link rel="shortcut icon" href="https://norbert.tech/assets/images/favicons/favicon-db409885df78dea389e6d0b036da382c.ico">

            <style>
            @import url('https://fonts.googleapis.com/css2?family=Cabin:ital,wght@0,400..700;1,400..700&display=swap');
        </style>
        <link rel="stylesheet" href="https://norbert.tech/assets/styles/app-ff31265a811feebd3b3b45d8dc315d8b.css">
    
            
<script type="importmap">
{
    "imports": {
        "app": "https://norbert.tech/assets/app-930adf3462cf9ab60908eb1b74cf7ca7.js",
        "@oddbird/popover-polyfill": "https://norbert.tech/assets/vendor/@oddbird/popover-polyfill/popover-polyfill.index-7979d53637476aa204f709644aed2c19.js",
        "https://norbert.tech/assets/bootstrap.js": "https://norbert.tech/assets/bootstrap-d78d7e12c819dedf89372fb4824c072d.js",
        "htmx.org": "https://norbert.tech/assets/vendor/htmx.org/htmx.org.index-023ae86a082913526422a6063298f898.js",
        "iconify-icon": "https://norbert.tech/assets/vendor/iconify-icon/iconify-icon.index-8a41e423576dc2d752509fd455f508c1.js",
        "@symfony/stimulus-bundle": "https://norbert.tech/assets/@symfony/stimulus-bundle/loader-5751ad1ee2975e725a94d8121d153d17.js",
        "@hotwired/stimulus": "https://norbert.tech/assets/vendor/@hotwired/stimulus/stimulus.index-304681764684182e6662e0931532ed91.js",
        "https://norbert.tech/assets/@symfony/stimulus-bundle/controllers.js": "https://norbert.tech/assets/@symfony/stimulus-bundle/controllers-11c35dc7f11bbd855b8108888f18f9b7.js",
        "https://norbert.tech/assets/controllers/hello_controller.js": "https://norbert.tech/assets/controllers/hello_controller-55882fcad241d2bea50276ea485583bc.js",
        "https://norbert.tech/assets/controllers/syntax_highlight_controller.js": "https://norbert.tech/assets/controllers/syntax_highlight_controller-ae10e4cee8b4dedbf232536d05654062.js",
        "https://norbert.tech/assets/controllers/clipboard_controller.js": "https://norbert.tech/assets/controllers/clipboard_controller-6aefa8a9dec3271dae2f05b464bf9204.js",
        "highlight.js/lib/core": "https://norbert.tech/assets/vendor/highlight.js/lib/core-760145ef158caabe84ca07686407d093.js",
        "highlight.js/lib/languages/php": "https://norbert.tech/assets/vendor/highlight.js/lib/languages/php-c0eb2105c14097e8a5a1e9a767e8ac95.js",
        "highlight.js/styles/github-dark.min.css": "data:application/javascript,document.head.appendChild%28Object.assign%28document.createElement%28%22link%22%29%2C%7Brel%3A%22stylesheet%22%2Chref%3A%22https%3A%2F%2Fnorbert.tech%2Fassets%2Fvendor%2Fhighlight.js%2Fstyles%2Fgithub-dark.min-4b46e20f66f76e35d6454ca4f09b57c3.css%22%7D%29%29",
        "@fontsource-variable/cabin/index.min.css": "data:application/javascript,document.head.appendChild%28Object.assign%28document.createElement%28%22link%22%29%2C%7Brel%3A%22stylesheet%22%2Chref%3A%22https%3A%2F%2Fnorbert.tech%2Fassets%2Fvendor%2F%40fontsource-variable%2Fcabin%2Findex.min-08e34691d22388e6974e6cb2bfbcbfd0.css%22%7D%29%29",
        "clipboard": "https://norbert.tech/assets/vendor/clipboard/clipboard.index-925566f98181665b5a61fea1bcd9033d.js",
        "highlight.js/lib/languages/shell": "https://norbert.tech/assets/vendor/highlight.js/lib/languages/shell-664215791af27581e04813723523a355.js",
        "highlight.js/lib/languages/json": "https://norbert.tech/assets/vendor/highlight.js/lib/languages/json-9ac51ad2a97f9ce56b2f309eb64d7b04.js",
        "highlight.js/lib/languages/twig": "https://norbert.tech/assets/vendor/highlight.js/lib/languages/twig-0f3c6d18c0368650898b432b7bcf672a.js",
        "highlight.js/lib/languages/sql": "https://norbert.tech/assets/vendor/highlight.js/lib/languages/sql-09f80640dd6fe9bed6ff4eb255b13f08.js",
        "highlight.js/lib/languages/javascript": "https://norbert.tech/assets/vendor/highlight.js/lib/languages/javascript-100f963be02a503f0531e497103ff398.js",
        "highlight.js/lib/languages/xml": "https://norbert.tech/assets/vendor/highlight.js/lib/languages/xml-a2295112e12d4d01f257d59e1cfa676d.js"
    }
}
</script>
<!-- ES Module Shims: Import maps polyfill for modules browsers without import maps support -->
<script async src="https://ga.jspm.io/npm:es-module-shims@1.10.0/dist/es-module-shims.js"></script>
<link rel="modulepreload" href="https://norbert.tech/assets/app-930adf3462cf9ab60908eb1b74cf7ca7.js">
<link rel="modulepreload" href="https://norbert.tech/assets/vendor/@oddbird/popover-polyfill/popover-polyfill.index-7979d53637476aa204f709644aed2c19.js">
<link rel="modulepreload" href="https://norbert.tech/assets/bootstrap-d78d7e12c819dedf89372fb4824c072d.js">
<link rel="modulepreload" href="https://norbert.tech/assets/vendor/htmx.org/htmx.org.index-023ae86a082913526422a6063298f898.js">
<link rel="modulepreload" href="https://norbert.tech/assets/vendor/iconify-icon/iconify-icon.index-8a41e423576dc2d752509fd455f508c1.js">
<link rel="modulepreload" href="https://norbert.tech/assets/@symfony/stimulus-bundle/loader-5751ad1ee2975e725a94d8121d153d17.js">
<link rel="modulepreload" href="https://norbert.tech/assets/vendor/@hotwired/stimulus/stimulus.index-304681764684182e6662e0931532ed91.js">
<link rel="modulepreload" href="https://norbert.tech/assets/@symfony/stimulus-bundle/controllers-11c35dc7f11bbd855b8108888f18f9b7.js">
<link rel="modulepreload" href="https://norbert.tech/assets/controllers/hello_controller-55882fcad241d2bea50276ea485583bc.js">
<script type="module">import 'app';</script>
                <script defer src="https://cloud.umami.is/script.js" data-website-id="9fed007d-d990-428b-b5d9-11c6ff55a3f1"></script>
    </head>
<body class="scroll-smooth text-black relative min-h-screen pb-16">
    <div class="sticky top-0 max-h-screen overflow-y-auto bg-white py-2 px-2 border-b border-gray-500 z-[9999] print:hidden">
        <div class="grid grid-cols-2 sm:mx-auto sm:max-w-screen-2xl md:px-4">
            <div class="text-left">
                <a href="/" class="text-lg">
                    norbert.tech
                </a>
            </div>
            <div class="text-right">
                <a href="/consulting" class="text-lg inline-flex items-center space-x-1 md:mr-4 mr-2">
                    <iconify-icon icon="lineicons:consulting" class="mr-1"></iconify-icon> Consulting
                </a>
                <a href="/blog" class="text-lg inline-flex items-center space-x-1">
                    <iconify-icon icon="ooui:articles-ltr" class="mr-1"></iconify-icon> Blog
                </a>
            </div>
        </div>
    </div>
    
    <main class="mx-auto max-w-screen-2xl mb-4 md:pt-4 px-4 lg:px-0">
            <div class="px-2 py-5 sm:px-4 md:px-8 lg:px-12 mx-auto max-w-4xl">
        <ul class="mt-2 pl-[20px] flex flex-wrap gap-2 sm:gap-4">
            <li>
                <a href="/blog" class="text-sm sm:text-base text-blue-500 hover:underline px-2 py-1 rounded">Go Back</a>
            </li>
                                                                <li>
                        <a href="/blog/2025-09-20/pl/parquet-wprowadzenie"
                           class="text-sm sm:text-lg px-2 py-1 rounded hover:opacity-80"
                           title="Polish">ğŸ‡µğŸ‡± Polish</a>
                    </li>
                                                                                <li>
                        <a href="/blog/2025-09-20/es/parquet-introduccion"
                           class="text-sm sm:text-lg px-2 py-1 rounded hover:opacity-80"
                           title="Spanish">ğŸ‡ªğŸ‡¸ Spanish</a>
                    </li>
                                                                                <li>
                        <a href="/blog/2025-09-20/parquet-introduction"
                           class="text-sm sm:text-lg px-2 py-1 rounded hover:opacity-80"
                           title="English">ğŸ‡ºğŸ‡¸ English</a>
                    </li>
                                                                                <li>
                        <a href="/blog/2025-09-20/it/parquet-introduzione"
                           class="text-sm sm:text-lg px-2 py-1 rounded hover:opacity-80"
                           title="Italian">ğŸ‡®ğŸ‡¹ Italian</a>
                    </li>
                                                                                <li>
                        <a href="/blog/2025-09-20/fr/parquet-introduction-fr"
                           class="text-sm sm:text-lg px-2 py-1 rounded hover:opacity-80"
                           title="French">ğŸ‡«ğŸ‡· French</a>
                    </li>
                                    </ul>

                    <div class="mt-4 p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
                <div class="flex items-start">
                    <div class="flex-shrink-0">
                        <svg class="h-5 w-5 text-yellow-400" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"/>
                        </svg>
                    </div>
                    <div class="ml-3">
                        <h3 class="font-medium text-yellow-800">
                            Translation Notice
                        </h3>
                        <div class="mt-2 text-yellow-700">
                            <p>
                                This is an automatically translated version of that Article. Despite my best efforts, it might not be perfect.<br/>
                                Native speakers are welcome to
                                <a href="https://github.com/norberttech/norbert.tech/edit/main/templates/blog/posts/2025-09-20/parquet-einfuehrung/post.html.twig"
                                   class="underline hover:text-yellow-800" target="_blank" rel="noopener">open pull requests
                                </a> to correct anything that doesn't sound right.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
            </div>
    <article class="blog-post">
            <div class="img-wide">
        <img src="https://norbert.tech/assets/images/blog/parquet-introduction/parquet-026fc09c95c7c7b4728c30bb85593777.jpg" alt="Parquet - EinfÃ¼hrung" />
    </div>

    <h1 class="font-bold text-4xl mb-2" id="title">Parquet - EinfÃ¼hrung</h1>
    <div class="mb-2">
        <small class="text-sm">VerÃ¶ffentlichungsdatum September 20, 2025 00:00</small>
    </div>
    <div class="mb-4">
                    <small><span class="badge badge-info">Parquet</span></small>
                    <small><span class="badge badge-info">binÃ¤r</span></small>
                    <small><span class="badge badge-info">spaltenorientiert</span></small>
                    <small><span class="badge badge-info">Dateiformat</span></small>
                    <small><span class="badge badge-info">Datenkompression</span></small>
                    <small><span class="badge badge-info">Metadaten</span></small>
                    <small><span class="badge badge-info">VerschlÃ¼sselung</span></small>
                    <small><span class="badge badge-info">Apache Thrift</span></small>
                    <small><span class="badge badge-info">Flow PHP</span></small>
            </div>
    <p>
        Parquet, ein binÃ¤res, spaltenorientiertes Dateiformat, das fÃ¼r die effiziente Speicherung und Abfrage von Daten entwickelt wurde.
    </p>
    <p>
        Es gibt unzÃ¤hlige Artikel Ã¼ber Parquet im Netz, warum also noch einer?<br/>
        Das ist meine Sicht auf dieses fantastische Format, die im Wesentlichen aus meinen Erfahrungen bei der Arbeit an
        einer Parquet-Implementierung in reinem PHP resultiert.
    </p>
    <p>
        FÃ¼r diejenigen, die hier zufÃ¤llig gelandet sind, mÃ¶chte ich erwÃ¤hnen, dass ich der Autor des ersten Frameworks fÃ¼r Datenverarbeitung
        in PHP namens <a href="https://flow-php.com" target="_blank">Flow PHP</a> bin.<br/>
        Wie es sich fÃ¼r ein Data Frame gehÃ¶rt, muss Flow Daten in verschiedenen Formaten lesen und schreiben kÃ¶nnen, einschlieÃŸlich Parquet<br/>
    </p>
    <p>
        Da die einzige Implementierung, die ich fand, im Grunde ein direkter Port aus C# war, der auÃŸerdem
        nicht so gut mit tief verschachtelten Strukturen umgehen konnte und viele fehlende Funktionen hatte, entschied ich mich,
        zu Lernzwecken eine eigene Implementierung von Grund auf zu schreiben, was sich als Ã¤uÃŸerst wertvolle Erfahrung herausstellte, aber auch groÃŸen SpaÃŸ machte.
    </p>
    <a href="#why-parquet"><h2 id="why-parquet">Warum Parquet</h2></a>
    <ul>
        <li><a href="#binary-format">BinÃ¤res Format - bis zu 10x kleinere Dateien</a></li>
        <li><a href="#metadata">Metadaten - einfacherer Zugriff auf ausgewÃ¤hlte Daten</a></li>
        <li><a href="#schema">Schema - Garantie fÃ¼r korrekte Struktur</a></li>
        <li><a href="#compression">Kompression - zusÃ¤tzliche GrÃ¶ÃŸenreduktion</a></li>
        <li><a href="#encryption">VerschlÃ¼sselung - auf Datei-, Metadaten-, Spalten- oder Seitenebene</a></li>
    </ul>

    <a href="#binary-format"><h2 id="binary-format">BinÃ¤res Format</h2></a>
    <p>
        Da dieses Format spalten- und nicht zeilenorientiert ist, ermÃ¶glicht es eine sehr effiziente Datenkompression,
        was sich in einer deutlich kleineren DateigrÃ¶ÃŸe niederschlÃ¤gt. Ohne groÃŸen Aufwand kann Parquet Daten sogar um das <strong>10-fache</strong> komprimieren,
        verglichen mit traditionellen Formaten wie CSV oder XML.
    </p>
    <p>
        Wenn also dieselben Daten im CSV-Format 1GB belegen, kÃ¶nnen sie im Parquet-Format nur 100MB benÃ¶tigen.<br/>
    </p>

    <p>
        FÃ¼r diesen Beitrag habe ich 2 Dateien generiert, eine im CSV-Format, die andere im Parquet-Format.<br/>
        Die Struktur dieser Dateien ist sehr einfach, sie enthÃ¤lt 10 Spalten und 10 Millionen Zeilen, die etwa so aussehen:
    </p>
    <pre><code class="code-shell" data-controller="syntax-highlight">index,order_id,created_at,updated_at,discount,email,customer,address,notes,items
0,254d61c5-22c8-4407-83a2-76f1cab53af2,2025-01-01T12:00:00+00:00,2025-01-01T12:10:00+00:00,24.4,user-0@example.com,&quot;John Doe 0&quot;,&quot;{&quot;&quot;street&quot;&quot;:&quot;&quot;123 Main St, Apt 0&quot;&quot;,&quot;&quot;city&quot;&quot;:&quot;&quot;City &quot;&quot;,&quot;&quot;zip&quot;&quot;:&quot;&quot;12345-0&quot;&quot;,&quot;&quot;country&quot;&quot;:&quot;&quot;PL&quot;&quot;}&quot;,&quot;[&quot;&quot;Note 1 for order 0&quot;&quot;,&quot;&quot;Note 2 for order 0&quot;&quot;,&quot;&quot;Note 3 for order 0&quot;&quot;]&quot;,&quot;[{&quot;&quot;sku&quot;&quot;:&quot;&quot;SKU_0001&quot;&quot;,&quot;&quot;quantity&quot;&quot;:1,&quot;&quot;price&quot;&quot;:0.14},{&quot;&quot;sku&quot;&quot;:&quot;&quot;SKU_0002&quot;&quot;,&quot;&quot;quantity&quot;&quot;:2,&quot;&quot;price&quot;&quot;:25.13}]&quot;
1,254d61c5-22c8-4407-83a2-76f1cab53af2,2025-01-01T12:00:00+00:00,2025-01-01T12:10:00+00:00,24.4,user-1@example.com,&quot;John Doe 1&quot;,&quot;{&quot;&quot;street&quot;&quot;:&quot;&quot;123 Main St, Apt 1&quot;&quot;,&quot;&quot;city&quot;&quot;:&quot;&quot;City &quot;&quot;,&quot;&quot;zip&quot;&quot;:&quot;&quot;12345-1&quot;&quot;,&quot;&quot;country&quot;&quot;:&quot;&quot;PL&quot;&quot;}&quot;,&quot;[&quot;&quot;Note 1 for order 1&quot;&quot;,&quot;&quot;Note 2 for order 1&quot;&quot;,&quot;&quot;Note 3 for order 1&quot;&quot;]&quot;,&quot;[{&quot;&quot;sku&quot;&quot;:&quot;&quot;SKU_0001&quot;&quot;,&quot;&quot;quantity&quot;&quot;:1,&quot;&quot;price&quot;&quot;:0.14},{&quot;&quot;sku&quot;&quot;:&quot;&quot;SKU_0002&quot;&quot;,&quot;&quot;quantity&quot;&quot;:2,&quot;&quot;price&quot;&quot;:25.13}]&quot;
2,254d61c5-22c8-4407-83a2-76f1cab53af2,2025-01-01T12:00:00+00:00,,,user-2@example.com,&quot;John Doe 2&quot;,&quot;{&quot;&quot;street&quot;&quot;:&quot;&quot;123 Main St, Apt 2&quot;&quot;,&quot;&quot;city&quot;&quot;:&quot;&quot;City &quot;&quot;,&quot;&quot;zip&quot;&quot;:&quot;&quot;12345-2&quot;&quot;,&quot;&quot;country&quot;&quot;:&quot;&quot;PL&quot;&quot;}&quot;,&quot;[&quot;&quot;Note 1 for order 2&quot;&quot;,&quot;&quot;Note 2 for order 2&quot;&quot;,&quot;&quot;Note 3 for order 2&quot;&quot;]&quot;,&quot;[{&quot;&quot;sku&quot;&quot;:&quot;&quot;SKU_0001&quot;&quot;,&quot;&quot;quantity&quot;&quot;:1,&quot;&quot;price&quot;&quot;:0.14},{&quot;&quot;sku&quot;&quot;:&quot;&quot;SKU_0002&quot;&quot;,&quot;&quot;quantity&quot;&quot;:2,&quot;&quot;price&quot;&quot;:25.13}]&quot;
3,254d61c5-22c8-4407-83a2-76f1cab53af2,2025-01-01T12:00:00+00:00,,24.4,user-3@example.com,&quot;John Doe 3&quot;,&quot;{&quot;&quot;street&quot;&quot;:&quot;&quot;123 Main St, Apt 3&quot;&quot;,&quot;&quot;city&quot;&quot;:&quot;&quot;City &quot;&quot;,&quot;&quot;zip&quot;&quot;:&quot;&quot;12345-3&quot;&quot;,&quot;&quot;country&quot;&quot;:&quot;&quot;PL&quot;&quot;}&quot;,&quot;[&quot;&quot;Note 1 for order 3&quot;&quot;,&quot;&quot;Note 2 for order 3&quot;&quot;,&quot;&quot;Note 3 for order 3&quot;&quot;]&quot;,&quot;[{&quot;&quot;sku&quot;&quot;:&quot;&quot;SKU_0001&quot;&quot;,&quot;&quot;quantity&quot;&quot;:1,&quot;&quot;price&quot;&quot;:0.14},{&quot;&quot;sku&quot;&quot;:&quot;&quot;SKU_0002&quot;&quot;,&quot;&quot;quantity&quot;&quot;:2,&quot;&quot;price&quot;&quot;:25.13}]&quot;
</code></pre>

    <p>
        Der Kompressionseffekt ist wirklich beeindruckend:
    </p>

    <pre><code class="code-shell" data-controller="syntax-highlight">4.1G Sep 20 18:32 orders.csv
437M Sep 20 18:47 orders.parquet</code></pre>

    <p>
        Das wirkt sich nicht nur auf die Speicherkosten aus, sondern auch auf die Datenverarbeitung.<br/>
        Besonders wenn unsere Daten in der Cloud leben, sei es auf Azure Bucket oder AWS S3. Einer der grÃ¶ÃŸeren Kostenfaktoren
        ist nicht die GrÃ¶ÃŸe der Daten, sondern der Transfer, den wir verbrauchen, um diese Daten zu lesen/schreiben.
    </p>
    <p>
        Indem wir die DateigrÃ¶ÃŸe reduzieren, reduzieren wir nicht nur die Speicherkosten, sondern auch die Verarbeitungskosten.
        Wichtig ist jedoch zu verstehen, dass Verarbeitung eigentlich jede Form des Zugriffs bedeutet, also Schreiben/Lesen.
    </p>
    <p>
        Das lÃ¤uft darauf hinaus, dass durch die Wahl des richtigen Dateiformats die Einsparungen wirklich erheblich sein kÃ¶nnen,
        besonders wenn wir Ã¼ber grÃ¶ÃŸere Datenmengen sprechen.
    </p>
    <p>
        Was bedeutet es Ã¼berhaupt, dass Parquet ein binÃ¤res Format ist?
    </p>
    <p>
        Es bedeutet etwa so viel, dass Daten in binÃ¤rer Form gespeichert werden, also in einer Form, die
        nicht direkt mit gÃ¤ngigen Texteditoren gelesen werden kann.
    </p>
    <p>
        Aber wird nicht letztendlich alles in binÃ¤rer Form gespeichert?
    </p>
    <p>
        Ja, im Allgemeinen sind auch Textdateien BinÃ¤rdateien, der Unterschied liegt darin, dass in Textdateien die Struktur
        der Datei immer gleich ist und jede Information auf die gleiche Weise gespeichert wird.
    </p>
    <p>
        Wenn wir zum Beispiel "12345" in einer Textdatei speichern wollten, wÃ¼rde die binÃ¤re Version so aussehen:
    </p>
    <pre><code class="code-shell" data-controller="syntax-highlight">STRING: &quot;12345&quot;
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Character:   &#039;1&#039;       &#039;2&#039;      &#039;3&#039;      &#039;4&#039;     &#039;5&#039;      &#039;\0&#039;
ASCII:       49        50       51        52     53        0
Binary:    00110001 00110010 00110011 00110100 00110101 00000000
           â””â”€byteâ”€â”˜ â””â”€byteâ”€â”˜ â””â”€byteâ”€â”˜ â””â”€byteâ”€â”˜ â””â”€byteâ”€â”˜ â””â”€byteâ”€â”˜

Total: 6 bytes (including null terminator)</code></pre>
    <p>
        Derselbe String, gespeichert im binÃ¤ren Format als int32 (Integer in 32-Bit-Form), wÃ¼rde so aussehen:
    </p>
    <pre><code class="code-shell" data-controller="syntax-highlight">INTEGER: 12345
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Integer:     0         0       48       57
Binary:  00000000  00000000 00110000 00111001
         â””â”€byteâ”€â”˜  â””â”€byteâ”€â”˜ â””â”€byteâ”€â”˜ â””â”€byteâ”€â”˜

Total: 4 bytes for a 32-bit integer</code></pre>

    <p>
        Beachten Sie, dass bei der binÃ¤ren Speicherung von Integern diese nicht einfach von links nach rechts (oder umgekehrt) gelesen werden kÃ¶nnen.
        Hier mÃ¼ssen wir bereits wissen, wie diese Bits zu interpretieren sind, um zu verstehen, was sie bedeuten.
        Bei Textdateien haben wir dieses Problem nicht, da wir wissen, dass jeder Buchstabe in 8-Bit-Form gespeichert wird.
    </p>
    <p>
        Deshalb ist praktisch jeder Texteditor in der Lage, jede Textdatei zu Ã¶ffnen und uns etwas anzuzeigen, was mehr oder weniger Sinn ergibt.
    </p>
    <p>
        Wenn wir jedoch versuchen, eine Parquet-Datei in einem Texteditor zu Ã¶ffnen, erhalten wir eine Zeichenkette, die sehr zufÃ¤llig aussieht und nicht viel Sinn ergibt.
    </p>

    <a href="#columns-rows"><h2 id="columns-rows">Spaltenorientiert / Zeilenorientiert</h2></a>
    <p>
        Den Unterschied zwischen diesen Formaten erklÃ¤rt man am besten mit einer Visualisierung.
    </p>
    <p>
        Im klassischen zeilenorientierten Modell enthÃ¤lt jede Zeile alle Spalten, wie z.B. im CSV-Format
    </p>

    <pre><code class="code-shell" data-controller="syntax-highlight">+------+------+------+
| Col1 | Col2 | Col3 |
+------+------+------+
|  A1  |  B1  |  C1  |
|  A2  |  B2  |  C2  |
|  A3  |  B3  |  C3  |
+------+------+------+
</code></pre>

    <p>
        Das spaltenorientierte Format ist insofern interessant, als es, anstatt Daten Zeile fÃ¼r Zeile zu speichern, sie Spalte fÃ¼r Spalte speichert.
    </p>

    <pre><code class="code-shell" data-controller="syntax-highlight">+------+------+------+------+
| Col1 |  A1  |  A2  |  A3  |
+------+------+------+------+
| Col2 |  B1  |  B2  |  B3  |
+------+------+------+------+
| Col3 |  C1  |  C2  |  C3  |
+------+------+------+------+
</code></pre>

    <p>
        Die Speicherung von Daten im spaltenorientierten Format bringt viele Vorteile mit sich, wie:
    </p>
    <ul>
        <li>Viel bessere Datenkompression</li>
        <li>MÃ¶glichkeit, nur ausgewÃ¤hlte Spalten zu lesen</li>
        <li>MÃ¶glichkeit, ausgewÃ¤hlte oder alle Spalten zu verschlÃ¼sseln</li>
    </ul>

    <p>
        Im Fall des zeilenorientierten Formats mÃ¼ssen wir, um nur eine Spalte zu lesen, trotzdem die gesamte Datei durchgehen.<br/>
        Im Fall des spaltenorientierten Formats kÃ¶nnen wir nur die Spalten lesen, die uns interessieren.<br/>
        Das ist besonders nÃ¼tzlich bei sehr groÃŸen DatensÃ¤tzen, wo wir oft nur einen Teil der Informationen benÃ¶tigen.
    </p>


    <a href="#immutable"><h2 id="immutable">UnverÃ¤nderlich</h2></a>
    <p>
        Aufgrund der Art, wie Daten im spaltenorientierten Format gespeichert werden, sind Parquet-Dateien unverÃ¤nderlich.<br/>
        Das bedeutet jedoch nicht, dass sie nicht modifiziert werden kÃ¶nnen. Das kÃ¶nnen sie, aber die einzige sinnvolle Operation ist das AnhÃ¤ngen von Daten am Ende.
    </p>
    <p>
        Warum? Parquet speichert Daten im spaltenorientierten Format, das bedeutet, wenn wir eine Spalte <code>email</code> haben,
        werden alle Zeilen (in einer gegebenen Zeilengruppe und Seite - dazu spÃ¤ter mehr) hintereinander als Kette gespeichert. </br>
        Die Modifikation einer Zeile ist daher unmÃ¶glich, da sie praktisch die Verschiebung der gesamten Datei erfordern wÃ¼rde.
    </p>
    <p>
        Es ist jedoch mÃ¶glich, eine neue Zeilengruppe am Ende der Datei hinzuzufÃ¼gen. Dies geschieht so, dass die Metadaten vom Ende der Datei entfernt werden,
        die vorÃ¼bergehend in den Speicher wandern. An ihrer Stelle wird die neue Zeilengruppe geschrieben (die auch zu den Metadaten hinzugefÃ¼gt werden muss),
        und dann werden die Metadaten am Ende wieder geschrieben.
    </p>
    <p>
        Aus diesem Grund mÃ¼ssen wir, wenn wir etwas aus einer Parquet-Datei lÃ¶schen wollen, praktisch die gesamte Datei neu schreiben, wobei wir
        ungewÃ¼nschte Daten weglassen.
    </p>

    <a href="#metadata"><h2 id="metadata">Starke Struktur</h2></a>
    <p>
        Parquet ist ein Format, das auf starker Typisierung basiert. Das bedeutet, dass die Struktur der gesamten Datei definiert und in der FuÃŸzeile gespeichert ist,
        so dass es ausreicht, nur das entsprechende Segment zu lesen, um zu verstehen, welche Daten wir in der Datei haben und in welchen
        Bereichen der Datei diese Daten gespeichert sind.
    </p>
    <p>
        Wir kÃ¶nnen uns das wie eine Karte der Datei vorstellen, eine Karte, die uns sagt, wo in der Datei genau die Daten sind, die
        uns interessieren.
    </p>
    <p>
        So sieht etwa die vereinfachte Struktur einer Datei im Parquet-Format aus:
    </p>
    <pre><code class="code-shell" data-controller="syntax-highlight">+-----------------+
| PAR1            |
+-----------------+
| Data            |
| .............   |
| .............   |
+-----------------+
| File Metadata   |
+-----------------+
| PAR1            |
+-----------------+</code></pre>

    <p>
        Im obigen Beispiel sehen wir 3 Elemente:
    </p>

    <ul>
        <li><code>PAR1</code> - also "Parquet Magic Bytes" - 4 Bytes, die Dateien im Parquet-Format Ã¶ffnen und schlieÃŸen</li>
        <li><code>Data</code> - hier sind alle Spalten gespeichert (dazu spÃ¤ter mehr)</li>
        <li><code>Metadata</code> - Metadaten, also die Karte der Datei</li>
    </ul>

    <p>
        Der erste Schritt zum korrekten Lesen einer Parquet-Datei ist die ÃœberprÃ¼fung, ob die ersten 4 Bytes <code>PAR1</code> sind.<br/>
        Wenn ja, mÃ¼ssen wir zum Ende der Datei springen (seek) und die letzten 4 Bytes lesen.
    </p>
    <p>
        Wenn Anfang und Ende der Datei <code>PAR1</code> enthalten, kÃ¶nnen wir mit dem Lesen der Metadaten beginnen.
    </p>
    <p>
        Dazu gehen wir 8 Bytes vom Ende der Datei zurÃ¼ck und lesen 4 Bytes, die die GrÃ¶ÃŸe der Metadaten reprÃ¤sentieren.
        Mit anderen Worten, wir lesen die Bytes <code>-8</code> bis <code>-4</code>
    </p>
    <p>
        Diese 4 Bytes sind ein <code>integer</code>, der angibt, auf wie vielen Bytes die Metadaten gespeichert sind. Mit
        dieser Information kÃ¶nnen wir die Metadaten lesen, die binÃ¤r mit <a href="https://thrift.apache.org/" target="_blank">Apache Thrift</a> serialisiert sind
    </p>
    <a href="#apache-thrift"><h2 id="apache-thrift">Apache Thrift</h2></a>
    <p>
        Apache Thrift ist ein sehr cleveres Tool, das die binÃ¤re Serialisierung von Interfaces/Typen in praktisch jeder
        Programmiersprache ermÃ¶glicht.
    </p>
    <p>
        <a href="https://github.com/flow-php/flow/blob/1.x/src/lib/parquet/src/Flow/Parquet/Resources/Thrift/parquet_clean.thrift" target="_blank">Hier</a>
        kÃ¶nnen wir sehen, wie die Definition der Metadaten im Parquet-Format aussieht.
    </p>
    <p>
        Dieses Format erinnert etwas an Pseudocode, der dann mit der entsprechenden Anwendung verwendet wird, um
        Code in der jeweiligen Programmiersprache zu generieren.
    </p>
    <p>
        <a href="https://github.com/flow-php/flow/tree/1.x/src/lib/parquet/src/Flow/Parquet/Thrift" target="_blank">Hier</a>
        kÃ¶nnen wir sehen, wie der generierte Code in PHP aussieht.
    </p>
    <p>
        Wenn wir die generierten Strukturen/Interfaces/Modelle haben, kÃ¶nnen wir mit dem Lesen beginnen.
    </p>

    <pre><code class="code-php" data-controller="syntax-highlight">&lt;?php

use Flow\Parquet\Thrift\FileMetaData;
use Thrift\Protocol\TCompactProtocol;
use Thrift\Transport\TMemoryBuffer;

$metadataLength = \unpack($this-&gt;byteOrder-&gt;value, $this-&gt;stream-&gt;read(4, $fileTotalSize - 8))[1];

$fileMetadata = new FileMetaData();
$fileMetadata-&gt;read(
    new TCompactProtocol(
        new TMemoryBuffer(
            $this-&gt;stream-&gt;read($metadataLength, $fileTotalSize - ($metadataLength + 8))
        )
    )
);</code></pre>

    <p>
        DafÃ¼r brauchen wir die Thrift-Bibliothek fÃ¼r die gewÃ¤hlte Programmiersprache.
        Alle Implementierungen sind im Repository <a href="https://github.com/apache/thrift" target="_blank">apache/thrift</a> verfÃ¼gbar.
    </p>

    <p>
        Mit Zugriff auf <code>$metadata</code> kÃ¶nnen wir anfangen, unsere Datei zu analysieren, um ihre Struktur zu verstehen.<br/>
    </p>

    <a href="#parquet-file-metadata"><h2 id="parquet-file-metadata">Parquet - FileMetaData</h2></a>

    <pre><code class="code-shell" data-controller="syntax-highlight">struct FileMetaData {
  1: required i32 version
  2: required list&lt;SchemaElement&gt; schema;
  3: required i64 num_rows
  4: required list&lt;RowGroup&gt; row_groups
  5: optional list&lt;KeyValue&gt; key_value_metadata
  6: optional string created_by
  7: optional list&lt;ColumnOrder&gt; column_orders;
  8: optional EncryptionAlgorithm encryption_algorithm
  9: optional binary footer_signing_key_metadata
}</code></pre>

    <p>
        SchlÃ¼sselinformationen Ã¼ber die Datei werden in der <code>FileMetaData</code>-Struktur gespeichert.
        Die wichtigsten davon sind:
    </p>
    <ul>
        <li><code>version</code> - Parquet-Format-Version</li>
        <li><code>num_rows</code> - Anzahl der Zeilen in der Datei</li>
        <li><code>schema</code> - Datenschema</li>
        <li><code>row_groups</code> - hier sind unsere Daten gespeichert</li>
    </ul>

    <a href="#format-versions"><h2 id="format-versions">Format-Versionen</h2></a>
    <p>
        Zum Zeitpunkt des Schreibens dieses Artikels war das Parquet-Format bereits in Version <code>2.12.0</code> verfÃ¼gbar.
    </p>
    <p>
        Die wichtigsten Ã„nderungen zwischen Version 1.0 und 2.0 sind:
    </p>
    <ul>
        <li><strong>Neue Kodierungsschemas:</strong> DELTA_BINARY_PACKED fÃ¼r Zahlen, DELTA_BYTE_ARRAY fÃ¼r Strings, RLE_DICTIONARY ersetzt PLAIN_DICTIONARY</li>
        <li><strong>Data Page V2 Struktur:</strong> Metadaten-Overhead eliminiert, Filterung auf Seitenebene ermÃ¶glicht</li>
    </ul>
    <p>
        Obwohl Version 2.0 viele Verbesserungen einfÃ¼hrt, verwenden die grÃ¶ÃŸten Akteure standardmÃ¤ÃŸig noch Version 1.
    </p>
    <a href="#rows-count"><h2 id="rows-count">Anzahl der Zeilen</h2></a>
    <p>
        Diese Information mag anfangs im Kontext des spaltenorientierten Formats wenig intuitiv erscheinen.<br/>
        Wir mÃ¼ssen jedoch daran denken, dass das spaltenorientierte Format nur eine Art der Wertspeicherung und nicht der Datenstruktur ist.
    </p>
    <p>
        Obwohl Daten auf Basis von Spalten und ihrem Typ gruppiert sind, erfolgt das Lesen/Schreiben immer noch auf klassische
        Weise, also Zeile fÃ¼r Zeile.
    </p>
    <p>
        Der Unterschied besteht darin, dass wir nicht eine Zeile auf einmal lesen, sondern eine ganze Zeilengruppe, wobei wir
        Spalte fÃ¼r Spalte in den Speicher laden und dann die Zeilen basierend auf den entsprechenden Indizes rekonstruieren.
    </p>
    <div class="notice">
    <p>
        Wenn wir daran denken, dass wir, um Daten ordnungsgemÃ¤ÃŸ im spaltenorientierten Format zu speichern, mit logischen Gruppen arbeiten mÃ¼ssen, nicht mit einzelnen Zeilen.
        KÃ¶nnen wir relativ einfach das VerhÃ¤ltnis von Speicher zu Anzahl der IO-Operationen verwalten.
    </p>
    </div>
    <p>
        Schreiben und Lesen aus dem Speicher ist schneller als Schreiben und Lesen von der Festplatte (<a href="https://www.bitflux.ai/blog/memory-is-slow-part1/" target="_blank">obwohl nicht immer</a>).
        Indem wir die Anzahl der Zeilen erhÃ¶hen, die in einer Gruppe gespeichert werden, reduzieren wir die Anzahl der Gruppen, also die Anzahl der IO-Operationen. <br/>
        Damit erhÃ¶hen wir die Geschwindigkeit des Schreibens/Lesens und gleichzeitig den Speicherverbrauch.
    </p>
    <p>
        Das funktioniert auch in die andere Richtung: Indem wir die Anzahl der Zeilen in einer Gruppe reduzieren, erhÃ¶hen wir die Anzahl der Gruppen in der Datei, damit
        erhÃ¶hen wir die Anzahl der IO-Operationen.
    </p>
    <p>
        <strong>GruppengrÃ¶ÃŸe, nicht Zeilenanzahl</strong> - Parquet erlaubt es, nicht die Anzahl der Zeilen zu definieren, sondern die maximale
        GrÃ¶ÃŸe der Zeilengruppe. <br/>
        Man muss jedoch bedenken, dass dies keine absoluten Werte sind (dazu etwas spÃ¤ter), so dass
        einige Gruppen kleiner/grÃ¶ÃŸer als die zulÃ¤ssige GrÃ¶ÃŸe sein kÃ¶nnen, und das hÃ¤ngt hauptsÃ¤chlich von der Implementierung der Bibliothek
        fÃ¼r Parquet ab.
    </p>
    <p>
        In der Dokumentation des Parquet-Formats finden wir die Information, dass die empfohlene GruppengrÃ¶ÃŸe <code>512MB - 1GB</code> betrÃ¤gt.
        Es lohnt sich jedoch, dies mit etwas Vernunft anzugehen, besonders wenn wir uns beim Lesen/Schreiben nicht auf HDFS (Hadoop Distributed File System) verlassen. <br/>
        Der empfohlene Wert ist so festgelegt, dass eine Zeilengruppe in einen HDFS-Block passt, wodurch garantiert wird, dass das Lesen
        von genau einem Knoten aus erfolgt.
    </p>
    <p>
        Das sollte man im Hinterkopf behalten. Wenn wir jedoch nicht planen, Parquet mit einem verteilten Dateisystem zu verwenden, erlauben kleinere Zeilen-
        gruppen, viel Speicher zu sparen.
    </p>
    <p>
        Ein sehr gutes Beispiel, wann kleinere Gruppen effizienter sind, ist der Fall, in dem wir nur einen kleinen Abschnitt von Zeilen
        irgendwo aus der Mitte der Datei lesen mÃ¶chten (Paginierung).
    </p>
    <p>
        Angenommen, wir mÃ¼ssen nur 100 Zeilen aus einer Datei lesen, die 10 Millionen Zeilen enthÃ¤lt. Die Einstellung einer kleineren
        GruppengrÃ¶ÃŸe ermÃ¶glicht es, viel Speicher zu sparen. Warum?
    </p>
    <p>
        Wenn wir 10 Millionen in, sagen wir, 10 Gruppen aufteilen, enthÃ¤lt jede Gruppe 1 Million Zeilen. Das bedeutet, dass wir praktisch
        die gesamte Gruppe lesen mÃ¼ssen und dann nur 100 Zeilen extrahieren, die uns interessieren.
    </p>
    <p>
        Im Fall der Festlegung einer kleineren GruppengrÃ¶ÃŸe, die es ermÃ¶glicht, 10 Millionen in 1000 Gruppen zu unterteilen, kÃ¶nnen wir durch die Analyse
        der Datei-Metadaten eine grÃ¶ÃŸere Anzahl von Gruppen Ã¼berspringen und eine viel kleinere Anzahl von Zeilen in den Speicher laden.
    </p>
    <div class="notice">
    <p>
        Die Entscheidung Ã¼ber die GrÃ¶ÃŸe der Zeilengruppe sollte sowohl hinsichtlich der Schreibgeschwindigkeit als auch der Lesegeschwindigkeit
        einer bestimmten Datei durchdacht sein. Die richtige Konfiguration wirkt sich direkt auf den Ressourcenverbrauch aus, was sich letztendlich in
        Geld niederschlÃ¤gt.
    </p>
    </div>

    <a href="#schema"><h2 id="schema">Schema</h2></a>

    <p>
        Langsam kommen wir zum Kern von Parquet, den <code>Row Groups</code>. Bevor wir jedoch ihre Struktur analysieren, mÃ¼ssen wir
        zu einem weiteren sehr wichtigen Aspekt von Parquet zurÃ¼ckkehren, dem Datenschema.
    </p>

    <p>
        Beginnen wir mit den Datentypen. Parquet besteht aus physischen und logischen Typen.
    </p>

    <h3>Physical Types</h3>

    <p>
        Physische Typen sind grundlegende Datentypen, die zur Speicherung von Werten in einer Parquet-Datei verwendet werden.
        Das sind Typen wie:
    </p>

    <ul>
        <li>Boolean</li>
        <li>Byte Array</li>
        <li>Double</li>
        <li>Fixed Len Byte Array</li>
        <li>Float</li>
        <li>Int32</li>
        <li>Int64</li>
        <li>Int96 - (veraltet - nur von Ã¤lteren Implementierungen verwendet)</li>
    </ul>

    <p>
        Logische Typen sind Typen, die zur Darstellung komplexerer Datenstrukturen verwendet werden. Man kann
        sie als Erweiterung der physischen Typen betrachten.
    </p>

    <h3>Logical Types</h3>

    <ul>
        <li>Bson</li>
        <li>Date</li>
        <li>Decimal</li>
        <li>Enum</li>
        <li>Integer</li>
        <li>Json</li>
        <li>List</li>
        <li>Map</li>
        <li>String</li>
        <li>Time</li>
        <li>Timestamp</li>
        <li>Uuid</li>
    </ul>

    <p>
        Die aktuelle Struktur kann man immer bei der Quelle Ã¼berprÃ¼fen, <a href="https://github.com/apache/parquet-format/blob/master/src/main/thrift/parquet.thrift" target="_blank">apache/parquet-format</a>
    </p>

    <p>
        Neben der Unterteilung in logische und physische Typen unterscheidet Parquet auch zwischen flachen und verschachtelten Spalten.<br/>
        <strong>Flache Spalten</strong> sind solche, die einen einzelnen Wert speichern, z.B. <code>Int32</code>, <code>Boolean</code>, <code>Float</code> usw.<br/>
        <strong>Verschachtelte Spalten</strong> sind solche, die mehr als einen Wert speichern, z.B. <code>List</code>, <code>Map</code> usw.
    </p>

    <p>
        Es gibt grundsÃ¤tzlich 3 Arten von verschachtelten Spalten:
    </p>
    <ul>
        <li>List</li>
        <li>Map</li>
        <li>Struct</li>
    </ul>
    <p>
        <strong>Struct</strong> ist ein spezieller Spaltentyp, der die Verschachtelung beliebiger anderer Typen ermÃ¶glicht und die Erstellung
        praktisch jeder Datenstruktur erlaubt.
    </p>
    <p>
        Mit den obigen Typen sind wir in der Lage, praktisch jede
        Datenstruktur zu modellieren und sie dann effizient zu speichern und zu durchsuchen.
    </p>
    <p>
        Schauen wir uns also die Thrift-Definitionen von <code>SchemaElement</code> und einigen verwandten Elementen an.
    </p>

    <pre><code class="code-shell" data-controller="syntax-highlight">struct SchemaElement {
  1: optional Type type;
  2: optional i32 type_length;
  3: optional FieldRepetitionType repetition_type;
  4: required string name;
  5: optional i32 num_children;
  6: optional ConvertedType converted_type;
  7: optional i32 scale
  8: optional i32 precision
  9: optional i32 field_id;
  10: optional LogicalType logicalType
}

enum FieldRepetitionType {
  REQUIRED = 0;
  OPTIONAL = 1;
  REPEATED = 2;
}

enum Type {
  BOOLEAN = 0;
  INT32 = 1;
  INT64 = 2;
  INT96 = 3;
  FLOAT = 4;
  DOUBLE = 5;
  BYTE_ARRAY = 6;
  FIXED_LEN_BYTE_ARRAY = 7;
}

union LogicalType {
  1:  StringType STRING
  2:  MapType MAP
  3:  ListType LIST
  4:  EnumType ENUM
  5:  DecimalType DECIMAL
  6:  DateType DATE
  7:  TimeType TIME
  8:  TimestampType TIMESTAMP
  10: IntType INTEGER
  11: NullType UNKNOWN
  12: JsonType JSON
  13: BsonType BSON
  14: UUIDType UUID
}</code></pre>

    <p>
        Die meisten Werte sollten ziemlich offensichtlich sein, schauen wir uns jedoch <code>FieldRepetitionType</code> an.
    </p>

    <p>
        Dieser Wert sagt uns, ob eine gegebene Spalte erforderlich, optional oder wiederholbar ist.<br/>
        Wenn eine Spalte erforderlich ist, bedeutet das, dass der Wert nicht null sein kann. <br/>
        Wenn eine Spalte optional ist, kann der Wert null sein, und wenn sie wiederholbar ist, bedeutet das, dass sie mehrere Werte enthalten kann (z.B. eine Liste).
    </p>

    <p>
        So kÃ¶nnte das Schema einer Bestelldatei aussehen (in DDL-Form)
    </p>

    <pre><code class="code-shell" data-controller="syntax-highlight">message orders_scheme {
    required fixed_len_byte_array(16) order_id (UUID)
    required int64 created_at (TIMESTAMP(MICROS,false))
    optional int64 updated_at (TIMESTAMP(MICROS,false))
    optional float discount
    required binary email (STRING)
    required binary customer (STRING)
    required group address {
          required binary street (STRING);
          required binary city (STRING);
          required binary zip (STRING);
          required binary country (STRING);
    }
    required group notes (LIST) {
          repeated group list {
                required binary element (STRING);
          }
    }
    required group items (LIST) {
          repeated group list {
                required group element {
                      required binary sku (STRING);
                      required int64 quantity (INTEGER(64,true));
                      required float price;
                }
          }
    }
}</code></pre>

    <a href="#nested-types"><h2 id="nested-types">Verschachtelte Typen</h2></a>

    <p>
        Um die Struktur von Zeilengruppen vollstÃ¤ndig zu verstehen, mÃ¼ssen wir zuerst verstehen, wie Parquet verschachtelte Typen abflacht.<br/>
        WÃ¤hrend einfache Strukturen wie <code>address</code> aus dem obigen Beispiel auf 4 einfache Spalten reduziert werden kÃ¶nnen:
    </p>
    <ul>
        <li><code>address.street</code> - String</li>
        <li><code>address.city</code> - String</li>
        <li><code>address.zip</code> - String</li>
        <li><code>address.country</code> - String</li>
    </ul>
    <p>
        Im Fall von <code>Map</code> oder <code>List</code> ist die Situation etwas komplizierter.
    </p>
    <p>
        Wenn wir zum Beispiel <code>Map&lt;string,int32&gt;</code> abflachen wollten, wÃ¼rden wir so etwas erhalten:
    </p>
    <ul>
        <li><code>map_column.key_value.key</code> - String</li>
        <li><code>map_column.key_value.value</code> - Int32</li>
    </ul>
    <p>
        FÃ¼r das obige Beispiel wÃ¤re der flache Pfad zu <code>sku</code>:
        <code>items.list.element.sku</code>, wÃ¤hrend die abgeflachte vollstÃ¤ndige Struktur so aussehen wÃ¼rde:
    </p>
    <pre><code class="code-shell" data-controller="syntax-highlight">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Columns â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ path                        â”‚ type                     â”‚ logical type â”‚ repetition â”‚ max repetition â”‚ max definition â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ order_id                    â”‚ FIXED_LEN_BYTE_ARRAY(16) â”‚ UUID         â”‚ REQUIRED   â”‚ 0              â”‚ 0              â”‚
â”‚ created_at                  â”‚ INT64                    â”‚ TIMESTAMP    â”‚ REQUIRED   â”‚ 0              â”‚ 0              â”‚
â”‚ updated_at                  â”‚ INT64                    â”‚ TIMESTAMP    â”‚ OPTIONAL   â”‚ 0              â”‚ 1              â”‚
â”‚ discount                    â”‚ FLOAT                    â”‚ -            â”‚ OPTIONAL   â”‚ 0              â”‚ 1              â”‚
â”‚ email                       â”‚ BYTE_ARRAY               â”‚ STRING       â”‚ REQUIRED   â”‚ 0              â”‚ 0              â”‚
â”‚ customer                    â”‚ BYTE_ARRAY               â”‚ STRING       â”‚ REQUIRED   â”‚ 0              â”‚ 0              â”‚
â”‚ address.street              â”‚ BYTE_ARRAY               â”‚ STRING       â”‚ REQUIRED   â”‚ 0              â”‚ 0              â”‚
â”‚ address.city                â”‚ BYTE_ARRAY               â”‚ STRING       â”‚ REQUIRED   â”‚ 0              â”‚ 0              â”‚
â”‚ address.zip                 â”‚ BYTE_ARRAY               â”‚ STRING       â”‚ REQUIRED   â”‚ 0              â”‚ 0              â”‚
â”‚ address.country             â”‚ BYTE_ARRAY               â”‚ STRING       â”‚ REQUIRED   â”‚ 0              â”‚ 0              â”‚
â”‚ notes.list.element          â”‚ BYTE_ARRAY               â”‚ STRING       â”‚ REQUIRED   â”‚ 1              â”‚ 1              â”‚
â”‚ items.list.element.sku      â”‚ BYTE_ARRAY               â”‚ STRING       â”‚ REQUIRED   â”‚ 1              â”‚ 1              â”‚
â”‚ items.list.element.quantity â”‚ INT64                    â”‚ -            â”‚ REQUIRED   â”‚ 1              â”‚ 1              â”‚
â”‚ items.list.element.price    â”‚ FLOAT                    â”‚ -            â”‚ REQUIRED   â”‚ 1              â”‚ 1              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>

    <a href="#row-groups"><h2 id="row-groups">Row Groups</h2></a>

    <pre><code class="code-shell" data-controller="syntax-highlight">+-----------------------------------+
| PAR1                              |
+-----------------------------------+
| Row Group 1                       |
|   +-----------------------------+ |
|   | Column Chunk 1              | |
|   |   (Metadata + Data Pages)   | |
|   +-----------------------------+ |
|   | Column Chunk 2              | |
|   |   (Metadata + Data Pages)   | |
|   +-----------------------------+ |
|   ...                             |
+-----------------------------------+
| Row Group 2                       |
|   +-----------------------------+ |
|   | Column Chunk 1              | |
|   |   (Metadata + Data Pages)   | |
|   +-----------------------------+ |
|   | Column Chunk 2              | |
|   |   (Metadata + Data Pages)   | |
|   +-----------------------------+ |
|   ...                             |
+-----------------------------------+
| ...                               |
+-----------------------------------+
| Metadata                          |
+-----------------------------------+
| PAR1                              |
+-----------------------------------+</code></pre>

    <p>
        Wie wir bereits wissen, ist eine Parquet-Datei in Zeilengruppen unterteilt. Das Schreiben in eine Datei sieht vereinfacht so aus:
    </p>
    <ul>
        <li>1) Erstelle eine Datei und fÃ¼ge 4 Bytes <code>PAR1</code> hinzu</li>
        <li>2) Erstelle eine Metadatenstruktur basierend auf dem Schema und halte sie im Speicher</li>
        <li>3) Flache die Ã¼bergebene Zeile ab (Ã¼berprÃ¼fe, ob sie zum Schema passt)</li>
        <li>4) Speichere die abgeflachte Zeile im Speicher in binÃ¤rer Form</li>
        <li>
            5) ÃœberprÃ¼fe, ob die GrÃ¶ÃŸe der Zeilengruppe, die wir derzeit im Speicher halten, in die maximal zulÃ¤ssige GrÃ¶ÃŸe passt
            <ul>
                <li>a) Schreibe die Zeilengruppe in die Datei</li>
                <li>b) Aktualisiere die Metadaten im Speicher, indem du die Metadaten der Gruppe hinzufÃ¼gst, die wir gerade geschrieben haben</li>
            </ul>
        </li>
        <li>
            6) Kehre zu Schritt 2 zurÃ¼ck
        </li>
        <li>
            7) Schreibe die Metadaten an das Ende der Datei, nachdem alle Zeilengruppen geschrieben wurden
        </li>
        <li>
            8) SchlieÃŸe die Datei mit 4 Bytes <code>PAR1</code>
        </li>
    </ul>
    <div class="notice">
    <p>
        NatÃ¼rlich ist diese Beschreibung sehr vereinfacht, in Wirklichkeit ist sie etwas komplexer, auÃŸerdem kÃ¶nnen sich verschiedene Implementierungen
        in den Details unterscheiden.
    </p>
    </div>

    <p>
        Konzentrieren wir uns auf die Struktur der Zeilengruppe, schauen wir uns zuerst die Thrift-Definitionen von <code>RowGroup</code> an.
    </p>

    <pre><code class="code-shell" data-controller="syntax-highlight">struct RowGroup {
  1: required list&lt;ColumnChunk&gt; columns
  2: required i64 total_byte_size
  3: required i64 num_rows
  4: optional list&lt;SortingColumn&gt; sorting_columns
  5: optional i64 file_offset
  6: optional i64 total_compressed_size
  7: optional i16 ordinal
}
</code></pre>

    <p>
        Bereits auf dieser Ebene sieht man, wie viele Informationen Ã¼ber eine bestimmte Zeilengruppe in den Metadaten gespeichert sind.<br/>
        FÃ¼r jetzt konzentrieren wir uns jedoch auf drei Felder:
    </p>
    <ul>
        <li><code>file_offset</code> - wie viele Bytes vom Dateianfang Ã¼bersprungen werden mÃ¼ssen, um die gegebene Gruppe zu lesen</li>
        <li><code>total_byte_size</code> - auf wie vielen Bytes die Zeilengruppe gespeichert ist</li>
        <li><code>columns</code> - detaillierte Informationen Ã¼ber jede Spalte, die im Rahmen der gegebenen Gruppe gespeichert ist</li>
    </ul>

    <div class="important">
        <p>
            <strong>Wichtig:</strong> Jede Zeilengruppe enthÃ¤lt immer alle im Schema definierten Spalten.<br/>
            Auch wenn Ã¼ber den gesamten Bereich der Gruppe eine Spalte nur Null-Werte enthÃ¤lt.
        </p>
    </div>

    <a href="#column-chunks"><h2 id="column-chunks">Column Chunks</h2></a>

    <p>
        Gehen wir tiefer und schauen uns die Thrift-Definition von <code>ColumnChunk</code> an
    </p>
    <pre><code class="code-shell" data-controller="syntax-highlight">struct ColumnChunk {
  1: optional string file_path
  2: required i64 file_offset
  3: optional ColumnMetaData meta_data
  4: optional i64 offset_index_offset
  5: optional i32 offset_index_length
  6: optional i64 column_index_offset
  7: optional i32 column_index_length
  8: optional ColumnCryptoMetaData crypto_metadata
  9: optional binary encrypted_column_metadata
}

struct ColumnMetaData {
  1: required Type type
  2: required list&lt;Encoding&gt; encodings
  3: required list&lt;string&gt; path_in_schema
  4: required CompressionCodec codec
  5: required i64 num_values
  6: required i64 total_uncompressed_size
  7: required i64 total_compressed_size
  8: optional list&lt;KeyValue&gt; key_value_metadata
  9: required i64 data_page_offset
  10: optional i64 index_page_offset
  11: optional i64 dictionary_page_offset
  12: optional Statistics statistics;
  13: optional list&lt;PageEncodingStats&gt; encoding_stats;
  14: optional i64 bloom_filter_offset;
  15: optional i32 bloom_filter_length;
}
</code></pre>

    <div class="notice">
        <p>
            <strong>Denke daran:</strong> Alles, was wir bisher betrachtet haben, ist immer noch Teil der Metadaten. <br/>
            Das bedeutet, dass wir all diese Informationen Ã¼ber Spalten, Zeilengruppen oder die Daten selbst erhalten, indem wir
            nur das Ende der Datei lesen, unabhÃ¤ngig davon, ob die Datei 1MB oder 1TB hat.
        </p>
    </div>

    <p>
        Hier kommen wir grundsÃ¤tzlich zu dem Punkt, der es uns ermÃ¶glicht, Daten aus der Datei zu lesen. <br/>
        Bevor das jedoch geschieht, mÃ¼ssen wir die letzte Datenstruktur kennenlernen, die zum Lesen notwendig ist.
    </p>

    <a href="#data-pages"><h2 id="data-pages">Data Pages</h2></a>

    <p>
        <code>Pages</code>, also eine weitere logische Unterteilung in der Struktur einer Parquet-Datei.<br/>
        <code>Row Group -> Column Chunk -> Data Pages</code>
    </p>

    <ul>
        <li><code>RowGroup</code> - Zeilengruppe (Partition)</li>
        <li><code>ColumnChunk</code> - jede Zeilengruppe enthÃ¤lt genau 1 <code>ColumnChunk</code> fÃ¼r jede Spalte in der Gruppe</li>
        <li><code>Data Page</code> - Seite, die kleinste logische Einheit in Parquet, die Daten aggregiert</li>
    </ul>

    <p>
        Das Lesen von Parquet lÃ¤uft eigentlich darauf hinaus, die Metadatenstruktur zu analysieren, die Adresse des Beginns einer bestimmten Zeilengruppe zu lokalisieren, dann
        eine bestimmte Spalte in der Gruppe und dann zu iterieren und Daten von jeder Seite zu lesen.
    </p>

    <p>
        Bevor wir jedoch mit dem Lesen von Seiten beginnen, mÃ¼ssen wir verstehen, ob wir es mit einer <code>DataPage</code>, <code>IndexPage</code> oder <code>DictionaryPage</code> zu tun haben.
    </p>
    <p>
        Dazu lesen wir zuerst den <code>PageHeader</code>, also den Seitenkopf, dessen Thrift-Definition so aussieht
    </p>

    <pre><code class="code-shell" data-controller="syntax-highlight">struct PageHeader {
  1: required PageType type
  2: required i32 uncompressed_page_size
  3: required i32 compressed_page_size
  4: optional i32 crc
  5: optional DataPageHeader data_page_header;
  6: optional IndexPageHeader index_page_header;
  7: optional DictionaryPageHeader dictionary_page_header;
  8: optional DataPageHeaderV2 data_page_header_v2;
}

enum PageType {
  DATA_PAGE = 0;
  INDEX_PAGE = 1;
  DICTIONARY_PAGE = 2;
  DATA_PAGE_V2 = 3;
}</code></pre>

    <p>
        Um den Header zu lesen, mÃ¼ssen wir seine Adresse relativ zum Dateianfang kennen. So kÃ¶nnen wir ihn fÃ¼r eine ausgewÃ¤hlte Zeilengruppe und ausgewÃ¤hlte Spalte berechnen:
    </p>

    <ol>
        <li>Wir lesen <code>FileMetadata</code></li>
        <li>Wir finden die entsprechende <code>RowGroup</code> und suchen den fÃ¼r uns relevanten <code>ColumnChunk</code></li>
        <li>Mit <code>ColumnChunk</code> erhalten wir die Adresse <code>file_offset</code> des Beginns von <code>ColumnChunk</code> relativ zum Dateianfang.</li>
    </ol>

    <div class="important">
        <p>
            <strong>Wichtig:</strong> Auf dieser Ebene mÃ¼ssen wir noch nicht physisch Bytes in den Speicher laden.<br/>
            Es reicht, wenn wir einen <code>stream</code> erstellen, der das Lesen von Daten direkt aus der Datei ermÃ¶glicht.
        </p>
    </div>

    <p>
        Das erste, was gelesen werden sollte, ist der Header, <code>PageHeader</code>. Indem wir das mit Thrift machen und den
        Stream Ã¼bergeben und die Adresse des Beginns entsprechend setzen, erhalten wir die Datenstruktur <code>PageHeader</code>, die uns genau sagt, wie die
        Seite selbst zu lesen ist.
    </p>
    <p>
        Es gibt 3 Arten von Seiten:
    </p>
    <h3><code>DataPage</code></h3>
    <p>
        Seite, die die binÃ¤re Darstellung von Daten einer ausgewÃ¤hlten Spalte aus Zeilen enthÃ¤lt, die in die ausgewÃ¤hlte Zeilengruppe gelangt sind.<br/>
        Das ist der einfachste und direkteste Seitentyp. EnthÃ¤lt "nur" Daten.
    </p>
    <p>
        Beim Lesen einer Integer-Spalte interessiert uns eigentlich die Anzahl der Zeilen in einer bestimmten Gruppe (jede Zeile ist ein Wert in <code>DataPage</code>).
        Wenn wir also wissen, dass wir in dieser Gruppe, sagen wir, 100 Werte haben, wissen wir, dass wir 400 Bytes lesen mÃ¼ssen (int32 ist auf 4 Bytes gespeichert). <br/>
    </p>
    <p>
        Okay, aber was ist, wenn die Spalte optional ist? Das bedeutet, dass sie Null-Werte enthalten kann.<br/>
        Hier wird die Situation etwas komplizierter, weil wir wissen mÃ¼ssen, welche Zeilen Null-Werte enthalten.<br/>
        Woher kommt dieses Wissen, fragt ihr euch? <br/>
        <code>Definition Levels</code>
    </p>
    <p>
        Die Situation wird etwas kompliziert, am Anfang schrieb ich, dass <code>DataPage</code> nur Daten enthÃ¤lt, und jetzt fÃ¼ge ich irgendwelche <code>Definition Levels</code> hinzu.<br/>
    </p>
    <p>
        In Wirklichkeit sieht die Struktur der Datenseite etwa so aus:
    </p>
    <pre><code class="code-shell" data-controller="syntax-highlight">Parquet Data Page: int32
=======================================
[ Repetition Levels ]: 0, 0, 0, 0, 0
---------------------------------------
[ Definition Levels ]: 1, 0, 1, 1, 0
---------------------------------------
[ Values           ]: 42, 73, 19
=======================================
</code></pre>
    <p>
        Im Moment konzentrieren wir uns nur auf <code>Definition Levels</code> und <code>Values</code>. Es ist sehr leicht, die Beziehung zwischen ihnen zu sehen.
        Die Anzahl der <code>Definition Level</code> und <code>Repetition Levels</code> in jeder Seite ist immer gleich der Anzahl der Werte in der Spalte.<br/>
        UnabhÃ¤ngig davon, ob dort Nullen sind oder nicht. <code>Definition Levels</code> sagen uns, ob eine gegebene Zeile einen Wert oder null enthÃ¤lt.
    </p>
    <p>
        Auf dieser Basis kÃ¶nnen wir leicht die Gesamtzahl der nicht leeren <code>Values</code> bestimmen, was uns das Lesen ermÃ¶glicht. <br/>
        Im obigen Beispiel haben wir 5 Zeilen, von denen 3 Werte darstellen. Da wir <code>int32</code> auf 4 Bytes speichern,
        wissen wir bereits, dass wir insgesamt 12 Bytes lesen mÃ¼ssen.<br/>
        Wir wissen auch, dass bei der Umwandlung der Spalte in Zeilen die erste Zeile den Wert <code>42</code> enthalten wird, die zweite Zeile <code>null</code>,
        die dritte Zeile <code>73</code>, die vierte Zeile <code>19</code> und die fÃ¼nfte Zeile <code>null</code>.
    </p>
    <div class="important">
        <p>
            <strong>Wichtig:</strong> <code>Repetition Levels</code> und <code>Definition Levels</code> sind jedoch viel komplizierter, dazu etwas mehr spÃ¤ter.<br/>
        </p>
    </div>
    <p>
        So etwa sieht die Struktur von <code>DataPage</code> aus.
    </p>
    <h3><code>DictionaryPage</code></h3>
    <p>
        Da wir Daten in <code>DataPage</code> speichern, welchen Zweck hat <code>DictionaryPage</code>?<br/>
        Nun, <code>DictionaryPage</code> ist eine Seite, die ein WÃ¶rterbuch von Werten enthÃ¤lt.<br/>
        WÃ¶rterbuch, verwendet zum Lesen von Daten, besonders bei Spalten mit sich wiederholenden Werten.
    </p>

    <p>
        Es funktioniert etwa so, dass beim Lesen von <code>ColumChunk</code> wir mit der ersten Seite beginnen. Wenn diese Seite eine <code>DictionaryPage</code> ist,
        wissen wir, dass wir es mit einem WÃ¶rterbuch zu tun haben (eigentlich wissen wir das von Anfang an, weil es in den Metadaten der Spalte gespeichert ist).
    </p>
    <p>
        Wenn wir zum Beispiel eine Spalte mit hoher Wiederholung lesen, z.B. eine Spalte mit einem LÃ¤ndernamen, anstatt in <code>DataPage</code> den vollstÃ¤ndigen LÃ¤ndernamen fÃ¼r jede Zeile zu speichern,
        speichern wir nur ihre Position im WÃ¶rterbuch.<br/>
        Bei einer solchen Spalte wird die erste Seite in der Spalte <code>DictionaryPage</code> sein, und die folgenden werden <code>DataPage</code> sein.
    </p>
    <p>
        Der Unterschied besteht darin, dass in <code>DataPage</code> anstelle des vollen Wertes Positionen im WÃ¶rterbuch stehen, das wir im Speicher behalten, um Zeilen zu rekonstruieren.<br/>
    </p>
    <div class="important">
        <p>
            <strong>Wichtig:</strong> Jeder <code>ColumnChunk</code> kann nur eine <code>DictionaryPage</code> enthalten.
        </p>
    </div>
    <p>
        Das kann zu enormen Einsparungen fÃ¼hren. Anstatt, sagen wir, das Wort <code>Polen</code> 10.000 Mal binÃ¤r zu speichern, also 60k Bytes,
        speichern wir nur die Position im Index (also 4 Bytes), die zusÃ¤tzlich mit dem Algorithmus <a href="https://parquet.apache.org/docs/file-format/data-pages/encodings/#RLE" target="_blank">Run Length Encoding / Bit-Packing Hybrid</a> gepackt werden.
        Der sich ebenfalls auf die Wiederholung aufeinanderfolgender Werte stÃ¼tzt, um die Gesamtzahl der benÃ¶tigten Bytes zu reduzieren.
    </p>

    <h3><code>IndexPage</code></h3>
    <p>
        Der letzte Seitentyp ist <code>IndexPage</code>.<br/>
        Diese Seite enthÃ¤lt keine Daten, ist also weder zum Lesen noch zum Schreiben notwendig.<br/>
        Jeder <code>ColumnChunk</code> kann nur eine <code>IndexPage</code> enthalten, und sie befindet sich immer am Ende, nach <code>DictionaryPage</code> und allen <code>DataPage</code>.
    </p>
    <p>
        Das Ziel dieser Seite ist die Speicherung von Statistiken Ã¼ber <code>ColumnChunk</code>, wie z.B. <code>Min/Max</code>-Werte, Anzahl der <code>Nulls</code> oder Sortierreihenfolge fÃ¼r jede Seite in einem bestimmten <code>ColumnChunk</code>.
        Das ermÃ¶glicht schnelles Filtern und Finden bestimmter Seiten innerhalb eines gegebenen <code>ColumnChunks</code>, was die Durchsuchung der Datei erheblich beschleunigt, wenn wir an bestimmten Informationen interessiert sind.
    </p>
    <div class="notice">
        <p>
            <strong>Hinweis:</strong> Jeder <code>ColumnChunk</code> enthÃ¤lt in seinen Metadaten Ã¤hnliche Statistiken wie <code>IndexPage</code>, jedoch nicht fÃ¼r jede Seite, sondern fÃ¼r den gesamten <code>ColumnChunk</code>.<br/>
            Dadurch kÃ¶nnen wir zunÃ¤chst ganze Spalten Ã¼berspringen, die uns nicht interessieren, und dann sogar bestimmte Seiten, wodurch die Menge der Daten, die wir lesen mÃ¼ssen, auf ein absolutes Minimum reduziert wird.
        </p>
    </div>

    <p>
        Wenn man bedenkt, dass diese Informationen in den Metadaten der Datei zu finden sind, kÃ¶nnen sogar die grÃ¶ÃŸten Parquet-Dateien blitzschnell gelesen und gefiltert werden, auch wenn sie nur Ã¼ber das Netzwerk verfÃ¼gbar sind.<br/>
        Es reicht, wenn wir die Metadaten lesen kÃ¶nnen. Auf deren Basis lokalisieren wir eine bestimmte Zeilengruppe, dann eine ausgewÃ¤hlte Spalte und am Ende bestimmte Seiten. <br/>
        Wir erhalten so eine sehr prÃ¤zise Lokalisierung unserer Daten, die wir mit dem <code>Http Range Header</code> lesen kÃ¶nnen.
    </p>
    <p>
        Das ist genau einer der GrÃ¼nde, warum Parquet so mÃ¤chtig ist. Wir sprechen hier nicht mehr Ã¼ber das brutale Herunterladen und Iterieren Ã¼ber eine Gigabyte-Datei. Parquet ermÃ¶glicht es, mit chirurgischer PrÃ¤zision
        nur die Bereiche der Datei herunterzuladen und zu lesen, die uns wirklich interessieren.
    </p>

    <a href="#dremel"><h2 id="dremel">Dremel</h2></a>

    <p>
        Bei der Diskussion der <code>DataPage</code>-Struktur erwÃ¤hnte ich <code>Definition Levels</code> und <code>Repetition Levels</code>.
    </p>
    <p>
        Das diskutierte Beispiel war sehr einfach, weil es sich um eine einfache Spalte (int32) handelte, wodurch <code>Repetition Levels</code> Ã¼berhaupt nicht anwendbar sind.<br/>
        Die Situation Ã¤ndert sich dramatisch, wenn wir es mit einer verschachtelten Spalte zu tun haben, z.B. einer Struktur, Liste oder Map.
        Schauen wir uns ein Beispiel an.
    </p>
    <p>
        <code>[{"sku":"abc", "quantity": 1, "price": 100}, {"sku":"def", "quantity": 2, "price": 200}]</code>
    </p>
    <p>
        ZurÃ¼ck zum frÃ¼heren Teil dieses Artikels, genauer zu <a href="#nested-types">verschachtelten Typen</a>.<br/>
        Wir wissen, dass unsere Daten nach dem Abflachen so aussehen werden:
    </p>
    <ul>
        <li><code>items.list.element.sku</code> - <code>"abc","def"</code></li>
        <li><code>items.list.element.quantity</code> - <code>1,2</code></li>
        <li><code>items.list.element.price</code> - <code>100,200</code></li>
    </ul>
    <p>
        Wir haben hier 3 Spalten, jede von ihnen wird sich in einem separaten <code>Column Chunk</code> befinden, und jede wird
        eine oder mehrere Seiten in sich enthalten.
    </p>
    <p>
        Woher wissen also Bibliotheken, die Dateien lesen, basierend auf diesen beiden Werten (<code>Repetition / Definition Levels</code>), wie tief in der Struktur sich Werte befinden und zu welchem Element sie gehÃ¶ren?<br/>
        Was wÃ¤re, wenn unsere Struktur so aussehen wÃ¼rde:
    </p>
    <p>
        <code>[{"sku":"abc", "quantity": 1, "price": 100}, {"sku":null, "quantity": 10, "price": 100}, {"sku":"def", "quantity": 2, "price": 200}]</code>
        (im zweiten Element hat sku den Wert null). <br/>
    </p>
    <p>Was ist, wenn die Struktur viel verschachtelter ist? Woher sollen wir wissen, welcher Wert auf welche Verschachtelungsebene gehÃ¶rt?</p>
    <p>
        Die Antwort auf diese und viele andere Fragen finden wir in dem von Google verÃ¶ffentlichten Dokument <a href="https://static.googleusercontent.com/media/research.google.com/pl//pubs/archive/36632.pdf" target="_blank">Dremel: Interactive Analysis of Web-Scale Datasets</a>
        das beschreibt, wie Google verschachtelte Datenstrukturen speichert und durchsucht.
    </p>
    <p>
        Das von Google verwendete Tool heiÃŸt Dremel und ist ein verteiltes System zur Durchsuchung groÃŸer DatensÃ¤tze. <br/>
        Es basiert auf 2 Algorithmen, <code>Shredding</code> und <code>Assembling</code>, die sehr oberflÃ¤chlich im obigen Dokument beschrieben sind.
    </p>
    <div class="notice">
        <p>
            <strong>Hinweis:</strong> Die Beschreibung der genauen Funktionsweise dieser Algorithmen geht Ã¼ber den Rahmen dieses bereits langen Beitrags hinaus.<br/>
            Wenn jedoch Interesse an dem Thema aufkommt, werde ich versuchen, auch diesen Aspekt in kommenden BeitrÃ¤gen zu behandeln.
        </p>
    </div>
    <p>
        Diese Algorithmen basieren auf diesen 3 Definitionen:
    </p>
    <ul>
        <li>Repetition Levels</li>
        <li>Definition Levels</li>
        <li>Values</li>
    </ul>
    <p>
        Wie bereits erwÃ¤hnt, bestimmt <code>Definition Level</code>, ob eine gegebene Zeile einen Wert enthÃ¤lt oder nicht, <code>Repetition Level</code>, das bei flachen Spalten immer 0 ist.
        FÃ¼r Strukturen wird es bestimmen, ob ein Wert (oder null) wiederholt werden soll und auf welcher Verschachtelungsebene.
    </p>
    <div class="notice">
        <p>
            <strong>Hinweis:</strong> Das Wissen darÃ¼ber, wie genau die Algorithmen aus Dremel funktionieren, ist nicht notwendig fÃ¼r die optimale Nutzung von Parquet.<br/>
            Aus diesem Grund werde ich nicht ausfÃ¼hrlich darÃ¼ber schreiben. Wenn jedoch Interesse an dem Thema aufkommt, werde ich versuchen, auch diesen Aspekt in kommenden BeitrÃ¤gen zu behandeln.
        </p>
    </div>
    <p>
         Unten werde ich nur ungefÃ¤hr zeigen, wie die abgeflachten Daten aussehen werden.
    </p>
    <pre>
        <code class="code-shell" data-controller="syntax-highlight">Input:
[
    &#039;items&#039; =&gt; [
        [&#039;sku&#039; =&gt; &#039;abc&#039;, ...],
        [&#039;sku&#039; =&gt; &#039;def&#039;, ...],
    ]
]

Output:
{
  [&quot;sku&quot;] =&gt;
  {
    [&quot;repetition_levels&quot;] =&gt; { [0] =&gt; int(0) [1] =&gt; int(1) }
    [&quot;definition_levels&quot;] =&gt; { [0] =&gt; int(1) [1] =&gt; int(1) }
    [&quot;values&quot;] =&gt; { [0] =&gt; string(3) &quot;abc&quot; [1] =&gt; string(3) &quot;def&quot; }
  }
}</code>
    </pre>
    <p>
        Also speichern wir in Wirklichkeit <code>0, 1, 0, 1, "abc", "def"</code> und nicht nur <code>"abc", "def"</code>. <br/>
        Genau diese zusÃ¤tzlichen Zahlen sagen uns, wie beliebige verschachtelte Strukturen rekonstruiert werden kÃ¶nnen.
    </p>
    <p>
        Interessant ist, dass sogar Repetition Levels und Definition Levels zur Optimierung frÃ¼h entsprechend mit dem Algorithmus
        <a href="https://parquet.apache.org/docs/file-format/data-pages/encodings/#RLE" target="_blank">Run Length Encoding / Bit-Packing Hybrid</a> gepackt werden.
    </p>
    <p>
        Das ist noch nicht alles, denn nicht nur die Ebenen werden gepackt, sondern auch die Werte selbst.<br/>
        Je nach Spaltentyp kÃ¶nnen Werte auf verschiedene Weise gepackt werden. Eine Liste aller von Parquet unterstÃ¼tzten Packungsalgorithmen (zumindest theoretisch) finden wir
        <a href="https://parquet.apache.org/docs/file-format/data-pages/encodings" target="_blank">in der offiziellen Dokumentation</a>.
    </p>
    <p>
        Informationen darÃ¼ber, welcher Algorithmus zum Packen der Daten vor dem Schreiben verwendet wurde, finden wir in den Metadaten unter dem Pfad <code>RowGroups[x].ColumnChunk[y].PageHeader[z].data_page_header.encoding</code>
    </p>
    <p>
        Das ist jedoch nicht Parquets letztes Wort im Kontext der Optimierung!
    </p>
    <a href="#compression"><h2 id="compression">Kompression</h2></a>
    <p>
        Nach dem Packen und Speichern unserer Daten fÃ¼r eine bestimmte Seite in binÃ¤rer Form wird jede Seite zusÃ¤tzlich komprimiert.
    </p>
    <p>
        Je nach Implementierung erlaubt Parquet die Verwendung verschiedener Kompressionsalgorithmen:
    </p>
    <ul>
        <li>UNCOMPRESSED</li>
        <li>SNAPPY</li>
        <li>GZIP</li>
        <li>LZO</li>
        <li>BROTLI</li>
        <li>LZ4</li>
        <li>ZSTD</li>
        <li>LZ4_RAW</li>
    </ul>
    <p>
        Eine sehr beliebte Option ist <a href="https://github.com/google/snappy" target="_blank">Snappy</a>, die einen sehr guten Kompromiss zwischen Geschwindigkeit und Kompressionsgrad bietet.
    </p>
    <p>
        Tools wie <a href="https://spark.apache.org/" target="_blank">Apache Spark</a> verwenden es sogar standardmÃ¤ÃŸig.
    </p>
    <a href="#encryption"><h2 id="encryption">VerschlÃ¼sselung</h2></a>
    <p>
        Eine der letzten interessanten Funktionen, die ich besprechen mÃ¶chte, ist die VerschlÃ¼sselung!
    </p>
    <p>
        Ja, Parquet ermÃ¶glicht die VerschlÃ¼sselung von Daten, VerschlÃ¼sselung auf mehreren Ebenen.
    </p>
    <ul>
        <li>Metadaten - verschlÃ¼sselte Metadaten erschweren das Lesen des Dateiinhalts erheblich, machen es jedoch nicht unmÃ¶glich</li>
        <li>Daten - verschlÃ¼sselte Daten machen das Lesen praktisch unmÃ¶glich</li>
        <li>Spalten - besonders nÃ¼tzlich, wenn nur einige Spalten sensible Daten enthalten.</li>
        <li>Seiten</li>
    </ul>
    <div class="notice">
        <p>
            <strong>Hinweis:</strong> VerschlÃ¼sselung ist eine jener Funktionen, die ich in der <a href="https://flow-php.com/documentation/components/libs/parquet/">Implementierung fÃ¼r PHP</a> noch nicht abgedeckt habe<br/>
            Aus diesem Grund werde ich nicht ausfÃ¼hrlich darÃ¼ber schreiben. Sobald sich die Gelegenheit ergibt, diese FunktionalitÃ¤t zu implementieren, werde ich versuchen, den Artikel zu ergÃ¤nzen.
        </p>
    </div>
    <p>
        Die VerschlÃ¼sselung in Parquet basiert auf <a href="https://parquet.apache.org/docs/file-format/data-pages/encryption/" target="_blank">Parquet Modular Encryption</a> und nutzt
        <a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf" target="_blank">AES</a> zur DatenverschlÃ¼sselung.
    </p>
    <p>
        VerschlÃ¼sselung, besonders von ausgewÃ¤hlten Spalten, hebt Parquet auf ein hÃ¶heres Niveau der Datenspeicherung. <br/> Dadurch kÃ¶nnen wir relativ einfach, mit geringem Overhead,
        zusÃ¤tzlich Daten sichern, die wir in Parquet-Dateien speichern. <br/>
    </p>
    <p>
        Stellen wir uns vor, dass Parquet zur Speicherung von Kundendaten verwendet wird, wo die Spalten <code>email</code> und <code>phone</code> sensible Daten enthalten.<br/>
        In dieser Situation bietet es sich geradezu an, diese beiden Spalten zusÃ¤tzlich zu sichern. Selbst wenn es jemandem gelingt, physischen Zugang zur Datei zu erlangen, kann er ohne SchlÃ¼ssel die
        Daten trotzdem nicht lesen.
    </p>
    <a href="#summary"><h2 id="summary">Zusammenfassung</h2></a>
    <p>
        Das ist genau das Geheimnis von Parquet und der Weg zur Effizienz. Anstatt beliebige Daten in Textform zu speichern, geht Parquet mehrere Schritte weiter. <br/>
        ZunÃ¤chst wird ein Datenschema basierend auf einfachen, aber unglaublich flexiblen Typen erzwungen, die alle in binÃ¤rer Form dargestellt werden kÃ¶nnen.<br/>
        Dann wird die binÃ¤re Form entsprechend gepackt, um unnÃ¶tige Byte-Wiederholungen zu vermeiden, was am Ende noch zusÃ¤tzlich mit sehr effizienten Algorithmen komprimiert wird.<br/>
        Die Kirsche auf der Torte sind erweiterte und detaillierte Metadaten, die auf mehreren Ebenen verfÃ¼gbar sind und es ermÃ¶glichen, unnÃ¶tige Partitionen oder sogar ganze Dateien zu filtern, ohne deren Inhalt zu lesen.
    </p>
    <p>
        AuÃŸerdem kÃ¶nnen wir dank der entsprechenden logischen Unterteilung, Ã¼ber die wir volle Kontrolle haben (GrÃ¶ÃŸe von Gruppen und Seiten),
        entscheiden, was fÃ¼r uns wichtiger ist: Geschwindigkeit oder Speichereinsparung. Durchsuchen oder Lesen von Daten oder vielleicht
        Sicherheit, fÃ¼r die wir zusÃ¤tzliche VerschlÃ¼sselung verwenden werden?
    </p>
    <p>
        Parquet ist wirklich ein mÃ¤chtiges Tool, das in den richtigen HÃ¤nden die effiziente Speicherung und Durchsuchung
        riesiger Datenmengen ermÃ¶glicht.<br/>
    </p>
    <p>
        Wenn dieser Beitrag Sie dazu inspiriert hat, mit diesem fantastischen Datenformat zu experimentieren, lassen Sie es mich in den Kommentaren wissen!
    </p>
    <a href="#help"><h2 id="help">Hilfe</h2></a>
    <p>
        Wenn Sie Hilfe beim Aufbau eines zentralen Data Warehouse benÃ¶tigen, helfe ich Ihnen gerne.<br/>
        <a href="https://norbert.tech/consulting">Kontaktieren Sie mich</a>, und wir werden gemeinsam eine LÃ¶sung schaffen, die perfekt auf Ihre BedÃ¼rfnisse zugeschnitten ist.
    </p>
    <p>
        Ich lade Sie auch ein, den Server <a href="https://discord.gg/5dNXfQyACW" target="_blank">Discord - Flow PHP</a> zu besuchen, wo
        wir direkt sprechen kÃ¶nnen.
    </p>
    <div class="img-wide">
        <img src="https://norbert.tech/assets/images/blog/analytics-in-transactional-distributed-systems/consulting_01-fa277dfb3736a033cbfcf1ac931afb08.jpg" alt="Beratung" />
    </div>

    </article>
    <div class="mb-2 mx-auto max-w-screen-lg text-center">
        <script src="https://giscus.app/client.js"
                data-repo="norberttech/norbert.tech"
                data-repo-id="MDEwOlJlcG9zaXRvcnkyMjQ0MDQwNDA="
                data-category="Comments"
                data-category-id="DIC_kwDODWAiSM4CionD"
                data-mapping="pathname"
                data-strict="0"
                data-reactions-enabled="0"
                data-emit-metadata="0"
                data-input-position="bottom"
                data-theme="light"
                data-lang="en"
                crossorigin="anonymous"
                async>
        </script>
    </div>
    </main>

    <footer class="p-4 bg-sky-50 absolute bottom-0 w-full">
        <div class="mx-auto max-w-screen-2xl text-center">
            <a href="/">by @norbert_tech</a>
        </div>
    </footer>
</body>
</html>