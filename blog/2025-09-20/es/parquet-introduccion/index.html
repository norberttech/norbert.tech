<!doctype html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Parquet - IntroducciÃ³n</title>
    <meta property="og:title" content="Parquet - IntroducciÃ³n" />
    <meta name="twitter:title" content="Parquet - IntroducciÃ³n" >

    <meta name="description" content="GuÃ­a completa de Apache Parquet - el formato de archivos binario y columnar. Aprende cÃ³mo lograr archivos 10x mÃ¡s pequeÃ±os, utilizar metadatos para filtrado ultrarrÃ¡pido, comprender la estructura de Row Groups y Data Pages, y conocer funciones avanzadas como cifrado y algoritmos Dremel.">
    <meta property="og:description" content="GuÃ­a completa de Apache Parquet - el formato de archivos binario y columnar. Aprende cÃ³mo lograr archivos 10x mÃ¡s pequeÃ±os, utilizar metadatos para filtrado ultrarrÃ¡pido, comprender la estructura de Row Groups y Data Pages, y conocer funciones avanzadas como cifrado y algoritmos Dremel.">
    <meta name="twitter:description" content="GuÃ­a completa de Apache Parquet - el formato de archivos binario y columnar. Aprende cÃ³mo lograr archivos 10x mÃ¡s pequeÃ±os, utilizar metadatos para filtrado ultrarrÃ¡pido, comprender la estructura de Row Groups y Data Pages, y conocer funciones avanzadas como cifrado y algoritmos Dremel.">

    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://norbert.tech/blog/2025-09-20/es/parquet-introduccion" />
                <meta property="og:image" content="https://norbert.tech/assets/images/blog/parquet-introduction/parquet-026fc09c95c7c7b4728c30bb85593777.jpg" />
                    
    <meta name="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://norbert.tech/blog/2025-09-20/es/parquet-introduccion" />
    <meta name="twitter:image" content="https://norbert.tech/assets/images/avatar-8f3c52c37f20d07c5e1631e1512bdeca.jpeg">
    <meta name="twitter:site" content="@norbert_tech" />
    <meta name="twitter:creator" content="@norbert_tech" />

    <link rel="apple-touch-icon" sizes="180x180" href="https://norbert.tech/assets/images/favicons/apple-touch-icon-9cae7ee880b4fe0bd755d300e1bca71e.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://norbert.tech/assets/images/favicons/favicon-32x32-b7a4ad4b584ab95534144e071f0e8587.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://norbert.tech/assets/images/favicons/favicon-16x16-154ca21abc06ae116c8d7ffc5713c000.png">
    <link rel="shortcut icon" href="https://norbert.tech/assets/images/favicons/favicon-db409885df78dea389e6d0b036da382c.ico">

            <style>
            @import url('https://fonts.googleapis.com/css2?family=Cabin:ital,wght@0,400..700;1,400..700&display=swap');
        </style>
        <link rel="stylesheet" href="https://norbert.tech/assets/styles/app-ff31265a811feebd3b3b45d8dc315d8b.css">
    
            
<script type="importmap">
{
    "imports": {
        "app": "https://norbert.tech/assets/app-930adf3462cf9ab60908eb1b74cf7ca7.js",
        "@oddbird/popover-polyfill": "https://norbert.tech/assets/vendor/@oddbird/popover-polyfill/popover-polyfill.index-7979d53637476aa204f709644aed2c19.js",
        "https://norbert.tech/assets/bootstrap.js": "https://norbert.tech/assets/bootstrap-d78d7e12c819dedf89372fb4824c072d.js",
        "htmx.org": "https://norbert.tech/assets/vendor/htmx.org/htmx.org.index-023ae86a082913526422a6063298f898.js",
        "iconify-icon": "https://norbert.tech/assets/vendor/iconify-icon/iconify-icon.index-8a41e423576dc2d752509fd455f508c1.js",
        "@symfony/stimulus-bundle": "https://norbert.tech/assets/@symfony/stimulus-bundle/loader-5751ad1ee2975e725a94d8121d153d17.js",
        "@hotwired/stimulus": "https://norbert.tech/assets/vendor/@hotwired/stimulus/stimulus.index-304681764684182e6662e0931532ed91.js",
        "https://norbert.tech/assets/@symfony/stimulus-bundle/controllers.js": "https://norbert.tech/assets/@symfony/stimulus-bundle/controllers-11c35dc7f11bbd855b8108888f18f9b7.js",
        "https://norbert.tech/assets/controllers/hello_controller.js": "https://norbert.tech/assets/controllers/hello_controller-55882fcad241d2bea50276ea485583bc.js",
        "https://norbert.tech/assets/controllers/syntax_highlight_controller.js": "https://norbert.tech/assets/controllers/syntax_highlight_controller-ae10e4cee8b4dedbf232536d05654062.js",
        "https://norbert.tech/assets/controllers/clipboard_controller.js": "https://norbert.tech/assets/controllers/clipboard_controller-6aefa8a9dec3271dae2f05b464bf9204.js",
        "highlight.js/lib/core": "https://norbert.tech/assets/vendor/highlight.js/lib/core-760145ef158caabe84ca07686407d093.js",
        "highlight.js/lib/languages/php": "https://norbert.tech/assets/vendor/highlight.js/lib/languages/php-c0eb2105c14097e8a5a1e9a767e8ac95.js",
        "highlight.js/styles/github-dark.min.css": "data:application/javascript,document.head.appendChild%28Object.assign%28document.createElement%28%22link%22%29%2C%7Brel%3A%22stylesheet%22%2Chref%3A%22https%3A%2F%2Fnorbert.tech%2Fassets%2Fvendor%2Fhighlight.js%2Fstyles%2Fgithub-dark.min-4b46e20f66f76e35d6454ca4f09b57c3.css%22%7D%29%29",
        "@fontsource-variable/cabin/index.min.css": "data:application/javascript,document.head.appendChild%28Object.assign%28document.createElement%28%22link%22%29%2C%7Brel%3A%22stylesheet%22%2Chref%3A%22https%3A%2F%2Fnorbert.tech%2Fassets%2Fvendor%2F%40fontsource-variable%2Fcabin%2Findex.min-08e34691d22388e6974e6cb2bfbcbfd0.css%22%7D%29%29",
        "clipboard": "https://norbert.tech/assets/vendor/clipboard/clipboard.index-925566f98181665b5a61fea1bcd9033d.js",
        "highlight.js/lib/languages/shell": "https://norbert.tech/assets/vendor/highlight.js/lib/languages/shell-664215791af27581e04813723523a355.js",
        "highlight.js/lib/languages/json": "https://norbert.tech/assets/vendor/highlight.js/lib/languages/json-9ac51ad2a97f9ce56b2f309eb64d7b04.js",
        "highlight.js/lib/languages/twig": "https://norbert.tech/assets/vendor/highlight.js/lib/languages/twig-0f3c6d18c0368650898b432b7bcf672a.js",
        "highlight.js/lib/languages/sql": "https://norbert.tech/assets/vendor/highlight.js/lib/languages/sql-09f80640dd6fe9bed6ff4eb255b13f08.js",
        "highlight.js/lib/languages/javascript": "https://norbert.tech/assets/vendor/highlight.js/lib/languages/javascript-100f963be02a503f0531e497103ff398.js",
        "highlight.js/lib/languages/xml": "https://norbert.tech/assets/vendor/highlight.js/lib/languages/xml-a2295112e12d4d01f257d59e1cfa676d.js"
    }
}
</script>
<!-- ES Module Shims: Import maps polyfill for modules browsers without import maps support -->
<script async src="https://ga.jspm.io/npm:es-module-shims@1.10.0/dist/es-module-shims.js"></script>
<link rel="modulepreload" href="https://norbert.tech/assets/app-930adf3462cf9ab60908eb1b74cf7ca7.js">
<link rel="modulepreload" href="https://norbert.tech/assets/vendor/@oddbird/popover-polyfill/popover-polyfill.index-7979d53637476aa204f709644aed2c19.js">
<link rel="modulepreload" href="https://norbert.tech/assets/bootstrap-d78d7e12c819dedf89372fb4824c072d.js">
<link rel="modulepreload" href="https://norbert.tech/assets/vendor/htmx.org/htmx.org.index-023ae86a082913526422a6063298f898.js">
<link rel="modulepreload" href="https://norbert.tech/assets/vendor/iconify-icon/iconify-icon.index-8a41e423576dc2d752509fd455f508c1.js">
<link rel="modulepreload" href="https://norbert.tech/assets/@symfony/stimulus-bundle/loader-5751ad1ee2975e725a94d8121d153d17.js">
<link rel="modulepreload" href="https://norbert.tech/assets/vendor/@hotwired/stimulus/stimulus.index-304681764684182e6662e0931532ed91.js">
<link rel="modulepreload" href="https://norbert.tech/assets/@symfony/stimulus-bundle/controllers-11c35dc7f11bbd855b8108888f18f9b7.js">
<link rel="modulepreload" href="https://norbert.tech/assets/controllers/hello_controller-55882fcad241d2bea50276ea485583bc.js">
<script type="module">import 'app';</script>
                <script defer src="https://cloud.umami.is/script.js" data-website-id="9fed007d-d990-428b-b5d9-11c6ff55a3f1"></script>
    </head>
<body class="scroll-smooth text-black relative min-h-screen pb-16">
    <div class="sticky top-0 max-h-screen overflow-y-auto bg-white py-2 px-2 border-b border-gray-500 z-[9999] print:hidden">
        <div class="grid grid-cols-2 sm:mx-auto sm:max-w-screen-2xl md:px-4">
            <div class="text-left">
                <a href="/" class="text-lg">
                    norbert.tech
                </a>
            </div>
            <div class="text-right">
                <a href="/consulting" class="text-lg inline-flex items-center space-x-1 md:mr-4 mr-2">
                    <iconify-icon icon="lineicons:consulting" class="mr-1"></iconify-icon> Consulting
                </a>
                <a href="/blog" class="text-lg inline-flex items-center space-x-1">
                    <iconify-icon icon="ooui:articles-ltr" class="mr-1"></iconify-icon> Blog
                </a>
            </div>
        </div>
    </div>
    
    <main class="mx-auto max-w-screen-2xl mb-4 md:pt-4 px-4 lg:px-0">
            <div class="px-2 py-5 sm:px-4 md:px-8 lg:px-12 mx-auto max-w-4xl">
        <ul class="mt-2 pl-[20px] flex flex-wrap gap-2 sm:gap-4">
            <li>
                <a href="/blog" class="text-sm sm:text-base text-blue-500 hover:underline px-2 py-1 rounded">Go Back</a>
            </li>
                                                                <li>
                        <a href="/blog/2025-09-20/pl/parquet-wprowadzenie"
                           class="text-sm sm:text-lg px-2 py-1 rounded hover:opacity-80"
                           title="Polish">ğŸ‡µğŸ‡± Polish</a>
                    </li>
                                                                                <li>
                        <a href="/blog/2025-09-20/de/parquet-einfuehrung"
                           class="text-sm sm:text-lg px-2 py-1 rounded hover:opacity-80"
                           title="Deutsch">ğŸ‡©ğŸ‡ª Deutsch</a>
                    </li>
                                                                                <li>
                        <a href="/blog/2025-09-20/parquet-introduction"
                           class="text-sm sm:text-lg px-2 py-1 rounded hover:opacity-80"
                           title="English">ğŸ‡ºğŸ‡¸ English</a>
                    </li>
                                                                                <li>
                        <a href="/blog/2025-09-20/it/parquet-introduzione"
                           class="text-sm sm:text-lg px-2 py-1 rounded hover:opacity-80"
                           title="Italian">ğŸ‡®ğŸ‡¹ Italian</a>
                    </li>
                                                                                <li>
                        <a href="/blog/2025-09-20/fr/parquet-introduction-fr"
                           class="text-sm sm:text-lg px-2 py-1 rounded hover:opacity-80"
                           title="French">ğŸ‡«ğŸ‡· French</a>
                    </li>
                                    </ul>

                    <div class="mt-4 p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
                <div class="flex items-start">
                    <div class="flex-shrink-0">
                        <svg class="h-5 w-5 text-yellow-400" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"/>
                        </svg>
                    </div>
                    <div class="ml-3">
                        <h3 class="font-medium text-yellow-800">
                            Translation Notice
                        </h3>
                        <div class="mt-2 text-yellow-700">
                            <p>
                                This is an automatically translated version of that Article. Despite my best efforts, it might not be perfect.<br/>
                                Native speakers are welcome to
                                <a href="https://github.com/norberttech/norbert.tech/edit/main/templates/blog/posts/2025-09-20/parquet-introduccion/post.html.twig"
                                   class="underline hover:text-yellow-800" target="_blank" rel="noopener">open pull requests
                                </a> to correct anything that doesn't sound right.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
            </div>
    <article class="blog-post">
            <div class="img-wide">
        <img src="https://norbert.tech/assets/images/blog/parquet-introduction/parquet-026fc09c95c7c7b4728c30bb85593777.jpg" alt="Parquet - IntroducciÃ³n" />
    </div>

    <h1 class="font-bold text-4xl mb-2" id="title">Parquet - IntroducciÃ³n</h1>
    <div class="mb-2">
        <small class="text-sm">Fecha de PublicaciÃ³n September 20, 2025 00:00</small>
    </div>
    <div class="mb-4">
                    <small><span class="badge badge-info">parquet</span></small>
                    <small><span class="badge badge-info">binario</span></small>
                    <small><span class="badge badge-info">columnar</span></small>
                    <small><span class="badge badge-info">formato de archivos</span></small>
                    <small><span class="badge badge-info">compresiÃ³n de datos</span></small>
                    <small><span class="badge badge-info">metadatos</span></small>
                    <small><span class="badge badge-info">cifrado</span></small>
                    <small><span class="badge badge-info">Apache Thrift</span></small>
                    <small><span class="badge badge-info">Flow PHP</span></small>
            </div>
    <p>
        Parquet, un formato de archivo binario y columnar creado para el almacenamiento y bÃºsqueda eficiente de datos.
    </p>
    <p>
        En internet hay montones de artÃ­culos sobre Parquet, entonces Â¿por quÃ© uno mÃ¡s?<br/>
        Esta es mi perspectiva sobre este fantÃ¡stico formato, que es bÃ¡sicamente el resultado de mi experiencia trabajando en
        escribir una implementaciÃ³n de Parquet en PHP puro.
    </p>
    <p>
        Para aquellos que llegaron aquÃ­ por casualidad, mencionarÃ© que soy el autor del primer framework de procesamiento
        de datos en PHP, llamado <a href="https://flow-php.com" target="_blank">Flow PHP</a>.<br/>
        Como corresponde a un Data Frame, Flow debe poder leer y escribir datos en varios formatos, incluyendo Parquet<br/>
    </p>
    <p>
        Sin embargo, como la Ãºnica implementaciÃ³n que encontrÃ© era bÃ¡sicamente un port directo de C#, que ademÃ¡s
        no maneja completamente las estructuras profundamente anidadas y tiene muchas funciones faltantes, decidÃ­
        como ejercicio de aprendizaje, escribir mi propia implementaciÃ³n desde cero, lo que resultÃ³ ser una experiencia extremadamente valiosa pero tambiÃ©n muy divertida.
    </p>
    <a href="#why-parquet"><h2 id="why-parquet">Por quÃ© Parquet</h2></a>
    <ul>
        <li><a href="#binary-format">Formato Binario - hasta 10x archivos mÃ¡s pequeÃ±os</a></li>
        <li><a href="#metadata">Metadatos - acceso mÃ¡s fÃ¡cil a datos seleccionados</a></li>
        <li><a href="#schema">Esquema - garantÃ­a de estructura correcta</a></li>
        <li><a href="#compression">CompresiÃ³n - reducciÃ³n adicional de tamaÃ±o</a></li>
        <li><a href="#encryption">Cifrado - a nivel de archivo, metadatos, columnas o pÃ¡ginas</a></li>
    </ul>

    <a href="#binary-format"><h2 id="binary-format">Formato Binario</h2></a>
    <p>
        Gracias a que este formato estÃ¡ orientado a columnas, no filas, permite una compresiÃ³n de datos muy eficiente,
        lo que se traduce en un tamaÃ±o de archivo significativamente menor. Sin mucho esfuerzo, Parquet puede comprimir datos hasta <strong>10 veces</strong>,
        comparado con formatos tradicionales como CSV o XML.
    </p>
    <p>
        Entonces, si los mismos datos guardados en formato CSV ocupan 1GB, en formato Parquet pueden ocupar solo 100MB.<br/>
    </p>

    <p>
        Para este artÃ­culo generÃ© 2 archivos, uno en formato CSV, otro en formato Parquet.<br/>
        La estructura de estos archivos es muy simple, contiene 10 columnas y 10 millones de filas, que se ven mÃ¡s o menos asÃ­:
    </p>
    <pre><code class="code-shell" data-controller="syntax-highlight">index,order_id,created_at,updated_at,discount,email,customer,address,notes,items
0,254d61c5-22c8-4407-83a2-76f1cab53af2,2025-01-01T12:00:00+00:00,2025-01-01T12:10:00+00:00,24.4,user-0@example.com,&quot;John Doe 0&quot;,&quot;{&quot;&quot;street&quot;&quot;:&quot;&quot;123 Main St, Apt 0&quot;&quot;,&quot;&quot;city&quot;&quot;:&quot;&quot;City &quot;&quot;,&quot;&quot;zip&quot;&quot;:&quot;&quot;12345-0&quot;&quot;,&quot;&quot;country&quot;&quot;:&quot;&quot;PL&quot;&quot;}&quot;,&quot;[&quot;&quot;Note 1 for order 0&quot;&quot;,&quot;&quot;Note 2 for order 0&quot;&quot;,&quot;&quot;Note 3 for order 0&quot;&quot;]&quot;,&quot;[{&quot;&quot;sku&quot;&quot;:&quot;&quot;SKU_0001&quot;&quot;,&quot;&quot;quantity&quot;&quot;:1,&quot;&quot;price&quot;&quot;:0.14},{&quot;&quot;sku&quot;&quot;:&quot;&quot;SKU_0002&quot;&quot;,&quot;&quot;quantity&quot;&quot;:2,&quot;&quot;price&quot;&quot;:25.13}]&quot;
1,254d61c5-22c8-4407-83a2-76f1cab53af2,2025-01-01T12:00:00+00:00,2025-01-01T12:10:00+00:00,24.4,user-1@example.com,&quot;John Doe 1&quot;,&quot;{&quot;&quot;street&quot;&quot;:&quot;&quot;123 Main St, Apt 1&quot;&quot;,&quot;&quot;city&quot;&quot;:&quot;&quot;City &quot;&quot;,&quot;&quot;zip&quot;&quot;:&quot;&quot;12345-1&quot;&quot;,&quot;&quot;country&quot;&quot;:&quot;&quot;PL&quot;&quot;}&quot;,&quot;[&quot;&quot;Note 1 for order 1&quot;&quot;,&quot;&quot;Note 2 for order 1&quot;&quot;,&quot;&quot;Note 3 for order 1&quot;&quot;]&quot;,&quot;[{&quot;&quot;sku&quot;&quot;:&quot;&quot;SKU_0001&quot;&quot;,&quot;&quot;quantity&quot;&quot;:1,&quot;&quot;price&quot;&quot;:0.14},{&quot;&quot;sku&quot;&quot;:&quot;&quot;SKU_0002&quot;&quot;,&quot;&quot;quantity&quot;&quot;:2,&quot;&quot;price&quot;&quot;:25.13}]&quot;
2,254d61c5-22c8-4407-83a2-76f1cab53af2,2025-01-01T12:00:00+00:00,,,user-2@example.com,&quot;John Doe 2&quot;,&quot;{&quot;&quot;street&quot;&quot;:&quot;&quot;123 Main St, Apt 2&quot;&quot;,&quot;&quot;city&quot;&quot;:&quot;&quot;City &quot;&quot;,&quot;&quot;zip&quot;&quot;:&quot;&quot;12345-2&quot;&quot;,&quot;&quot;country&quot;&quot;:&quot;&quot;PL&quot;&quot;}&quot;,&quot;[&quot;&quot;Note 1 for order 2&quot;&quot;,&quot;&quot;Note 2 for order 2&quot;&quot;,&quot;&quot;Note 3 for order 2&quot;&quot;]&quot;,&quot;[{&quot;&quot;sku&quot;&quot;:&quot;&quot;SKU_0001&quot;&quot;,&quot;&quot;quantity&quot;&quot;:1,&quot;&quot;price&quot;&quot;:0.14},{&quot;&quot;sku&quot;&quot;:&quot;&quot;SKU_0002&quot;&quot;,&quot;&quot;quantity&quot;&quot;:2,&quot;&quot;price&quot;&quot;:25.13}]&quot;
3,254d61c5-22c8-4407-83a2-76f1cab53af2,2025-01-01T12:00:00+00:00,,24.4,user-3@example.com,&quot;John Doe 3&quot;,&quot;{&quot;&quot;street&quot;&quot;:&quot;&quot;123 Main St, Apt 3&quot;&quot;,&quot;&quot;city&quot;&quot;:&quot;&quot;City &quot;&quot;,&quot;&quot;zip&quot;&quot;:&quot;&quot;12345-3&quot;&quot;,&quot;&quot;country&quot;&quot;:&quot;&quot;PL&quot;&quot;}&quot;,&quot;[&quot;&quot;Note 1 for order 3&quot;&quot;,&quot;&quot;Note 2 for order 3&quot;&quot;,&quot;&quot;Note 3 for order 3&quot;&quot;]&quot;,&quot;[{&quot;&quot;sku&quot;&quot;:&quot;&quot;SKU_0001&quot;&quot;,&quot;&quot;quantity&quot;&quot;:1,&quot;&quot;price&quot;&quot;:0.14},{&quot;&quot;sku&quot;&quot;:&quot;&quot;SKU_0002&quot;&quot;,&quot;&quot;quantity&quot;&quot;:2,&quot;&quot;price&quot;&quot;:25.13}]&quot;
</code></pre>

    <p>
        El efecto de compresiÃ³n es realmente impresionante:
    </p>

    <pre><code class="code-shell" data-controller="syntax-highlight">4.1G Sep 20 18:32 orders.csv
437M Sep 20 18:47 orders.parquet</code></pre>

    <p>
        Esto se traduce no solo en costos de almacenamiento, sino tambiÃ©n de procesamiento de datos.<br/>
        Especialmente cuando nuestros datos viven en la nube, ya sea en Azure Bucket o AWS S3. Uno de los mayores factores que afectan
        la factura no es el tamaÃ±o de los datos, sino cuÃ¡nto trÃ¡fico usamos para leer/escribir esos datos.
    </p>
    <p>
        AsÃ­ que reduciendo el tamaÃ±o del archivo, reducimos no solo el costo de almacenarlo, sino tambiÃ©n de procesarlo.
        Es importante entender que el procesamiento es realmente cualquier forma de acceso, es decir, escritura/lectura.
    </p>
    <p>
        Esto se reduce a que, eligiendo el formato de archivo apropiado, los ahorros pueden ser realmente significativos,
        especialmente cuando hablamos de mayores cantidades de datos.
    </p>
    <p>
        Â¿QuÃ© significa exactamente que Parquet es un formato binario?
    </p>
    <p>
        Significa mÃ¡s o menos que los datos se almacenan en forma binaria, es decir, de una manera que no se puede
        leer directamente usando editores de texto populares.
    </p>
    <p>
        Pero todo finalmente se almacena en forma binaria, Â¿no?
    </p>
    <p>
        SÃ­, generalmente los archivos de texto tambiÃ©n son archivos binarios, la diferencia es que en archivos de texto la estructura
        del archivo es siempre la misma y cada informaciÃ³n se guarda de la misma manera.
    </p>
    <p>
        Por ejemplo, si quisiÃ©ramos guardar "12345" en un archivo de texto, la versiÃ³n binaria se verÃ­a asÃ­:
    </p>
    <pre><code class="code-shell" data-controller="syntax-highlight">STRING: &quot;12345&quot;
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Character:   &#039;1&#039;       &#039;2&#039;      &#039;3&#039;      &#039;4&#039;     &#039;5&#039;      &#039;\0&#039;
ASCII:       49        50       51        52     53        0
Binary:    00110001 00110010 00110011 00110100 00110101 00000000
           â””â”€byteâ”€â”˜ â””â”€byteâ”€â”˜ â””â”€byteâ”€â”˜ â””â”€byteâ”€â”˜ â””â”€byteâ”€â”˜ â””â”€byteâ”€â”˜

Total: 6 bytes (including null terminator)</code></pre>
    <p>
        La misma cadena guardada en formato binario como int32 (entero en forma de 32 bits) se verÃ­a asÃ­:
    </p>
    <pre><code class="code-shell" data-controller="syntax-highlight">INTEGER: 12345
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Integer:     0         0       48       57
Binary:  00000000  00000000 00110000 00111001
         â””â”€byteâ”€â”˜  â””â”€byteâ”€â”˜ â””â”€byteâ”€â”˜ â””â”€byteâ”€â”˜

Total: 4 bytes for a 32-bit integer</code></pre>

    <p>
        Notemos que en el caso de guardar un entero en forma binaria, no se puede simplemente leer de izquierda a derecha (o viceversa).
        AquÃ­ ya debemos saber cÃ³mo interpretar esos bits para entender quÃ© significan.
        En el caso de archivos de texto no tenemos este problema, ya que sabemos que cada carÃ¡cter se guarda en forma de 8 bits.
    </p>
    <p>
        MÃ¡s o menos por eso cualquier editor de texto puede abrir cualquier archivo de texto y mostrarnos algo que tendrÃ¡ mÃ¡s o menos sentido.
    </p>
    <p>
        Sin embargo, si tratamos de abrir un archivo tipo Parquet en un editor de texto, obtendremos una cadena de caracteres que parece muy aleatoria y no tiene mucho sentido.
    </p>

    <a href="#columns-rows"><h2 id="columns-rows">Columnar / Por Filas</h2></a>
    <p>
        La mejor manera de explicar la diferencia entre estos formatos es con visualizaciÃ³n.
    </p>
    <p>
        En el modelo clÃ¡sico por filas cada fila contiene todas las columnas, como por ejemplo en formato CSV
    </p>

    <pre><code class="code-shell" data-controller="syntax-highlight">+------+------+------+
| Col1 | Col2 | Col3 |
+------+------+------+
|  A1  |  B1  |  C1  |
|  A2  |  B2  |  C2  |
|  A3  |  B3  |  C3  |
+------+------+------+
</code></pre>

    <p>
        El formato columnar es interesante porque en lugar de almacenar datos fila por fila, los almacena columna por columna.
    </p>

    <pre><code class="code-shell" data-controller="syntax-highlight">+------+------+------+------+
| Col1 |  A1  |  A2  |  A3  |
+------+------+------+------+
| Col2 |  B1  |  B2  |  B3  |
+------+------+------+------+
| Col3 |  C1  |  C2  |  C3  |
+------+------+------+------+
</code></pre>

    <p>
        Almacenar datos en formato columnar trae muchos beneficios, como:
    </p>
    <ul>
        <li>Mucho mejor capacidad de compresiÃ³n de datos</li>
        <li>Capacidad de leer solo columnas seleccionadas</li>
        <li>Capacidad de cifrar columnas seleccionadas o todas</li>
    </ul>

    <p>
        En el caso del formato por filas, para leer solo una columna, tenemos que revisar todo el archivo de todos modos.<br/>
        En el caso del formato columnar podemos leer solo las columnas que nos interesan.<br/>
        Esto es especialmente Ãºtil en el caso de conjuntos de datos muy grandes, donde a menudo necesitamos solo parte de la informaciÃ³n.
    </p>


    <a href="#immutable"><h2 id="immutable">Inmutable</h2></a>
    <p>
        Debido a la forma en que los datos se almacenan en formato columnar, los archivos Parquet son inmutables.<br/>
        Esto no significa que no se puedan modificar. Se puede, pero la Ãºnica operaciÃ³n sensata es agregar datos al final.
    </p>
    <p>
        Â¿Por quÃ©? Parquet almacena datos en formato columnar, lo que significa que si tenemos una columna <code>email</code>
        todas las filas (en un grupo de filas y pÃ¡gina dados - de esto mÃ¡s adelante) estarÃ¡n escritas una tras otra. </br>
        Intentar modificar una fila es por tanto imposible, porque requerirÃ­a mover prÃ¡cticamente todo el archivo.
    </p>
    <p>
        Sin embargo, es posible agregar un nuevo grupo de filas al final del archivo. Esto se hace removiendo metadatos del final del archivo,
        que temporalmente van a la memoria. En su lugar se escribe el nuevo grupo de filas (que tambiÃ©n debe agregarse a los metadatos),
        y luego al final se escriben los metadatos nuevamente.
    </p>
    <p>
        Por esta razÃ³n, si queremos eliminar algo de un archivo Parquet, en la prÃ¡ctica tenemos que reescribir todo el archivo, omitiendo
        los datos no deseados.
    </p>

    <a href="#metadata"><h2 id="metadata">Estructura Fuerte</h2></a>
    <p>
        Parquet es un formato basado en tipado fuerte. Esto significa que la estructura de todo el archivo estÃ¡ definida y almacenada en el pie de pÃ¡gina,
        gracias a lo cual es suficiente leer solo el segmento apropiado para entender quÃ© datos tenemos en el archivo, y en quÃ©
        regiones del archivo estÃ¡n guardados esos datos.
    </p>
    <p>
        Podemos pensar en esto como un mapa del archivo, un mapa que nos dirÃ¡ dÃ³nde exactamente en el archivo estÃ¡n
        los datos que nos interesan.
    </p>
    <p>
        AsÃ­ es mÃ¡s o menos como se ve la estructura simplificada de un archivo en formato Parquet:
    </p>
    <pre><code class="code-shell" data-controller="syntax-highlight">+-----------------+
| PAR1            |
+-----------------+
| Data            |
| .............   |
| .............   |
+-----------------+
| File Metadata   |
+-----------------+
| PAR1            |
+-----------------+</code></pre>

    <p>
        En el ejemplo anterior vemos 3 elementos:
    </p>

    <ul>
        <li><code>PAR1</code> - es decir, "Parquet Magic Bytes" - 4 bytes que abren y cierran archivos en formato Parquet</li>
        <li><code>Data</code> - aquÃ­ se guardan todas las columnas (de esto mÃ¡s adelante)</li>
        <li><code>Metadata</code> - metadatos, es decir, el mapa del archivo</li>
    </ul>

    <p>
        El primer paso para leer correctamente un archivo Parquet es verificar si los primeros 4 bytes son <code>PAR1</code>.<br/>
        Si es asÃ­, debemos saltar al final del archivo (seek) y leer los Ãºltimos 4 bytes.
    </p>
    <p>
        Si el final y el comienzo del archivo contienen <code>PAR1</code> podemos proceder a leer los metadatos.
    </p>
    <p>
        Para esto retrocedemos 8 bytes desde el final del archivo y leemos 4 bytes representando el tamaÃ±o de los metadatos.
        En otras palabras, leemos los bytes <code>-8</code> a <code>-4</code>
    </p>
    <p>
        Esos 4 bytes son un <code>integer</code> que nos dice en cuÃ¡ntos bytes estÃ¡n escritos los metadatos. Teniendo
        esta informaciÃ³n podemos leer los metadatos, que estÃ¡n serializados de forma binaria usando <a href="https://thrift.apache.org/" target="_blank">Apache Thrift</a>
    </p>
    <a href="#apache-thrift"><h2 id="apache-thrift">Apache Thrift</h2></a>
    <p>
        Apache Thrift es una herramienta muy inteligente que permite la serializaciÃ³n binaria de interfaces/tipos en prÃ¡cticamente cualquier
        lenguaje de programaciÃ³n.
    </p>
    <p>
        <a href="https://github.com/flow-php/flow/blob/1.x/src/lib/parquet/src/Flow/Parquet/Resources/Thrift/parquet_clean.thrift" target="_blank">AquÃ­</a>
        podemos ver cÃ³mo se ve la definiciÃ³n de metadatos en formato Parquet.
    </p>
    <p>
        Este formato se parece un poco a pseudocÃ³digo, que luego usando la aplicaciÃ³n apropiada se usa para generar
        cÃ³digo en un lenguaje de programaciÃ³n dado.
    </p>
    <p>
        <a href="https://github.com/flow-php/flow/tree/1.x/src/lib/parquet/src/Flow/Parquet/Thrift" target="_blank">AquÃ­</a>
        podemos ver cÃ³mo se ve el cÃ³digo generado en PHP.
    </p>
    <p>
        Cuando ya tenemos las estructuras/interfaces/modelos generados podemos proceder a la lectura.
    </p>

    <pre><code class="code-php" data-controller="syntax-highlight">&lt;?php

use Flow\Parquet\Thrift\FileMetaData;
use Thrift\Protocol\TCompactProtocol;
use Thrift\Transport\TMemoryBuffer;

$metadataLength = \unpack($this-&gt;byteOrder-&gt;value, $this-&gt;stream-&gt;read(4, $fileTotalSize - 8))[1];

$fileMetadata = new FileMetaData();
$fileMetadata-&gt;read(
    new TCompactProtocol(
        new TMemoryBuffer(
            $this-&gt;stream-&gt;read($metadataLength, $fileTotalSize - ($metadataLength + 8))
        )
    )
);</code></pre>

    <p>
        Para esto necesitaremos la biblioteca Thrift para el lenguaje de programaciÃ³n elegido.
        Todas las implementaciones estÃ¡n disponibles en el repositorio <a href="https://github.com/apache/thrift" target="_blank">apache/thrift</a>.
    </p>

    <p>
        Teniendo acceso a <code>$metadata</code> podemos comenzar a analizar nuestro archivo para entender su estructura.<br/>
    </p>

    <a href="#parquet-file-metadata"><h2 id="parquet-file-metadata">Parquet - FileMetaData</h2></a>

    <pre><code class="code-shell" data-controller="syntax-highlight">struct FileMetaData {
  1: required i32 version
  2: required list&lt;SchemaElement&gt; schema;
  3: required i64 num_rows
  4: required list&lt;RowGroup&gt; row_groups
  5: optional list&lt;KeyValue&gt; key_value_metadata
  6: optional string created_by
  7: optional list&lt;ColumnOrder&gt; column_orders;
  8: optional EncryptionAlgorithm encryption_algorithm
  9: optional binary footer_signing_key_metadata
}</code></pre>

    <p>
        La informaciÃ³n clave sobre el archivo se almacena en la estructura <code>FileMetaData</code>.
        Las mÃ¡s importantes de ellas son:
    </p>
    <ul>
        <li><code>version</code> - versiÃ³n del formato Parquet</li>
        <li><code>num_rows</code> - nÃºmero de filas en el archivo</li>
        <li><code>schema</code> - esquema de datos</li>
        <li><code>row_groups</code> - aquÃ­ se almacenan nuestros datos</li>
    </ul>

    <a href="#format-versions"><h2 id="format-versions">Versiones del Formato</h2></a>
    <p>
        Al momento de escribir este artÃ­culo el formato Parquet ya estaba disponible en versiÃ³n <code>2.12.0</code>.
    </p>
    <p>
        Los cambios mÃ¡s cruciales entre las versiones 1.0 y 2.0 son:
    </p>
    <ul>
        <li><strong>Nuevos esquemas de codificaciÃ³n:</strong> DELTA_BINARY_PACKED para nÃºmeros, DELTA_BYTE_ARRAY para strings, RLE_DICTIONARY reemplazando PLAIN_DICTIONARY</li>
        <li><strong>Estructura Data Page V2:</strong> EliminÃ³ la sobrecarga de metadatos, permitiÃ³ filtrado a nivel de pÃ¡gina</li>
    </ul>
    <p>
        Aunque la versiÃ³n 2.0 introduce muchas mejoras, los jugadores mÃ¡s grandes aÃºn usan la versiÃ³n 1 por defecto.
    </p>
    <a href="#rows-count"><h2 id="rows-count">NÃºmero de Filas</h2></a>
    <p>
        Esta informaciÃ³n puede parecer poco intuitiva al principio en el contexto del formato columnar.<br/>
        Sin embargo, debemos recordar que el formato columnar es solo una forma de almacenar valores, no la estructura de datos.
    </p>
    <p>
        A pesar de que los datos estÃ¡n agrupados por columnas y su tipo, la lectura/escritura aÃºn ocurre de manera clÃ¡sica,
        es decir, fila por fila.
    </p>
    <p>
        La diferencia es que no leemos una fila a la vez, sino todo un grupo de filas, cargando en memoria
        columna por columna, y luego reconstruyendo las filas basÃ¡ndose en los Ã­ndices apropiados.
    </p>
    <div class="notice">
        <p>
        Recordando que para escribir datos apropiadamente en formato columnar debemos operar en grupos lÃ³gicos, no en filas individuales.
        Podemos de manera relativamente fÃ¡cil gestionar la relaciÃ³n entre memoria y cantidad de operaciones IO.
        </p>
    </div>
    <p>
        La escritura y lectura desde memoria es mÃ¡s rÃ¡pida que la escritura y lectura desde disco (<a href="https://www.bitflux.ai/blog/memory-is-slow-part1/" target="_blank">aunque no siempre</a>).
        Aumentando la cantidad de filas que se escribirÃ¡n en un grupo, reducimos el nÃºmero de grupos, es decir, el nÃºmero de operaciones IO. <br/>
        AsÃ­ aumentamos la velocidad de escritura/lectura, a la vez que aumentamos el uso de memoria.
    </p>
    <p>
        Esto tambiÃ©n funciona al revÃ©s, reduciendo la cantidad de filas en un grupo, aumentamos el nÃºmero de grupos en el archivo, asÃ­
        aumentando el nÃºmero de operaciones IO.
    </p>
    <p>
        <strong>TamaÃ±o del grupo, no cantidad de filas</strong> - Parquet permite definir no la cantidad de filas, sino el tamaÃ±o mÃ¡ximo
        del grupo de filas. <br/>
        Sin embargo, hay que recordar que estos no son valores absolutos (de esto un poco mÃ¡s adelante), entonces
        algunos grupos pueden ser mÃ¡s pequeÃ±os/grandes que el tamaÃ±o permitido y esto depende principalmente de la implementaciÃ³n de la biblioteca
        de Parquet.
    </p>
    <p>
        En la documentaciÃ³n del formato Parquet encontraremos informaciÃ³n de que el tamaÃ±o sugerido del grupo es <code>512Mb - 1Gb</code>.
        Sin embargo, vale la pena abordar esto con un poco de sentido comÃºn, especialmente si para lectura/escritura no dependemos de HDFS (Hadoop Distributed File System). <br/>
        El valor sugerido se establece de tal manera que un grupo de filas quepa en un bloque HDFS, garantizando que la lectura
        ocurra desde exactamente un nodo.
    </p>
    <p>
        Vale la pena recordar esto, sin embargo, si no planeamos usar Parquet con un sistema de archivos distribuido, grupos de filas mÃ¡s pequeÃ±os
        permitirÃ¡n ahorrar bastante memoria.
    </p>
    <p>
        Un muy buen ejemplo de cuÃ¡ndo los grupos mÃ¡s pequeÃ±os son mÃ¡s eficientes es el caso donde quisiÃ©ramos leer
        solo una pequeÃ±a secciÃ³n de filas desde el medio del archivo (paginaciÃ³n).
    </p>
    <p>
        Asumiendo que necesitamos leer solo 100 filas de un archivo que contiene 10 millones de filas, establecer un tamaÃ±o de grupo mÃ¡s pequeÃ±o
        permitirÃ¡ ahorrar mucho en memoria. Â¿Por quÃ©?
    </p>
    <p>
        Si dividimos 10 millones en digamos 10 grupos, cada grupo contiene 1 millÃ³n de filas. Esto significa que en la prÃ¡ctica
        debemos leer todo el grupo, y luego extraer solo las 100 filas que nos interesan.
    </p>
    <p>
        En el caso de establecer un tamaÃ±o de grupo mÃ¡s pequeÃ±o, que permita dividir 10 millones en 1000 grupos, analizando
        los metadatos del archivo, podremos saltar una mayor cantidad de grupos y cargar en memoria una cantidad mucho menor de filas.
    </p>
    <div class="notice">
        <p>
            La decisiÃ³n sobre el tamaÃ±o del grupo de filas debe ser considerada tanto para el rendimiento de escritura como de lectura
            del archivo especÃ­fico. La configuraciÃ³n apropiada se traduce directamente en el uso de recursos lo que finalmente se traduce
            en dinero.
        </p>
    </div>

    <a href="#schema"><h2 id="schema">Esquema</h2></a>

    <p>
        Lentamente llegamos al nÃºcleo de Parquet, es decir, <code>Row Groups</code>. Pero antes de analizar su estructura, debemos
        volver a otro aspecto muy importante de Parquet, el esquema de datos.
    </p>

    <p>
        Comencemos con los tipos de datos. Parquet consiste en tipos fÃ­sicos y lÃ³gicos.
    </p>

    <h3>Tipos FÃ­sicos</h3>

    <p>
        Los tipos fÃ­sicos son los tipos de datos bÃ¡sicos que se usan para almacenar valores en el archivo Parquet.
        Son tipos como:
    </p>

    <ul>
        <li>Boolean</li>
        <li>Byte Array</li>
        <li>Double</li>
        <li>Fixed Len Byte Array</li>
        <li>Float</li>
        <li>Int32</li>
        <li>Int64</li>
        <li>Int96 - (deprecado - usado solo por implementaciones mÃ¡s antiguas)</li>
    </ul>

    <p>
        Los tipos lÃ³gicos son tipos que se usan para representar estructuras de datos mÃ¡s complejas. Se puede
        pensar en ellos como una extensiÃ³n de los tipos fÃ­sicos.
    </p>

    <h3>Tipos LÃ³gicos</h3>

    <ul>
        <li>Bson</li>
        <li>Date</li>
        <li>Decimal</li>
        <li>Enum</li>
        <li>Integer</li>
        <li>Json</li>
        <li>List</li>
        <li>Map</li>
        <li>String</li>
        <li>Time</li>
        <li>Timestamp</li>
        <li>Uuid</li>
    </ul>

    <p>
        La estructura actual siempre se puede verificar en la fuente, <a href="https://github.com/apache/parquet-format/blob/master/src/main/thrift/parquet.thrift" target="_blank">apache/parquet-format</a>
    </p>

    <p>
        AdemÃ¡s de la divisiÃ³n en tipos lÃ³gicos y fÃ­sicos, Parquet tambiÃ©n distingue columnas planas y anidadas.<br/>
        <strong>Columnas planas</strong> son aquellas que almacenan un solo valor, por ejemplo, <code>Int32</code>, <code>Boolean</code>, <code>Float</code>, etc.<br/>
        <strong>Columnas anidadas</strong> son aquellas que almacenan mÃ¡s de un valor, por ejemplo, <code>List</code>, <code>Map</code>, etc.
    </p>

    <p>
        En principio existen 3 tipos de columnas anidadas:
    </p>
    <ul>
        <li>List</li>
        <li>Map</li>
        <li>Struct</li>
    </ul>
    <p>
        <strong>Struct</strong>, es un tipo especial de columna que permite anidar cualquier otro tipo, permitiendo crear
        prÃ¡cticamente cualquier estructura de datos.
    </p>
    <p>
        Usando los tipos anteriores podemos modelar prÃ¡cticamente cualquier
        estructura de datos, y luego almacenarla y buscarla eficientemente.
    </p>
    <p>
        Veamos entonces las definiciones Thrift <code>SchemaElement</code> y algunos elementos relacionados.
    </p>

    <pre><code class="code-shell" data-controller="syntax-highlight">struct SchemaElement {
  1: optional Type type;
  2: optional i32 type_length;
  3: optional FieldRepetitionType repetition_type;
  4: required string name;
  5: optional i32 num_children;
  6: optional ConvertedType converted_type;
  7: optional i32 scale
  8: optional i32 precision
  9: optional i32 field_id;
  10: optional LogicalType logicalType
}

enum FieldRepetitionType {
  REQUIRED = 0;
  OPTIONAL = 1;
  REPEATED = 2;
}

enum Type {
  BOOLEAN = 0;
  INT32 = 1;
  INT64 = 2;
  INT96 = 3;
  FLOAT = 4;
  DOUBLE = 5;
  BYTE_ARRAY = 6;
  FIXED_LEN_BYTE_ARRAY = 7;
}

union LogicalType {
  1:  StringType STRING
  2:  MapType MAP
  3:  ListType LIST
  4:  EnumType ENUM
  5:  DecimalType DECIMAL
  6:  DateType DATE
  7:  TimeType TIME
  8:  TimestampType TIMESTAMP
  10: IntType INTEGER
  11: NullType UNKNOWN
  12: JsonType JSON
  13: BsonType BSON
  14: UUIDType UUID
}</code></pre>

    <p>
        La mayorÃ­a de valores deberÃ­a ser bastante obvia, pero veamos <code>FieldRepetitionType</code>.
    </p>

    <p>
        Este valor nos dice si una columna dada es requerida, opcional o repetible.<br/>
        Si una columna es requerida, significa que el valor no puede ser null. <br/>
        Si una columna es opcional el valor puede ser null, y si es repetible, significa que puede contener mÃºltiples valores (por ejemplo, una lista).
    </p>

    <p>
        AsÃ­ es como puede verse el esquema de un archivo de pedidos (en forma DDL)
    </p>

    <pre><code class="code-shell" data-controller="syntax-highlight">message orders_scheme {
    required fixed_len_byte_array(16) order_id (UUID)
    required int64 created_at (TIMESTAMP(MICROS,false))
    optional int64 updated_at (TIMESTAMP(MICROS,false))
    optional float discount
    required binary email (STRING)
    required binary customer (STRING)
    required group address {
          required binary street (STRING);
          required binary city (STRING);
          required binary zip (STRING);
          required binary country (STRING);
    }
    required group notes (LIST) {
          repeated group list {
                required binary element (STRING);
          }
    }
    required group items (LIST) {
          repeated group list {
                required group element {
                      required binary sku (STRING);
                      required int64 quantity (INTEGER(64,true));
                      required float price;
                }
          }
    }
}</code></pre>

    <a href="#nested-types"><h2 id="nested-types">Tipos Anidados</h2></a>

    <p>
        Para entender completamente la estructura de grupos de filas primero debemos entender cÃ³mo Parquet aplana los tipos anidados.<br/>
        Mientras que estructuras simples como <code>address</code> del ejemplo anterior se pueden reducir bÃ¡sicamente a 4 columnas simples:
    </p>
    <ul>
        <li><code>address.street</code> - String</li>
        <li><code>address.city</code> - String</li>
        <li><code>address.zip</code> - String</li>
        <li><code>address.country</code> - String</li>
    </ul>
    <p>
        En el caso de <code>Map</code> o <code>List</code> la situaciÃ³n es un poco mÃ¡s complicada.
    </p>
    <p>
        Por ejemplo, si quisiÃ©ramos aplanar <code>Map&lt;string,int32&gt;</code> obtendrÃ­amos algo asÃ­:
    </p>
    <ul>
        <li><code>map_column.key_value.key</code> - String</li>
        <li><code>map_column.key_value.value</code> - Int32</li>
    </ul>
    <p>
        AsÃ­ que para el ejemplo anterior la ruta plana a <code>sku</code> se verÃ­a asÃ­:
        <code>items.list.element.sku</code>, mientras que la estructura plana completa se verÃ­a asÃ­:
    </p>
    <pre><code class="code-shell" data-controller="syntax-highlight">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Columns â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ path                        â”‚ type                     â”‚ logical type â”‚ repetition â”‚ max repetition â”‚ max definition â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ order_id                    â”‚ FIXED_LEN_BYTE_ARRAY(16) â”‚ UUID         â”‚ REQUIRED   â”‚ 0              â”‚ 0              â”‚
â”‚ created_at                  â”‚ INT64                    â”‚ TIMESTAMP    â”‚ REQUIRED   â”‚ 0              â”‚ 0              â”‚
â”‚ updated_at                  â”‚ INT64                    â”‚ TIMESTAMP    â”‚ OPTIONAL   â”‚ 0              â”‚ 1              â”‚
â”‚ discount                    â”‚ FLOAT                    â”‚ -            â”‚ OPTIONAL   â”‚ 0              â”‚ 1              â”‚
â”‚ email                       â”‚ BYTE_ARRAY               â”‚ STRING       â”‚ REQUIRED   â”‚ 0              â”‚ 0              â”‚
â”‚ customer                    â”‚ BYTE_ARRAY               â”‚ STRING       â”‚ REQUIRED   â”‚ 0              â”‚ 0              â”‚
â”‚ address.street              â”‚ BYTE_ARRAY               â”‚ STRING       â”‚ REQUIRED   â”‚ 0              â”‚ 0              â”‚
â”‚ address.city                â”‚ BYTE_ARRAY               â”‚ STRING       â”‚ REQUIRED   â”‚ 0              â”‚ 0              â”‚
â”‚ address.zip                 â”‚ BYTE_ARRAY               â”‚ STRING       â”‚ REQUIRED   â”‚ 0              â”‚ 0              â”‚
â”‚ address.country             â”‚ BYTE_ARRAY               â”‚ STRING       â”‚ REQUIRED   â”‚ 0              â”‚ 0              â”‚
â”‚ notes.list.element          â”‚ BYTE_ARRAY               â”‚ STRING       â”‚ REQUIRED   â”‚ 1              â”‚ 1              â”‚
â”‚ items.list.element.sku      â”‚ BYTE_ARRAY               â”‚ STRING       â”‚ REQUIRED   â”‚ 1              â”‚ 1              â”‚
â”‚ items.list.element.quantity â”‚ INT64                    â”‚ -            â”‚ REQUIRED   â”‚ 1              â”‚ 1              â”‚
â”‚ items.list.element.price    â”‚ FLOAT                    â”‚ -            â”‚ REQUIRED   â”‚ 1              â”‚ 1              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>

    <a href="#row-groups"><h2 id="row-groups">Grupos de Filas</h2></a>

    <pre><code class="code-shell" data-controller="syntax-highlight">+-----------------------------------+
| PAR1                              |
+-----------------------------------+
| Row Group 1                       |
|   +-----------------------------+ |
|   | Column Chunk 1              | |
|   |   (Metadata + Data Pages)   | |
|   +-----------------------------+ |
|   | Column Chunk 2              | |
|   |   (Metadata + Data Pages)   | |
|   +-----------------------------+ |
|   ...                             |
+-----------------------------------+
| Row Group 2                       |
|   +-----------------------------+ |
|   | Column Chunk 1              | |
|   |   (Metadata + Data Pages)   | |
|   +-----------------------------+ |
|   | Column Chunk 2              | |
|   |   (Metadata + Data Pages)   | |
|   +-----------------------------+ |
|   ...                             |
+-----------------------------------+
| ...                               |
+-----------------------------------+
| Metadata                          |
+-----------------------------------+
| PAR1                              |
+-----------------------------------+</code></pre>

    <p>
        De acuerdo con lo que ya sabemos, un archivo Parquet estÃ¡ dividido en grupos de filas, la escritura al archivo en resumen funciona asÃ­:
    </p>
    <ul>
        <li>1) crear archivo y agregar 4 bytes <code>PAR1</code></li>
        <li>2) crear estructura de metadatos basada en el esquema y mantenerla en memoria</li>
        <li>3) aplanar la fila pasada (verificando si coincide con el esquema)</li>
        <li>4) escribir la fila aplanada en memoria en forma binaria</li>
        <li>
            5) verificar si el tamaÃ±o del grupo de filas que actualmente tenemos en memoria cabe en el tamaÃ±o mÃ¡ximo permitido
            <ul>
                <li>a) escribir grupo de filas al archivo</li>
                <li>b) actualizar metadatos en memoria agregÃ¡ndoles metadatos del grupo que acabamos de escribir</li>
            </ul>
        </li>
        <li>
            6) volver al paso 2
        </li>
        <li>
            7) Escribir metadatos al final del archivo despuÃ©s de escribir todos los grupos de filas
        </li>
        <li>
            8) Cerrar archivo con 4 bytes <code>PAR1</code>
        </li>
    </ul>
    <div class="notice">
        <p>
            Por supuesto esta descripciÃ³n estÃ¡ muy simplificada, en realidad es un poco mÃ¡s compleja, ademÃ¡s diferentes implementaciones
            pueden diferir en detalles.
        </p>
    </div>

    <p>
        EnfoquÃ©monos en la estructura del grupo de filas, veamos primero las definiciones Thrift <code>RowGroup</code>.
    </p>

    <pre><code class="code-shell" data-controller="syntax-highlight">struct RowGroup {
  1: required list&lt;ColumnChunk&gt; columns
  2: required i64 total_byte_size
  3: required i64 num_rows
  4: optional list&lt;SortingColumn&gt; sorting_columns
  5: optional i64 file_offset
  6: optional i64 total_compressed_size
  7: optional i16 ordinal
}
</code></pre>

    <p>
        Ya en esta etapa se ve cuÃ¡nta informaciÃ³n sobre un grupo especÃ­fico de filas se almacena en los metadatos.<br/>
        Por ahora enfoquÃ©monos en tres campos:
    </p>
    <ul>
        <li><code>file_offset</code> - es decir, cuÃ¡ntos bytes desde el comienzo del archivo hay que saltar para leer el grupo dado</li>
        <li><code>total_byte_size</code> - en cuÃ¡ntos bytes estÃ¡ escrito el grupo de filas</li>
        <li><code>columns</code> - informaciÃ³n detallada sobre cada columna escrita dentro del grupo dado</li>
    </ul>

    <div class="important">
        <p>
            <strong>Importante:</strong> cada grupo de filas siempre contiene todas las columnas definidas en el esquema.<br/>
            Incluso si a lo largo de todo el grupo una columna contiene solo valores null.
        </p>
    </div>

    <a href="#column-chunks"><h2 id="column-chunks">Chunks de Columna</h2></a>

    <p>
        Profundicemos y miremos la definiciÃ³n Thrift <code>ColumnChunk</code>
    </p>
    <pre><code class="code-shell" data-controller="syntax-highlight">struct ColumnChunk {
  1: optional string file_path
  2: required i64 file_offset
  3: optional ColumnMetaData meta_data
  4: optional i64 offset_index_offset
  5: optional i32 offset_index_length
  6: optional i64 column_index_offset
  7: optional i32 column_index_length
  8: optional ColumnCryptoMetaData crypto_metadata
  9: optional binary encrypted_column_metadata
}

struct ColumnMetaData {
  1: required Type type
  2: required list&lt;Encoding&gt; encodings
  3: required list&lt;string&gt; path_in_schema
  4: required CompressionCodec codec
  5: required i64 num_values
  6: required i64 total_uncompressed_size
  7: required i64 total_compressed_size
  8: optional list&lt;KeyValue&gt; key_value_metadata
  9: required i64 data_page_offset
  10: optional i64 index_page_offset
  11: optional i64 dictionary_page_offset
  12: optional Statistics statistics;
  13: optional list&lt;PageEncodingStats&gt; encoding_stats;
  14: optional i64 bloom_filter_offset;
  15: optional i32 bloom_filter_length;
}
</code></pre>

    <div class="notice">
        <p>
            <strong>Recuerda:</strong> Todo lo que hemos visto hasta ahora sigue siendo parte de los metadatos. <br/>
            Esto significa que toda esta informaciÃ³n sobre columnas, grupos de filas o los datos mismos la obtenemos leyendo
            solo el final del archivo, independientemente de si el archivo tiene 1MB o 1TB.
        </p>
    </div>

    <p>
        AquÃ­ llegamos bÃ¡sicamente al lugar que nos permite leer datos del archivo. <br/>
        Pero antes de que esto suceda debemos conocer la Ãºltima estructura de datos necesaria para la lectura.
    </p>

    <a href="#data-pages"><h2 id="data-pages">PÃ¡ginas de Datos</h2></a>

    <p>
        <code>Pages</code>, es decir, otra divisiÃ³n lÃ³gica en la estructura del archivo Parquet.<br/>
        <code>Row Group -> Column Chunk -> Data Pages</code>
    </p>

    <ul>
        <li><code>RowGroup</code> - grupo de filas (particiÃ³n)</li>
        <li><code>ColumnChunk</code> - cada grupo de filas contiene exactamente 1 <code>ColumnChunk</code> para cada columna en el grupo</li>
        <li><code>Data Page</code> - pÃ¡gina, la unidad lÃ³gica mÃ¡s pequeÃ±a en Parquet que agrega datos</li>
    </ul>

    <p>
        En realidad, leer Parquet se reduce a analizar la estructura de metadatos, localizar la direcciÃ³n del comienzo de un grupo especÃ­fico de filas, luego
        una columna especÃ­fica en el grupo, y luego iterar y leer datos de cada pÃ¡gina.
    </p>

    <p>
        Pero antes de empezar a leer pÃ¡ginas, debemos entender si estamos lidiando con <code>DataPage</code>, <code>IndexPage</code> o <code>DictionaryPage</code>.
    </p>
    <p>
        Para esto primero leemos <code>PageHeader</code> es decir, el encabezado de la pÃ¡gina, cuya definiciÃ³n Thrift se ve asÃ­
    </p>

    <pre><code class="code-shell" data-controller="syntax-highlight">struct PageHeader {
  1: required PageType type
  2: required i32 uncompressed_page_size
  3: required i32 compressed_page_size
  4: optional i32 crc
  5: optional DataPageHeader data_page_header;
  6: optional IndexPageHeader index_page_header;
  7: optional DictionaryPageHeader dictionary_page_header;
  8: optional DataPageHeaderV2 data_page_header_v2;
}

enum PageType {
  DATA_PAGE = 0;
  INDEX_PAGE = 1;
  DICTIONARY_PAGE = 2;
  DATA_PAGE_V2 = 3;
}</code></pre>

    <p>
        Para leer el encabezado debemos conocer su direcciÃ³n relativa al comienzo del archivo, asÃ­ es como podemos calcularlo para un grupo de filas y columna seleccionados:
    </p>

    <ol>
        <li>Leemos <code>FileMetadata</code></li>
        <li>Encontramos el <code>RowGroup</code> apropiado y buscamos el <code>ColumnChunk</code> relevante para nosotros</li>
        <li>Teniendo <code>ColumnChunk</code> obtendremos la direcciÃ³n <code>file_offset</code> del comienzo de <code>ColumnChunk</code> relativa al comienzo del archivo.</li>
    </ol>

    <div class="important">
        <p>
            <strong>Importante:</strong> En esta etapa aÃºn no necesitamos cargar fÃ­sicamente los bytes en memoria.<br/>
            Es suficiente que creemos un <code>stream</code> que permita leer datos directamente del archivo.
        </p>
    </div>

    <p>
        Lo primero que hay que leer es el encabezado, <code>PageHeader</code>, haciÃ©ndolo usando Thrift, pasando
        el stream y estableciendo apropiadamente la direcciÃ³n del comienzo obtendremos la estructura de datos <code>PageHeader</code>, que nos dirÃ¡ exactamente cÃ³mo leer
        la pÃ¡gina misma.
    </p>
    <p>
        Existen 3 tipos de pÃ¡ginas:
    </p>
    <h3><code>DataPage</code></h3>
    <p>
        PÃ¡gina que contiene representaciÃ³n binaria de datos de la columna seleccionada de las filas que fueron al grupo de filas seleccionado.<br/>
        Es el tipo de pÃ¡gina mÃ¡s simple y directo. Contiene "solo" datos.
    </p>
    <p>
        Leyendo una columna tipo entero, lo que nos interesa es realmente el nÃºmero de filas en el grupo especÃ­fico (cada fila es un valor en <code>DataPage</code>).
        AsÃ­ que sabiendo que en este grupo tenemos digamos 100 valores, sabemos que tenemos que leer 400 bytes (int32 se escribe en 4 bytes). <br/>
    </p>
    <p>
        Bueno, pero Â¿quÃ© pasa cuando la columna es opcional? Eso significa que puede contener valores null.<br/>
        AquÃ­ la situaciÃ³n se vuelve un poco mÃ¡s complicada porque necesitamos saber quÃ© filas contienen valor null.<br/>
        Â¿De dÃ³nde viene este conocimiento?<br/>
        <code>Definition Levels</code>
    </p>
    <p>
        La situaciÃ³n se complica un poco, al principio escribÃ­ que <code>DataPage</code> contiene solo datos, y ahora agrego algunos <code>Definition Levels</code>.<br/>
    </p>
    <p>
        En realidad la estructura de data page se ve mÃ¡s o menos asÃ­:
    </p>
    <pre><code class="code-shell" data-controller="syntax-highlight">Parquet Data Page: int32
=======================================
[ Repetition Levels ]: 0, 0, 0, 0, 0
---------------------------------------
[ Definition Levels ]: 1, 0, 1, 1, 0
---------------------------------------
[ Values           ]: 42, 73, 19
=======================================
</code></pre>
    <p>
        Por ahora, enfoquÃ©monos solo en <code>Definition Levels</code> y <code>Values</code>. Es muy fÃ¡cil notar la relaciÃ³n entre ellos.
        La cantidad de <code>Definition Level</code> y <code>Repetition Levels</code> en cada pÃ¡gina siempre es igual a la cantidad de valores en la columna.<br/>
        Sin importar si hay nulls o no. <code>Definition Levels</code> nos dicen si una fila dada contiene un valor o null.
    </p>
    <p>
        En base a esto, podemos determinar fÃ¡cilmente la cantidad total de <code>Values</code> no vacÃ­os lo que nos permitirÃ¡ leerlos. <br/>
        En el ejemplo anterior tenemos 5 filas, de las cuales 3 constituyen valores, ya que <code>int32</code> lo escribimos en 4 bytes,
        ya sabemos que tenemos que leer en total 12 bytes.<br/>
        TambiÃ©n sabemos que al transformar la columna en filas, la primera fila contendrÃ¡ el valor <code>42</code>, la segunda <code>null</code>,
        la tercera <code>73</code>, la cuarta <code>19</code> y la quinta <code>null</code>.
    </p>
    <div class="important">
        <p>
            <strong>Importante:</strong> <code>Repetition Levels</code> y <code>Definition Levels</code> son sin embargo mucho mÃ¡s complicados, un poco mÃ¡s adelante.<br/>
        </p>
    </div>
    <p>
        AsÃ­ mÃ¡s o menos se presenta la estructura de <code>DataPage</code>.
    </p>
    <h3><code>DictionaryPage</code></h3>
    <p>
        Si los datos los guardamos en <code>DataPage</code>, Â¿quÃ© propÃ³sito tiene <code>DictionaryPage</code>?<br/>
        Bueno, <code>DictionaryPage</code> es una pÃ¡gina que contiene un diccionario de valores.<br/>
        Diccionario, usado para leer datos, especialmente en el caso de columnas que contienen valores repetibles.
    </p>

    <p>
        Funciona mÃ¡s o menos asÃ­, que leyendo <code>ColumChunk</code>, empezamos desde la primera pÃ¡gina, si esta pÃ¡gina es <code>DictionaryPage</code>,
        sabemos que estamos lidiando con un diccionario (en realidad lo sabemos desde el principio, porque estÃ¡ escrito en los metadatos de la columna).
    </p>
    <p>
        Si por ejemplo leemos una columna con alta repetibilidad, ej. una columna con nombre de paÃ­s, en lugar de escribir en <code>DataPage</code> el nombre completo del paÃ­s para cada fila,
        escribimos solo su posiciÃ³n en el diccionario.<br/>
        En el caso de tal columna la primera pÃ¡gina en la columna serÃ¡ <code>DictionaryPage</code>, y las siguientes serÃ¡n <code>DataPage</code>.
    </p>
    <p>
        La diferencia es que en <code>DataPage</code> en lugar del valor completo, habrÃ¡ posiciones en el diccionario, que mantendremos en memoria para reconstruir las filas.<br/>
    </p>
    <div class="important">
        <p>
            <strong>Importante:</strong> Cada <code>ColumnChunk</code> puede contener solo una pÃ¡gina <code>DictionaryPage</code>.
        </p>
    </div>
    <p>
        Esto puede dar ahorros enormes, en lugar de digamos escribir de forma binaria la palabra <code>Polonia</code> 10 mil veces, es decir, 60k bytes,
        escribiremos solo la posiciÃ³n en el Ã­ndice (es decir, 4 bytes), que adicionalmente serÃ¡n empaquetados usando el algoritmo <a href="https://parquet.apache.org/docs/file-format/data-pages/encodings/#RLE" target="_blank">Run Length Encoding / Bit-Packing Hybrid</a>.
        Que, tambiÃ©n basÃ¡ndose en la repetibilidad de valores consecutivos reducirÃ¡ la cantidad total de bytes necesarios.
    </p>

    <h3><code>IndexPage</code></h3>
    <p>
        El Ãºltimo tipo de pÃ¡gina es <code>IndexPage</code>.<br/>
        Esta pÃ¡gina no contiene datos, por lo que no es necesaria para lectura ni escritura.<br/>
        Cada <code>ColumnChunk</code> puede contener solo una pÃ¡gina tipo <code>IndexPage</code> y siempre se encuentra al final, despuÃ©s de <code>DictionaryPage</code> y todas las <code>DataPage</code>.
    </p>
    <p>
        El propÃ³sito de esta pÃ¡gina es almacenar estadÃ­sticas sobre <code>ColumnChunk</code>, como valores <code>Min/Max</code>, cantidad de <code>nulls</code> o manera de ordenamiento para cada pÃ¡gina en un <code>ColumnChunk</code> especÃ­fico.
        Esto permite filtrado rÃ¡pido y encontrar solo pÃ¡ginas especÃ­ficas dentro de un <code>ColumnChunk</code> dado, lo que acelera significativamente la bÃºsqueda en el archivo, si nos interesan informaciones especÃ­ficas.
    </p>
    <div class="notice">
        <p>
            <strong>AtenciÃ³n:</strong> Cada <code>ColumnChunk</code> en sus metadatos contiene estadÃ­sticas similares a <code>IndexPage</code>, pero no para cada pÃ¡gina sino para todo el <code>ColumnChunk</code>.<br/>
            Gracias a esto, en primera instancia podemos saltar columnas completas que no nos interesan y luego incluso pÃ¡ginas especÃ­ficas, reduciendo al mÃ­nimo absoluto la cantidad de datos que tenemos que leer.
        </p>
    </div>

    <p>
        Considerando que esta informaciÃ³n se encuentra en los metadatos del archivo, incluso los archivos Parquet mÃ¡s grandes pueden ser leÃ­dos y filtrados instantÃ¡neamente incluso si solo estÃ¡n disponibles a travÃ©s de la red.<br/>
        Es suficiente que logremos leer los metadatos, en base a ellos localizar un grupo especÃ­fico de filas, luego una columna seleccionada y al final pÃ¡ginas especÃ­ficas. <br/>
        Obtendremos de esta manera una localizaciÃ³n muy precisa de nuestros datos, que podremos leer usando el encabezado <code>Http Range Header</code>.
    </p>
    <p>
        Esta es precisamente una de las razones por las que Parquet es tan poderoso, ya no hablamos de descargar brutalmente e iterar sobre un archivo de gigabytes. Parquet permite con precisiÃ³n de cirujano
        descargar y leer solo las Ã¡reas del archivo que realmente nos interesan.
    </p>

    <a href="#dremel"><h2 id="dremel">Dremel</h2></a>

    <p>
        Discutiendo la estructura de <code>DataPage</code> mencionÃ© <code>Definition Levels</code> y <code>Repetition Levels</code>.
    </p>
    <p>
        El ejemplo discutido fue muy simple, porque se referÃ­a a una columna simple (int32), por lo que <code>Repetition Levels</code> no tienen aplicaciÃ³n en absoluto.<br/>
        La situaciÃ³n cambia diametralmente cuando estamos lidiando con una columna anidada, ej. estructura, lista o mapa.
        Veamos un ejemplo.
    </p>
    <p>
        <code>[{"sku":"abc", "quantity": 1, "price": 100}, {"sku":"def", "quantity": 2, "price": 200}]</code>
    </p>
    <p>
        Volviendo a la parte anterior de este artÃ­culo, especÃ­ficamente a <a href="#nested-types">tipos anidados</a>.<br/>
        Sabemos que nuestros datos despuÃ©s del aplanamiento se verÃ¡n asÃ­:
    </p>
    <ul>
        <li><code>items.list.element.sku</code> - <code>"abc","def"</code></li>
        <li><code>items.list.element.quantity</code> - <code>1,2</code></li>
        <li><code>items.list.element.price</code> - <code>100,200</code></li>
    </ul>
    <p>
        Tenemos aquÃ­ 3 columnas, cada una de ellas estarÃ¡ en un <code>Column Chunk</code> separado y cada una contendrÃ¡
        una o mÃ¡s pÃ¡ginas.
    </p>
    <p>
        Entonces, Â¿cÃ³mo basÃ¡ndose en estos dos valores (<code>Repetition / Definition Levels)</code> las bibliotecas que leen archivos saben quÃ© tan profundo en la estructura estÃ¡n los valores y a quÃ© elemento pertenecen?<br/>
        Â¿QuÃ© pasa si nuestra estructura se viera asÃ­:
    </p>
    <p>
        <code>[{"sku":"abc", "quantity": 1, "price": 100}, {"sku":null, "quantity": 10, "price": 100}, {"sku":"def", "quantity": 2, "price": 200}]</code>
        (en el segundo elemento sku tiene valor null). <br/>
    </p>
    <p>Â¿QuÃ© pasa cuando la estructura estÃ¡ mucho mÃ¡s anidada, cÃ³mo sabemos quÃ© valor va a quÃ© nivel de anidamiento?</p>
    <p>
        La respuesta a esta y muchas otras preguntas la encontraremos en el documento publicado por Google <a href="https://static.googleusercontent.com/media/research.google.com/pl//pubs/archive/36632.pdf" target="_blank">Dremel: Interactive Analysis of Web-Scale Datasets</a>
        que describe cÃ³mo Google almacena y busca estructuras de datos anidadas.
    </p>
    <p>
        La herramienta usada por Google se llama Dremel y es un sistema distribuido de bÃºsqueda de grandes conjuntos de datos. <br/>
        Se basa en 2 algoritmos, <code>Shredding</code> y <code>Assembling</code>, que estÃ¡n descritos muy brevemente en el documento anterior.
    </p>
    <div class="notice">
        <p>
            <strong>AtenciÃ³n:</strong> Describir el funcionamiento exacto de estos algoritmos estÃ¡ fuera del alcance de este ya largo artÃ­culo.<br/>
            Si aparece interÃ©s en el tema, tratarÃ© de abordar tambiÃ©n este hilo en prÃ³ximos artÃ­culos.
        </p>
    </div>
    <p>
        Estos algoritmos se basan en estas 3 definiciones:
    </p>
    <ul>
        <li>Repetition Levels</li>
        <li>Definition Levels</li>
        <li>Values</li>
    </ul>
    <p>
        Como ya mencionamos <code>Definition Level</code> determina si una fila dada contiene un valor, o no, <code>Repetition Level</code> que en el caso de columnas planas siempre es 0.
        Para estructuras determinarÃ¡ si el valor (o null) debe ser repetido, y en quÃ© nivel de profundidad.
    </p>
    <div class="notice">
        <p>
            <strong>AtenciÃ³n:</strong> El conocimiento de cÃ³mo funcionan exactamente los algoritmos de Dremel, no es necesario para el uso Ã³ptimo de Parquet.<br/>
            Por esta razÃ³n, no me extenderÃ© sobre este tema, sin embargo, si aparece interÃ©s en el tema, tratarÃ© de abordar tambiÃ©n este hilo en prÃ³ximos artÃ­culos.
        </p>
    </div>
    <p>
         Abajo presentarÃ© solo mÃ¡s o menos cÃ³mo se verÃ¡n los datos aplanados.
    </p>
    <pre>
        <code class="code-shell" data-controller="syntax-highlight">Input:
[
    &#039;items&#039; =&gt; [
        [&#039;sku&#039; =&gt; &#039;abc&#039;, ...],
        [&#039;sku&#039; =&gt; &#039;def&#039;, ...],
    ]
]

Output:
{
  [&quot;sku&quot;] =&gt;
  {
    [&quot;repetition_levels&quot;] =&gt; { [0] =&gt; int(0) [1] =&gt; int(1) }
    [&quot;definition_levels&quot;] =&gt; { [0] =&gt; int(1) [1] =&gt; int(1) }
    [&quot;values&quot;] =&gt; { [0] =&gt; string(3) &quot;abc&quot; [1] =&gt; string(3) &quot;def&quot; }
  }
}</code>
    </pre>
    <p>
        Es decir, en realidad escribimos <code>0, 1, 0, 1, "abc", "def"</code> y no solo <code>"abc", "def"</code>. <br/>
        Son precisamente estos nÃºmeros adicionales los que dicen cÃ³mo reconstruir cualquier estructura anidada.
    </p>
    <p>
        Es curioso que incluso los repetition levels y definition levels para optimizaciÃ³n son empaquetados apropiadamente usando el algoritmo
        <a href="https://parquet.apache.org/docs/file-format/data-pages/encodings/#RLE" target="_blank">Run Length Encoding / Bit-Packing Hybrid</a>.
    </p>
    <p>
        AhÃ­ no termina, porque no solo los niveles son empaquetados, sino tambiÃ©n los valores mismos.<br/>
        Dependiendo del tipo de columna, los valores pueden ser empaquetados de diferentes maneras, la lista de todos los algoritmos de empaquetado soportados por Parquet (al menos en teorÃ­a) la encontraremos
        <a href="https://parquet.apache.org/docs/file-format/data-pages/encodings" target="_blank">en la documentaciÃ³n oficial</a>.
    </p>
    <p>
        Mientras que la informaciÃ³n sobre quÃ© algoritmo se usÃ³ para empaquetar los datos antes de escribir la encontraremos en los metadatos, bajo tal ruta <code>RowGroups[x].ColumnChunk[y].PageHeader[z].data_page_header.encoding</code>
    </p>
    <p>
        Â¡Pero esta no es la Ãºltima palabra de Parquet en el contexto de optimizaciÃ³n!
    </p>
    <a href="#compression"><h2 id="compression">CompresiÃ³n</h2></a>
    <p>
        DespuÃ©s de empaquetar y escribir en forma binaria nuestros datos para una pÃ¡gina especÃ­fica, cada pÃ¡gina es adicionalmente comprimida.
    </p>
    <p>
        Dependiendo de la implementaciÃ³n Parquet permite el uso de diferentes algoritmos de compresiÃ³n:
    </p>
    <ul>
        <li>UNCOMPRESSED</li>
        <li>SNAPPY</li>
        <li>GZIP</li>
        <li>LZO</li>
        <li>BROTLI</li>
        <li>LZ4</li>
        <li>ZSTD</li>
        <li>LZ4_RAW</li>
    </ul>
    <p>
        Una opciÃ³n muy popular es <a href="https://github.com/google/snappy" target="_blank">Snappy</a>, que ofrece un muy buen compromiso entre velocidad y grado de compresiÃ³n.
    </p>
    <p>
        Herramientas como <a href="https://spark.apache.org/" target="_blank">Apache Spark</a> incluso lo usan por defecto.
    </p>
    <a href="#encryption"><h2 id="encryption">Cifrado</h2></a>
    <p>
        Una de las Ãºltimas caracterÃ­sticas interesantes que quiero discutir es Â¡el cifrado!
    </p>
    <p>
        SÃ­, Parquet permite cifrar datos, cifrar en mÃºltiples niveles.
    </p>
    <ul>
        <li>Metadatos - metadatos cifrados efectivamente dificultan la lectura del contenido del archivo, pero no es imposible</li>
        <li>Datos - datos cifrados prÃ¡cticamente imposibilitan la lectura</li>
        <li>Columnas - especialmente Ãºtil si solo algunas columnas contienen datos sensibles.</li>
        <li>PÃ¡ginas</li>
    </ul>
    <div class="notice">
        <p>
            <strong>AtenciÃ³n:</strong> El cifrado es una de esas caracterÃ­sticas que aÃºn no he cubierto en <a href="https://flow-php.com/documentation/components/libs/parquet/">la implementaciÃ³n para PHP</a><br/>
            Por esta razÃ³n no me extenderÃ© sobre este tema, tan pronto como tenga la oportunidad de implementar esta funcionalidad, tratarÃ© de completar el artÃ­culo.
        </p>
    </div>
    <p>
        El cifrado en Parquet se basa en <a href="https://parquet.apache.org/docs/file-format/data-pages/encryption/" target="_blank">Parquet Modular Encryption</a> y utiliza
        <a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf" target="_blank">AES</a> para cifrar datos.
    </p>
    <p>
        El cifrado, especialmente de columnas seleccionadas, eleva Parquet a un nivel superior de almacenamiento de datos. <br/> Gracias a esto de manera relativamente fÃ¡cil, con poco overhead,
        podemos proteger adicionalmente los datos que almacenamos en archivos Parquet. <br/>
    </p>
    <p>
        Imaginemos que Parquet se usa para almacenar datos de clientes, donde la columna <code>email</code> y <code>phone</code> contienen datos sensibles.<br/>
        En esta situaciÃ³n, se pide que estas dos columnas estÃ©n adicionalmente protegidas. Incluso si alguien logra obtener acceso fÃ­sico al archivo, sin la clave aÃºn no
        podrÃ¡ leer los datos.
    </p>
    <a href="#summary"><h2 id="summary">Resumen</h2></a>
    <p>
        Ese es precisamente el secreto de Parquet y la forma de lograr eficiencia. En lugar de almacenar datos arbitrarios en forma textual, Parquet va varios pasos mÃ¡s allÃ¡. <br/>
        En primera instancia fuerza un esquema de datos basado en tipos simples pero increÃ­blemente flexibles, cada uno de los cuales puede ser
        representado en forma binaria.<br/>
        Luego la forma binaria es apropiadamente empaquetada, para evitar repeticiones innecesarias de bytes, lo que al final es
        adicionalmente comprimido usando algoritmos muy eficientes.<br/>
        La cereza del pastel son los metadatos avanzados y detallados, disponibles en varios niveles, permitiendo filtrar
        particiones innecesarias, o incluso archivos completos sin leer su contenido.
    </p>
    <p>
        AdemÃ¡s, gracias a la divisiÃ³n lÃ³gica apropiada, sobre la cual tenemos control completo (tamaÃ±o de grupos y pÃ¡ginas) podemos
        decidir quÃ© es mÃ¡s importante para nosotros, velocidad o ahorro de memoria. BÃºsqueda o lectura de datos o tal vez
        seguridad, para la cual utilizaremos cifrado adicional.
    </p>
    <p>
        Parquet es realmente una herramienta poderosa que en las manos correctas permite el almacenamiento y bÃºsqueda eficiente
        de enormes cantidades de datos.<br/>
    </p>
    <p>
        Si este artÃ­culo te inspirÃ³ a experimentar con este formato de datos revelador, Â¡hazme saber en los comentarios!
    </p>
    <a href="#help"><h2 id="help">Ayuda</h2></a>
    <p>
        Si necesitas ayuda en la construcciÃ³n de un almacÃ©n central de datos, estarÃ© encantado de ayudarte.<br/>
        <a href="https://norbert.tech/consulting">ContÃ¡ctame</a>, y juntos crearemos una soluciÃ³n que se adapte perfectamente a tus necesidades.
    </p>
    <p>
        TambiÃ©n te animo a visitar el servidor <a href="https://discord.gg/5dNXfQyACW" target="_blank">Discord - Flow PHP</a>, donde
        podemos hablar directamente.
    </p>
    <div class="img-wide">
        <img src="https://norbert.tech/assets/images/blog/analytics-in-transactional-distributed-systems/consulting_01-fa277dfb3736a033cbfcf1ac931afb08.jpg" alt="ConsultorÃ­a" />
    </div>

    </article>
    <div class="mb-2 mx-auto max-w-screen-lg text-center">
        <script src="https://giscus.app/client.js"
                data-repo="norberttech/norbert.tech"
                data-repo-id="MDEwOlJlcG9zaXRvcnkyMjQ0MDQwNDA="
                data-category="Comments"
                data-category-id="DIC_kwDODWAiSM4CionD"
                data-mapping="pathname"
                data-strict="0"
                data-reactions-enabled="0"
                data-emit-metadata="0"
                data-input-position="bottom"
                data-theme="light"
                data-lang="en"
                crossorigin="anonymous"
                async>
        </script>
    </div>
    </main>

    <footer class="p-4 bg-sky-50 absolute bottom-0 w-full">
        <div class="mx-auto max-w-screen-2xl text-center">
            <a href="/">by @norbert_tech</a>
        </div>
    </footer>
</body>
</html>